
# ==> ./Dynamic_Programming/0010.Regular-Expression-Matching/Readme.md <==
snippet 0010.Regular-Expression-Matching "0010.Regular-Expression-Matching" b
### 010.Regular-Expression-Matching

此题带有很明显的DP解法的特征，dp[i][j]就代表s[1..i]和p[1...j]的字符串是否匹配。（以1-index为起点）

我们逐个分析一下：

1.如果p[j]是字母，那么s[i]必须是与其相同的字母才行。所以写成表达式 ```dp[i][j] = (s[i]==p[j] && dp[i-1][j-1])```

2.如果p[j]是'.'，那么s[i]可以是任意字母。所以写成表达式 ```dp[i][j] = dp[i-1][j-1]```

3.如果p[j]是'*'，那么星号的作用有两种情况。

第一种可以认为是重复0次，即考虑s[1..i]和p[1..j-2]是否匹配。那么记录 ```prob1 = dp[i][j-2]```

第二种可以认为是重复了若干次。不管重复了几次，都要求s[i]必须是与p[j-1]相匹配的字母。这说明什么呢？刨除s[i]之外，前面的字符串也必须与p[1..j]匹配。所以记录 ```prob2 = (s[i]==p[j-1]||p[j-1]=='.') && dp[i-1][j]```. 注意之前说的“s[i]必须是与p[j-1]相匹配”，不仅仅指二者是相同的字母，后者也可以是'.'。

那么综上，第3点情况下，dp[i][j] = prob1 || prob2

以上搭起了dp方程的框架。
```cpp
        for (int i=1; i<=M; i++)
            for (int j=1; j<=N; j++)
            {
                if (isalpha(p[j]))
                {
                    dp[i][j] = (s[i]==p[j] && dp[i-1][j-1]);
                }
                else if (p[j]=='.')
                {
                    dp[i][j] = dp[i-1][j-1];
                }
                else if (p[j]=='*')
                {
                    bool temp1 = dp[i][j-2];
                    bool temp2 = dp[i-1][j] && (s[i]==p[j-1] || p[j-1]=='.');
                    dp[i][j] = temp1 || temp2;
                }                
            }
```            
接下来我们考虑边界条件。我们注意到上面框架中有几处可能的越界情况：
1. 当j==1时，dp[i][j-2]的第二个下标未定义。但是我们发现当j==1时，p[j]不可能是星号，否则不是合法的表达式。所以这种边界情况我们不用担心。
2. 当j==2时，dp[i][j-2]的第二个下标未定义。所以我们需要考虑dp[i][0]的情况。这种情况下应该都是false，包含在了初始值中。
3. 当i==1时，dp[i-1][j]的第一个下表未定义。所以我们需要考虑dp[0][j]的情况。这对于p来说只可能是非常特殊的一类字符，即类似"a\*b\*c\*"这类的，并且这里的星号都代表重复零次。其他任何p的表达式都不可能被parse成为一个空字符串。所以我们只要对这一类特殊情况做判断就行。

与此题类似的还有044.Wildcard Matching，其边界条件也很类似，需要特别小心．


[Leetcode Link](https://leetcode.com/problems/regular-expression-matching)
$0
endsnippet

# ==> ./Dynamic_Programming/0010.Regular-Expression-Matching/10.Regular-Expression-Matching.cpp <==
snippet 0010.Regular-Expression-Matching "0010.Regular-Expression-Matching" b
class Solution {
public:
    /**
     * @param s: A string 
     * @param p: A string includes "." and "*"
     * @return: A boolean
     */
    bool isMatch(string &s, string &p) 
    {
        int M = s.size();
        int N = p.size();
        s = "0"+s;
        p = "0"+p;
        auto dp = vector<vector<int>>(M+1,vector<int>(N+1,0));
        dp[0][0] = 1;
        for (int j=2; j<=N; j++)
        {
            if (p[j]=='*') dp[0][j]=dp[0][j-2];
        }
        
        for (int j=1; j<=N; j++)
            for (int i=1; i<=M; i++)
            {
                if (isalpha(p[j]))
                {
                    dp[i][j] = (s[i]==p[j] && dp[i-1][j-1]);
                }
                else if (p[j]=='.')
                {
                    dp[i][j] = dp[i-1][j-1];
                }
                else if (p[j]=='*')
                {
                    bool temp1 = dp[i][j-2];
                    bool temp2 = dp[i-1][j] && (s[i]==p[j-1] || p[j-1]=='.');
                    dp[i][j] = temp1 || temp2;
                }
                
                //cout<<i<<" "<<j<<" "<<dp[i][j]<<endl;
            }
        return dp[M][N];
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/0044.Wildcard-Matching/Readme.md <==
snippet 0044.Wildcard-Matching "0044.Wildcard-Matching" b
### 044.Wildcard-Matching

这道题的入手点是当做双序列的DP问题来做。设计dp[i][j]表示s的前i个元素、p的前j个元素能否匹配。（注意，预先调整成为1-index）

分析转移方程的时候，依然是关注s的第i个元素，p的第j个元素。其中p[j]是关键，因为它可能是通配符。所以常规的思路是：
1. 如果p[j]='?'，它必须匹配s的第i个元素，显然dp[i][j]=dp[i-1][j-1].
2. 如果p[j]='*'，它可以匹配s结尾的任意多个元素，所以有：
```cpp
for (int k=0; k<=i; k++)
  if (dp[k][j-1]==1) dp[i][j]=1;
```
3. 如果p[j]是普通字符，则必须与s的第i各元素完全一致。所以
```cpp
if (s[i]==p[j])
  dp[i][j]=dp[i-1][j-1]
```

接下来考虑两个问题。首先是边界条件。最常见的dp[0][0]=1是必然的。但同时要注意到第二种情况时，我们会查看dp[0][j-1]，而这个是未定义的。事实上dp[0][x]对任何的j而言不一定是0，比如当
```
s = ""
p = ****
```
所以我们需要对所有的dp[0][x]设计初始值。只有当p的前若干个都是星号时，才有dp[0][x]=1.

另外一个问题，就是如何改进第二种情况。用一个for循环是比较低效的，其实有一个更优秀的判定手段。

我们知道，当p[j]=='\*'的前提下，我们有```dp[i][j] = dp[0][j-1] || dp[1][j-1] || dp[2][j-1] || ... || dp[i-1][j-1] || dp[i][j-1]```。

我们将i用i-1替换，就同理可以写出```dp[i-1][j] = dp[0][j-1] || dp[1][j-1] || dp[2][j-1] || ... || dp[i-1][j-1]```。

用第二式替换第一式右边的大部分项，就有```dp[i][j] = dp[i-1][j] || dp[i][j-1]```.惊喜不惊喜？

$0
endsnippet

# ==> ./Dynamic_Programming/0044.Wildcard-Matching/044.Wildcard-Matching.cpp <==
snippet 0044.Wildcard-Matching "0044.Wildcard-Matching" b
class Solution {
public:
    bool isMatch(string &s, string &p) 
    {
        int M = s.size();
        int N = p.size();
        s="0"+s;
        p="0"+p;
        auto dp = vector<vector<int>>(M+1,vector<int>(N+1,0));        

        dp[0][0] = 1;
        for (int j=1; j<=N; j++)
        {
            if (p[j]!='*') break;
            dp[0][j] = 1;
        }
        
        for (int i=1; i<=M; i++)
            for (int j=1; j<=N; j++)
            {
                if (p[j]=='?')
                    dp[i][j] = dp[i-1][j-1];
                else if (p[j]=='*')
                {
                    // for (int k=0; k<=i; k++)
                    //     if (dp[k][j-1]==1) dp[i][j]=1;
                    dp[i][j] = dp[i][j-1]||dp[i-1][j];
                }
                else if (s[i]==p[j])
                    dp[i][j] = dp[i-1][j-1];
            }
        
        return dp[M][N];
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/0053.Maximum-Subarray/Readme.md <==
snippet 0053.Maximum-Subarray "0053.Maximum-Subarray" b
### 053.Maximum-Subarray

本题是一道经典题，其算法类似动态规划，称之为Kadane算法。

我们考虑每个以i截止的maximum subarray是什么？显然对于i而言，它只有两种选择：
1. 这样的subarray里面，i是接在元素i-1后面。为了使得subarray最大，自然问题就转化为希望得到以i-1结尾的maximum subarray。
2. 这样的subarray里面，i不是接在前一个元素之后。这就意味着自己是这个maximum subarray中的唯一一个元素。

所以，我们定义dp[i]表示以元素i结尾的maximum subarray的和。那么dp[i]就是上面两种方案中取较大的值。因为我们并不知道全局最大的subarray的截止点在哪里，所以最终的答案就是所有dp[i]中的最大值。

$0
endsnippet

# ==> ./Dynamic_Programming/0053.Maximum-Subarray/053.Maximum-Subarray.cpp <==
snippet 0053.Maximum-Subarray "0053.Maximum-Subarray" b
class Solution {
public:
    int maxSubArray(vector<int>& nums) 
    {
        int n = nums.size();                
        vector<int>dp(n);
        dp[0] = nums[0];
        int ret = nums[0];
        
        for (int i=1; i<n; i++)
        {
            dp[i] = max(dp[i-1]+nums[i], nums[i]);                
            ret = max(dp[i],ret);
        }
        
        return ret;        
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/0072.Edit-Distance/Readme.md <==
snippet 0072.Edit-Distance "0072.Edit-Distance" b
### 072.Edit-Distance

此题类似097.Interleaving String，用DP来实现两个数组的某项功能关系。用dp[i][j]分别表示数组A取前i位、数组B取前j位时的目标函数（所需的最小edit次数），想办法找出其与dp[i-1][j]或dp[i][j-1]或dp[i-1][j-1]或以上所有的递推关系。

对于dp[i][j]，常规思路是考虑数组A的第i位，数组B的第j位。一个最直接的想法是：如果word1[i]==word2[j]，那么显然dp[i][j]=dp[i-1][j-1]，轻而易举地把锅甩给了低一个量级的子问题。

那么如果word1[i]!=word2[j]呢？显然，若想递进到dp[i][j]的话，可以尝试从dp[i-1][j]入手：因为dp[i-1][j]表示word1[1\~i-1]和word2[1\~j]匹配的操作数，那么如果想再加上word1[i]并强行保持匹配，那么就只有将word1[i]删除这步操作。同理，考虑从dp[i][j-1]入手，将word2删除第j个字符即可等同于dp[i][j-1]的情况。第三个方案是从dp[i-1][j-1]入手，在此基础上将word1的第i个字符直接替换为word2的第j个字符，同样可以使两者匹配成功。

综上，粗浅的递推关系很容易写出来（以1为index的起点）：
```cpp
for (int i=1; i<=n1; i++)
 for (int j=1; j<=n2; j++)
 {
     if (word1[i]==word2[j])
        dp[i][j]==dp[i-1][j-1];
     else
        dp[i][j]=min(min(dp[i-1][j],dp[i][j-1]),dp[i-1][j-1])+1;     
 }
```
输出的结果是dp[n1][n2].

现在考虑边界条件。发现当i=1, j=1时，上述递推关系式中需要用dp[i][0] (for all i), dp[0][j] (for all j). 因此我们特别考虑一下他们。很明显dp[i][0]表示子串A有i位，子串B有零位，显然只需要在子串添加i个相应的字符即可匹配字符串A，所以dp[i][0]=i。同理，dp[0][j]=j。更特殊一点，dp[0][0]=0.


[Leetcode Link](https://leetcode.com/problems/edit-distance)
$0
endsnippet

# ==> ./Dynamic_Programming/0072.Edit-Distance/072.Edit-Distance.cpp <==
snippet 0072.Edit-Distance "0072.Edit-Distance" b
class Solution {
public:
    int minDistance(string word1, string word2) 
    {
        int n1=word1.size();
        int n2=word2.size();
        word1.insert(word1.begin(),'0');
        word2.insert(word2.begin(),'0');
        
        auto dp=vector<vector<int>>(n1+1,vector<int>(n2+1,INT_MAX));        
        
        dp[0][0]=0;
        for (int i=1; i<=n1; i++)
            dp[i][0]=i;
        for (int j=1; j<=n2; j++)
            dp[0][j]=j;
        
        for (int i=1; i<=n1; i++)
         for (int j=1; j<=n2; j++)
         {
             if (word1[i]==word2[j])
                 dp[i][j]=dp[i-1][j-1];
             else
             {
                 dp[i][j]=min(dp[i][j],dp[i-1][j]+1);
                 dp[i][j]=min(dp[i][j],dp[i][j-1]+1);
                 dp[i][j]=min(dp[i][j],dp[i-1][j-1]+1);
             }                 
         }
        
        return dp[n1][n2];
    }

    /**
     * @brief calculate the minimum edit distance between word1 and word2
     * Another implementation of edit distance with compressed memory usage
     * @param word1 const std::string &   The reference of first string
     * @param word2 const std::string &   The reference of second string
     * @return The edit distance
     */
    int minDistance2(const std::string &word1, const std::string &word2)
    {
      int n1=word1.size();
      int n2=word2.size();

      // dp[i][j] : edit distance between word1[0, i) and word2[0, j)
      // dp[i][j] = std::min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1
      //                     ----------  ---------- -------------
      //                       add-j       delete-j   replace-j
      //  if word1[i] != word2[j]
      // Compressed to
      // dp[j]

      std::vector<int> dp(n2+1, 0);

      for (auto j = 1; j <= n2; ++j)
        dp[j] = j; // distance between word1[0, 0) and word2[0, j), j deletions

      for (auto i = 1; i <= n1; ++i)
      {
        int topleft = dp[0];
        // reset dp[i]
        dp[0] = i; // edit distance = j add operations

        for (auto j = 1; j <= n2; ++j)
        {
          int top = dp[j];

          if (word1[i-1] == word2[j-1])
            dp[j] = topleft;
          else
            dp[j] = std::min({dp[j-1], top, topleft}) + 1;
            //                -------- --- ---------
            //                delete-j add-j replace-j

          topleft = top; // move the top 1 step to the right
        }
      }

      return dp.back();
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/0091.Decode-Ways/Readme.md <==
snippet 0091.Decode-Ways "0091.Decode-Ways" b
### 091.Decode-Ways

非常典型的DP问题。dp[i]= dp[i-2] （如果最后两位合法） + dp[i-1] （如果最后一位合法）

最后两位合法存在，指的是数字在10和26之间；最后一位合法存在，指的是不能为0.

为了方便书写，可以将字符串额外在首端添加一个零。这样dp[i]表示的就是s[i]的第i位所代表的结果，且dp[0]是边界条件。

另外特别注意的是：
1. 边界条件dp[0]=1而不是0.
2. dp[1]需要单独计算。dp[2]以后可以有通用表达式。


[Leetcode Link](https://leetcode.com/problems/decode-ways)
$0
endsnippet

# ==> ./Dynamic_Programming/0091.Decode-Ways/091.Decode_Ways.cpp <==
snippet 0091.Decode-Ways "0091.Decode-Ways" b
class Solution {
public:
    int numDecodings(string s) 
    {
        if (s.size()==0) return 0;
        
        int N =s.size();
        s = "#"+s;
        vector<int>dp(N+1,0);
        
        dp[0] = 1;
        dp[1] = s[1]=='0'? 0:1;
        
        for (int i=2; i<=N; i++)
        {
            // Check if s[i] alone can stand for a letter
            if (s[i]!='0')
            {
                dp[i] += dp[i-1];
            }
            
            // Check if s[i-1:i] can stand for a letter
            if (s[i]>='0' && s[i]<='6' && (s[i-1]=='1'||s[i-1]=='2'))
                dp[i]+=dp[i-2];
            else if (s[i]>='7' && s[i]<='9' && s[i-1]=='1')
                dp[i]+=dp[i-2];
            
            // cout<<i<<" "<<dp[i]<<endl;
        }
        
        return dp[N];
        
    }
};


$0
endsnippet

# ==> ./Dynamic_Programming/0096.Unique-Binary-Search-Trees/Readme.md <==
snippet 0096.Unique-Binary-Search-Trees "0096.Unique-Binary-Search-Trees" b
### 096.Unique-Binary-Search-Trees

首先我们考虑根节点的选择。如果我们选择数字k作为根节点，那么左子树必然由节点1~k-1组成，左子树必然由节点k+1~n组成。接下来左右子树的构建就是一个递归问题。构建完左右子树之后，以k为根节点的BST的个数就是左子树个数乘以右子树个数（两两组合）。

我们可以用dp的解法。令dp[k]表示给定n个节点可以构成多少个BST。根据上面的思路，我们先loop作为根节点的数值，然后递归调用dp
```cpp
dp[n] = 0;
for (int k=1; k<=n; k++)
  dp[n] += dp[k-1]*dp[n-1-k]; 
```
以上得到的序列```h[0]=1, h[1]=1, h[2]=3, h[3]=5, ...```就是著名的Catalan数。

Catalan数其实有更肩接的递归公式和通项公式：
```
h(n) =  h(n-1) * (4n-2)/(n+1)
h(n) =  C(2n,n) - C(2n, n-1),  其中C是组合数
```

类似的题目有很多.

#### follow up 1
给你N个节点，能构造出多少种不同结构的树？

这个和给你N个元素的数列，能构造出多少种不同结构的BST没有区别。因为任何一种普通树，只要合理填充节点val，都可以是BST。

#### follow up 2
给你n对括号，能构造出多少合法的序列？

我们考虑第一对括号里面包含多少个nested括号？假设是k个，那么第一对括号之后，需要构造一个有n-1-k对括号组成的合法序列。遍历所有k的可能，可以得到类似的dp转移方程：
```cpp
for (int k=0; k<=n-1; k++)
  dp[n] += dp[k]*dp[n-1-k]; 
```
答案依然是Catalan数h(n).

#### follow up 3
满二叉树定义是：每个节点要么是叶子节点，要么有两个子节点。如果节点总数是2n+1. 问能构造出多少不同结构的满二叉树？

首先想一下为什么节点总数是奇数？是因为满二叉树里，除了根节点，所有的节点都会有姐妹；所以算上根节点，总数必然是奇数个。OK，接下来，节点数目是2n+1的树，边的个数一定是2n。同理分析，每一条边必然也会有它的姐妹，也就是每一条指向左孩子的边，都会有一条指向右孩子的边。

我们现在只需要想象一下进行先序遍历时，走边的过程。假设指向左孩子的边对应左括号，指向有孩子的边对应右括号，那么每种不同结构的满二叉树的先序遍历（先走左边，再走右边），都一一对应着一种合法的左右括号序列。考虑到2n条边对应着n对括号，所以此题的答案还是Catalan数h(n)。

这道题还可以变形为：如果叶子节点总数是n+1，问能构造出多少不同结构的满二叉树？

$0
endsnippet

# ==> ./Dynamic_Programming/0096.Unique-Binary-Search-Trees/096.Unique-Binary-Search-Trees.cpp <==
snippet 0096.Unique-Binary-Search-Trees "0096.Unique-Binary-Search-Trees" b
class Solution {
public:
    int numTrees(int n) 
    {
        vector<int>dp(n+1);
        dp[0] = 1;
        dp[1] = 1;
        for (int i=2; i<=n; i++)
        {
            dp[i] = 0;
            for (int j=0; j<=i-1; j++)
                dp[i] += dp[j]*dp[i-1-j];
        }
        return dp[n];        
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/0097.Interleaving-String/Readme.md <==
snippet 0097.Interleaving-String "0097.Interleaving-String" b
### 097.Interleaving-String

这种可行性的问题，直觉就是DP。而且此题很明显，是否是s1,s2,s3是否满足交叉子串，必然取决于他们的上一级（少一个字符）状态是否满足交叉子串。

程序最开始，一个快速的判别条件是 n1+n2==n3，不满足的立即退出。

设置状态数组dp[i][j]，表示s1的前i个字符、s2的前j个字符、s3的前i+j个字符，是否满足交叉子串的关系。其中i=1,2,..,n1，j=1,2,..,n2

状态转移方程很容易写，我们先粗浅地写出来：
```cpp
        for (int i=1; i<=n1; i++)
         for (int j=1; j<=n2; j++)
         {
             if (dp[i-1][j]==1 && s1[i]==s3[i+j])
                 dp[i][j]=1;
             else if (dp[i][j-1]==1 && s2[j]==s3[i+j])
                 dp[i][j]=1;
         }
```
考虑边界条件。从上述的转移方程中可以发现需要提前设置dp[i][0](for all i)和dp[0][j](for all j)。

dp[i][0]表示从s1里取前i个，是否能与s3的前i个组成交叉子串。显然就是判断s1和s3是否逐位相等。这包含了另一个准动态规划小问题。
```cpp
   for (int i=1; i<=n1; i++)
   {
       if (dp[i-1][0]==1 && s1[i]==s3[i])
          dp[i][0]=1;
   }
```
同理可以设置dp[0][j]。

注意到这两个小问题又都要涉及到边界条件dp[0][0]。这个条件需要dp[0][0]=1.


[Leetcode Link](https://leetcode.com/problems/interleaving-string)
$0
endsnippet

# ==> ./Dynamic_Programming/0097.Interleaving-String/097.Interleaving-String.cpp <==
snippet 0097.Interleaving-String "0097.Interleaving-String" b
class Solution {
public:
    bool isInterleave(string s1, string s2, string s3) 
    {
        int n1=s1.size();
        int n2=s2.size();
        int n3=s3.size();
        if (n1+n2!=n3) return false;

        s1.insert(s1.begin(),'0');
        s2.insert(s2.begin(),'0');
        s3.insert(s3.begin(),'0');
        
        auto dp=vector<vector<int>>(n1+1,vector<int>(n2+1,0));

        dp[0][0]=1;
        
        for (int i=1; i<=n1; i++)
        {
            if (dp[i-1][0]==1 && s1[i]==s3[i])
                dp[i][0]=1;
        }
        
        for (int j=1; j<=n2; j++)
        {
            if (dp[0][j-1]==1 && s2[j]==s3[j])
                dp[0][j]=1;
        }
        
        for (int i=1; i<=n1; i++)
         for (int j=1; j<=n2; j++)
         {
             if (dp[i-1][j]==1 && s1[i]==s3[i+j])
                 dp[i][j]=1;
             else if (dp[i][j-1]==1 && s2[j]==s3[i+j])
                 dp[i][j]=1;
         }
        
        return dp[n1][n2];
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/0115.Distinct-Subsequences/Readme.md <==
snippet 0115.Distinct-Subsequences "0115.Distinct-Subsequences" b
### 115.Distinct-Subsequences

刷过一年的题之后，再做这道题就会很容易地看出这题属于two string convergence的套路。类似标签的题号有010,097,072,712,727.

令dp[i][j]表示```s[1:i]```中有多少个不同的子序列等于```t[1:j]```。

依照套路，我们首先分析如果s[i]==t[j]的情况。显然，这两个字符相等，我们就将注意力前移，集中在s[1:i-1]和t[1:j-1]上。dp[i-1][j-1]表示s[1:i-1]中有多少个不同的子序列等于t[1:j-1]，两边分别加上s[i]和t[j]之后，自然就有相同多数目的s[1:i]的不同子序列等于t[1:j]。所以算上这部分，```dp[i][j]+=dp[i-1][j-1]```。

如果s[i]!=t[j]的话，说明s[i]指望不上，我们就将注意力放在```s[1:i-1]```上，看里面有多少个不同子序列等于```t[1:j]```，直接拿过来用就行，反正加上了s[i]也不管事。所以这种情况下，```dp[i][j]+=dp[i-1][j]```.

注意：当s[i]==t[j]的时候，上述的第二种情况也是要累加进去的。原因也是显然的。

递推关系有了，那么边界条件呢？无非就是```dp[0][j]```和```dp[i][0]```的情况。显然，前者仍算是一种子序列，所以赋值为1，后者赋值为0.




[Leetcode Link](https://leetcode.com/problems/distinct-subsequences)
$0
endsnippet

# ==> ./Dynamic_Programming/0115.Distinct-Subsequences/115.Distinct-Subsequences.cpp <==
snippet 0115.Distinct-Subsequences "0115.Distinct-Subsequences" b
class Solution {
public:
    int numDistinct(string s, string t) 
    {
        int m = s.size();
        int n = t.size();
        auto dp = vector<vector<long long>>(m+1,vector<long long>(n+1,0));
        s = "#"+s;
        t = "#"+t;
                
        if (m<n) 
            return 0;
        if (m==n)
            return (s==t);
        
        for (int i=0; i<=m; i++)
            dp[i][0] = 1;
        
        for (int i=1; i<=m; i++)
            for (int j=1; j<=n; j++)
            {
                if (s[i]==t[j])
                    dp[i][j] = dp[i-1][j] + dp[i-1][j-1];
                else
                    dp[i][j] = dp[i-1][j];
                //cout<<i<<" "<<j<<" "<<dp[i][j]<<endl;
            }
        return dp[m][n];
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/0120.Triangle/Readme.md <==
snippet 0120.Triangle "0120.Triangle" b
### 120.Triangle

最基本的DP题。令dp[i][j]表示从起点到第i行第j列所经过的最短权重和，那么
```cpp
dp[i][j] = min(dp[i-1][j], dp[i-1][j-1]) + triangle[i][j]
```
注意当j==0和j==i时需要单独处理。

$0
endsnippet

# ==> ./Dynamic_Programming/0120.Triangle/120.Triangle.cpp <==
snippet 0120.Triangle "0120.Triangle" b
class Solution {
public:
    int minimumTotal(vector<vector<int>>& triangle) 
    {
        int n = triangle.size();
        vector<int>dp(n);
        dp[0] = triangle[0][0];
        for (int i=1; i<n; i++)
        {
            auto dp2 = dp;
            for (int j=0; j<=i; j++)
            {
                if (j==0)
                    dp[j] = dp2[0]+triangle[i][0];
                else if (j==i)
                    dp[j] = dp2[i-1]+triangle[i][j];
                else
                    dp[j] = min(dp2[j-1],dp2[j])+triangle[i][j];
            }                
        }
        int ret = INT_MAX;
        for (int i=0; i<n; i++)
            ret = min(ret, dp[i]);
        return ret;
        
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/0123.Best-Time-to-Buy-and-Sell-Stock-III/Readme.md <==
snippet 0123.Best-Time-to-Buy-and-Sell-Stock-III "0123.Best-Time-to-Buy-and-Sell-Stock-III" b
### 123.Best-Time-to-Buy-and-Sell-Stock-III

此题属于DP的范畴,但是不需要存储庞大的状态数组.本题中,每一天的决策,仅仅取决于之前一天的若干个状态.

一天之内的状态,只有四种:已经买了一只股buy1,已经卖了一只股sold1,已经买了第二只股buy2,已经卖了第二只股sold2.那么显然每一天的状态更新是:
```cpp
buy1 = max(buy1,-p)
sold1 = max(sold1, buy1+p)
buy2 = max(buy2,sold1-p)
sold2 = max(sold2, buy2+p)
```
注意等号右边的变量都是前一天的状态. 另外需要考虑初始状态:buy1=-inf, sold1=0, buy2=-inf, sold2=0

跟这一题类似的题目有:376,487,714,552


[Leetcode Link](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii)
$0
endsnippet

# ==> ./Dynamic_Programming/0131.Palindrome-Partitioning/Readme.md <==
snippet 0131.Palindrome-Partitioning "0131.Palindrome-Partitioning" b
### 131.Palindrome-Partitioning

首先预处理字符串，用区间型dp计算出任意两个index之间的substring是否是回文串，记做dp[i][j].

然后从第一个字符开始进行深度优先搜索。设计dfs(i,temp)，表示考虑以当前的位置i为substring的开头，遍历有哪些位置j满足[i:j]的字符串满足回文（即dp[i][j]=1），就将该字符串收录进temp，然后递归搜索第j+1个位置。如果dfs的参数i走到了n，说明恰好将整个s分割成了若干段回文串，就将这组分割的子串temp加入最终答案。

特别注意，这个dfs在回溯的时候需要将temp末尾加入的子串弹出。

$0
endsnippet

# ==> ./Dynamic_Programming/0131.Palindrome-Partitioning/131.Palindrome-Partitioning.cpp <==
snippet 0131.Palindrome-Partitioning "0131.Palindrome-Partitioning" b
class Solution {
    int dp[16][16];
    vector<vector<string>>rets;
    int n;
    string s;
public:
    vector<vector<string>> partition(string s) 
    {
        this->s = s;
        n = s.size();
        
        for (int i=0; i<n; i++)
            dp[i][i] = 1;
        for (int i=0; i+1<n; i++)
            dp[i][i+1] = s[i]==s[i+1];
        for (int len = 3; len <=n; len++)
            for (int i=0; i+len-1<n; i++)
            {
                int j = i+len-1;
                if (s[i]==s[j])
                    dp[i][j] = dp[i+1][j-1];
                else
                    dp[i][j] = 0;
            }

        vector<string>temp;
        dfs(0, temp);

        return rets;
    }

    void dfs(int i, vector<string>&temp)
    {
        if (i==n)
        {
            rets.push_back(temp);
            return;
        } 
        for (int j=i; j<n; j++)
        {
            if (dp[i][j])
            {
                temp.push_back(s.substr(i,j-i+1));
                dfs(j+1, temp);
                temp.pop_back();
            }
        }
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/0132.Palindrome-Partitioning-II/Readme.md <==
snippet 0132.Palindrome-Partitioning-II "0132.Palindrome-Partitioning-II" b
### 132.Palindrome-Partitioning-II

这是一道分两步走，并且每一步都可以用DP实现的题目。

首先，我们可以用dp来计算任意两个字符之间是否是回文的。转移方程是：```isPal[i][j] = 1 if isPal[i+1][j-1]==1 and s[i]==s[j]```

接下来，我们可以用dp来计算第二个问题。令dp[i]表示从0到i的字符串可被拆分为最少的回文数的个数。则易知```dp[i] = min(i+1,dp[j]+1 for isPal[j+1][i]==1)```


[Leetcode Link](https://leetcode.com/problems/palindrome-partitioning-ii)
$0
endsnippet

# ==> ./Dynamic_Programming/0132.Palindrome-Partitioning-II/132.Palindrome-Partitioning-II.cpp <==
snippet 0132.Palindrome-Partitioning-II "0132.Palindrome-Partitioning-II" b
class Solution {
public:
    int minCut(string s) 
    {
        int N = s.size();
        
        auto isPal = vector<vector<bool>>(N,vector<bool>(N,0));
        for (int len = 1; len<=N; len++)
            for (int i=0; i<=N-len; i++)
            {
                int j = i+len-1;
                // update isPal[i][j]
                if (s[i]==s[j])
                {
                    if (i+1>=j-1)
                        isPal[i][j] = true;
                    else 
                        isPal[i][j] = isPal[i+1][j-1];
                }
            }
        
        
        vector<int>dp(N, INT_MAX/2);
        
        dp[0] = 1;
        
        for (int i=1; i<N; i++)
        {
            for (int j=0; j<=i; j++)
            {
                if (isPal[j][i])
                {
                    if (j==0)
                        dp[i] = 1;
                    else
                        dp[i] = min(dp[i], dp[j-1]+1);
                }
            }
        }
        
        return dp[N-1]-1;
    }
    
};

$0
endsnippet

# ==> ./Dynamic_Programming/0152.Maximum-Product-Subarray/Readme.md <==
snippet 0152.Maximum-Product-Subarray "0152.Maximum-Product-Subarray" b
### 152.Maximum-Product-Subarray

此题是053.Maximum-Subarray的进阶版。本题的关键点在于，如果nums[i]是负数，那么求以i为结尾的最大乘积子数组，其实转化为求以i-1为结尾的最小乘积子数组。所以我们每次考察以i为结尾的子数组时，需要同时保留最大和最小值。于是状态转移方程：
```cpp
            curMax = max(max(preMin*nums[i],preMax*nums[i]),nums[i]);
            curMin = min(min(preMin*nums[i],preMax*nums[i]),nums[i]);            
```
最后返回的结果不是最后的curMax,而是遍历每个回合的curMax中的最大值。


[Leetcode Link](https://leetcode.com/problems/maximum-product-subarray)

$0
endsnippet

# ==> ./Dynamic_Programming/0152.Maximum-Product-Subarray/152.Maximum-Product-Subarray.cpp <==
snippet 0152.Maximum-Product-Subarray "0152.Maximum-Product-Subarray" b
class Solution {
public:
    int maxProduct(vector<int>& nums) 
    {
        long MAX = 1;
        long MIN = 1;
        long ret =  INT_MIN;
        
        for (int i=0; i<nums.size(); i++)
        {
            long MAX_tmp = MAX, MIN_tmp = MIN;
            MAX = max(max(MAX_tmp*nums[i],MIN_tmp*nums[i]),(long)nums[i]);            
            MIN = min(min(MAX_tmp*nums[i],MIN_tmp*nums[i]),(long)nums[i]);
            ret = max(ret,MAX);
        }
        return result;
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/0152.Maximum-Product-Subarray/152.Maximum-Product-Subarray_DP.cpp <==
snippet 0152.Maximum-Product-Subarray "0152.Maximum-Product-Subarray" b
class Solution {
public:
    int maxProduct(vector<int>& nums) 
    {        
        int n = nums.size();
        vector<long>dp1(n);
        vector<long>dp2(n);
        dp1[0] = nums[0];
        dp2[0] = nums[0];
        long ret =  nums[0];
        
        for (int i=1; i<n; i++)
        {            
            dp1[i] = max(max(dp1[i-1]*(long)nums[i], dp2[i-1]*(long)nums[i]),(long)nums[i]);            
            dp2[i] = min(min(dp1[i-1]*(long)nums[i], dp2[i-1]*(long)nums[i]),(long)nums[i]);            
            ret = max(ret,dp1[i]);
        }
        return ret;
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/0174.Dungeon-Game/Readme.md <==
snippet 0174.Dungeon-Game "0174.Dungeon-Game" b
### 174.Dungeon-Game

我们会想```dp[i][j]```表示从```(i,j)```的位置上出发（注意，已经survive from ```(i,j)```本身）的时候，需要多少血才能走到终点？显然有两条路。其中一条通过```(i+1,j)```走到终点，这样我们需要在出发的时候至少有```-dugeon[i+1][j]```的血才能活着走到```(i+1,j)```,然后再利用```dp[i+1][j]```的血量保证能继续走到终点。

第二路通过```(i,j+1)```走到终点，这样我们需要在出发的时候至少有```-dugeon[i][j+1]```的血才能活着走到```(i,j+1)```,然后再利用```dp[i][j+1]```的血量保证能继续走到终点。

既然这两条路都能走到终点，那从```(i,j)```出发到底需要准备多少血量就够了呢？自然是两者的较小值：
```
dp[i][j] = min( dp[i][j+1]-dungeon[i][j+1], dp[i+1][j]-dungeon[i+1][j] );
```
特别注意的是，```dp[i][j]```还必须大于等于1，要保证从```(i,j)```出发的时候人必须还是活着的。也就是说，即使下一个cell有很大的补药，也不允许在本cell先欠着命再在后面靠补药续上。这个补丁很重要。
```
dp[i][j] = max(dp[i][j], 1); 
```
从这个动态转移方程的表达式可以看出，这是个从右下角往左上角计算的过程。初始状态是```dp[m-1][n-1]=1```。最终得到的```d[0][0]```的意义是：survive from ```(0,0)```之后需要存留多少血才能走到终点。因此我们还需要再额外处理一次(0,0)位置的损血代价。


[Leetcode Link](https://leetcode.com/problems/dungeon-game)
$0
endsnippet

# ==> ./Dynamic_Programming/0174.Dungeon-Game/174.Dungeon-Game.cpp <==
snippet 0174.Dungeon-Game "0174.Dungeon-Game" b
class Solution {
public:
    int calculateMinimumHP(vector<vector<int>>& dungeon) 
    {
        int M = dungeon.size();
        int N = dungeon[0].size();
        auto dp = vector<vector<int>>(M,vector<int>(N,1));
        
        for (int i=M-1; i>=0; i--)
            for (int j=N-1; j>=0; j--)
            {
                if (i==M-1 && j==N-1)
                    dp[M-1][N-1] = 1;
                else if (i==M-1)
                    dp[i][j] =  dp[i][j+1]-dungeon[i][j+1];                
                else if (j==N-1)
                    dp[i][j] =  dp[i+1][j]-dungeon[i+1][j];
                else
                    dp[i][j] = min( dp[i][j+1]-dungeon[i][j+1], dp[i+1][j]-dungeon[i+1][j] );
                
                dp[i][j] = max(dp[i][j], 1); 
            }
        
        dp[0][0] = dp[0][0]-dungeon[0][0];
        dp[0][0] = max(dp[0][0], 1); 
        
        return dp[0][0];
        
    }
};


  

$0
endsnippet

# ==> ./Dynamic_Programming/0188.Best-Time-to-Buy-and-Sell-Stock-IV/Readme.md <==
snippet 0188.Best-Time-to-Buy-and-Sell-Stock-IV "0188.Best-Time-to-Buy-and-Sell-Stock-IV" b
### 188.Best-Time-to-Buy-and-Sell-Stock-IV

#### 解法1：

此题是对之前股票系列I，II，III的综合考察，并推广到任意k次交易的条件。

基本思路还是从第i天的策略考虑起。第i天如果卖出的话，说明第i-1天必须手头有股票；如果是买入的话，说明第i-1天必须手头没有股票。因此我们可以粗略地写下：```dp[i] = max{dp[i-1][yes]+sell, dp[i-1][no]+buy}```这就提示我们dp其实有两个维度，dp[i][yes/no]，第二个维度代表了持有或不持有股票。这时候我们可以写出状态转移方程：
```
for (int i=0; i<n; i++)
{
    dp[i][yes] = max( dp[i-1][no]+buy, dp[i-1][yes]+hold );
    dp[i][no] =  max( dp[i-1][yes]+sell, dp[i-1][no]+hold );
}
return dp[n-1][no];
```
但是这个状态转移方程并没有考虑到对于交易次数的约束。我们因此修改状态变量为dp[i][yes/no][j]，其中j表示经历过j次的股票买入。显然，第i天买入第j只股票，需要要求第i-1天已经卖出第j-1只股票；第i天卖出第j只股票，需要要求第i-1天已经入手第j只股票。因此类推，就可以把j写入状态转移方程中。
```
for (int i=0; i<n; i++)
{
    for (int j=0; j<=k; j++)
    {
      dp[i][yes][j] = max { dp[i-1][no][j-1]+buy, dp[i-1][yes][j]+hold };
      dp[i][no][j] = max {dp[i-1][yes][j]+sell, dp[i-1][no][j]+hold  };
    }
}
return dp[n-1][no];
```
进一步，yes/no的状态维度可以拆分为两个dp变量：
```
  hold[i][j] = max { sold[i-1][j-1]+buy, hold[i-1][j] }
  sold[i][j] = max { hold[i-1][j]+sell, sold[i-1][j] }
```
至此，写出最多k次交易的最大利润已经不难，返回的结果是sold[n-1][j]中的最大值。

本题最有意思的一点是，k可以很大，远大于prices的天数。这样的话，题目就等效于无限次的操作，这样就可以用 122. Best Time to Buy and Sell Stock II
里面的技巧来解，时间复杂度反而从```o(n*k)```降到了```o(n)```.

#### 解法2：
上述的解法时间复杂度是o(NK)，在最近的评测中会TLE。这里介绍一个惊为天人的解法，时间复杂度是O(NlogP)，其中P是prices的最大值。

我们令f(x)表示固定交易x次能收获的最大值。那么这个f(x)会长什么样子？它是一个上凸的函数。因为交易次数太少，赚的机会就少；交易次数太多，有些交易反而会亏钱。所以在某个位置xm的地方，交易这个次数可以使得利益最大化。如果k>=xm，那么我们必然选择交易xm次。如果k<xm，那么我们必然选择交易k次。对于前者，本质上就是没有约束，那么问题就转化为了122. Best Time to Buy and Sell Stock II. 所以这题的关键其实就是求后者的f(k).

虽然知道了f(x)的形状，但直接求解f(x)我们其实没有什么特别好的办法。接下用来有个神奇的技巧。

我们在令```g(x)=f(x)-a*x```，从形式上看，就是一个带有transaction fee的股票买卖问题，其中每买一次股票需要额外付出a。特别地，当a=0的时候，g(x)就是f(x)。我们此时考虑，当a=1的时候相比于a=0的时候，g(x)的函数图像有什么变化呢？首先对任何的交易次数x而言，交易费的引入都会让利润受损，所以g(x)整体会向下移动。另外，交易费的引入会让有些交易变得无利可图甚至亏损，最大利润所对应的股票交易次数一定会减少，所以g(x)的峰值会左移。

可以想见，随着a的增大，g(x)的峰值会向下向左移动。注意，x的定义域是离散的，所以峰值也一定对应着某个整数的x。

如果我们能找到某个a，使得g(x)的峰值恰好对应着x=k的时候，意味着```f(k)-ak = g(x)_max```. 如果```g(x)_max```和a都知道了，那么本题就得解。那么如何知道这样的a呢？事实上，我们已经知道，随着a的增大，g(x)的峰值位置是向左单调移动的。我们可以用二分法搜索出这个a来，满足峰值是的位置是k。此时交易费a确定了，那么问题就同714	Best Time to Buy and Sell Stock with Transaction Fee，可以知道最大利润，也就是g(x)的峰值。

这个二分的过程中，a的最小值是0，最大值就是max{prices}。如果k>xm，那么我们二分搜索是不会搜到峰值位置是k的，但是会最终将a的选择收敛到0，这也就达到我们的目的了。


[Leetcode Link](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv)

$0
endsnippet

# ==> ./Dynamic_Programming/0188.Best-Time-to-Buy-and-Sell-Stock-IV/188.Best-Time-to-Buy-and-Sell-Stock-IV.cpp <==
snippet 0188.Best-Time-to-Buy-and-Sell-Stock-IV "0188.Best-Time-to-Buy-and-Sell-Stock-IV" b
class Solution {
public:
    int maxProfit(int k, vector<int>& prices) 
    {
        int n = prices.size();
        
        if (k>=n/2)
        {
            int result = 0;
            for (int i=1; i<prices.size(); i++)
                if (prices[i]>prices[i-1])
                    result+=prices[i]-prices[i-1];
            return result;
        }
        
        vector<int>hold(k+1, INT_MIN/2);
        vector<int>sold(k+1, INT_MIN/2);
        
        hold[0] = 0;
        sold[0] = 0;
        
        for (int i=0; i<n; i++)
        {
            auto hold_old = hold;
            auto sold_old = sold;
            
            for (int j=1; j<=k; j++)
            {
                hold[j] = max (sold_old[j-1]-prices[i], hold_old[j] );
                sold[j] = max (hold_old[j]+prices[i], sold_old[j] );
            }
            
        }
        
        int result = INT_MIN;
        for (int j=0; j<=k; j++)
            result = max(result, sold[j]);
        return result;
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/0188.Best-Time-to-Buy-and-Sell-Stock-IV/188.Best-Time-to-Buy-and-Sell-Stock-IV_v2.cpp <==
snippet 0188.Best-Time-to-Buy-and-Sell-Stock-IV "0188.Best-Time-to-Buy-and-Sell-Stock-IV" b
class Solution {
    int n;
public:
    int maxProfit(int k, vector<int>& prices) 
    {
        n = prices.size();
        prices.insert(prices.begin(),0);
        int left = 0, right = *max_element(prices.begin(), prices.end());

        while (left<right)
        {
            int fee = left + (right-left)/2;
            if (helper(prices, fee)[1] > k)
                left = fee+1;
            else
                right = fee;
        }
        return helper(prices,left)[0] + left*k;
    }

    vector<int> helper(vector<int>& prices, int fee) 
    {
        vector<int>sold(n+1,0);
        vector<int>hold(n+1,0);
        sold[0] = 0;
        hold[0] = INT_MIN/2;
        int count0 = 0;
        int count1 = 0;

        for (int i=1; i<=n; i++)
        {
            if (hold[i-1]+prices[i]> sold[i-1])
            {
                sold[i] = hold[i-1] + prices[i];
                count0 = count1+1;
            }
            else
                sold[i] = sold[i-1];
            
            if (sold[i-1] - prices[i] - fee  > hold[i-1])
            {
                hold[i] = sold[i-1] - prices[i] - fee;
                count1 = count0;
            }
            else
                hold[i] = hold[i-1];
        }
        return {sold[n], count0};
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/0198.House-Robber/Readme.md <==
snippet 0198.House-Robber "0198.House-Robber" b
### 198.House-Robber

这是“双状态”DP最典型的一道题。它的特点是：每一轮的状态只取决于上一轮的状态；并且每一轮的状态只有两种，通常就是“取”或“不取”。

结合本题来说，是否打劫第k间房子（的收益），完全取决于是否打劫第k-1间房子（的收益）。令rob[k]表示打劫第k间的最大收益，norob[k]表示不打劫第k间的最大收益。我们可以分析出相邻两轮状态之间的递推关系：
```cpp
rob[k] = norob[k-1];  // 想要打劫第k间房子，必须基于第k-1间房子没打劫。
norob[k] = max(rob[k-1],norob[k-1])+nums[k]; // 不打劫第k间房子的最大收益，显然对应了rob[k-1],norob[k-1]之间较大的值。
```
对于初始状态，我们可以直接考虑第0间房子是否打劫及其收益。这样状态转移方程可以从第1间房子开始适用。


[Leetcode Link](https://leetcode.com/problems/house-robber)
$0
endsnippet

# ==> ./Dynamic_Programming/0198.House-Robber/198.House-Robber.cpp <==
snippet 0198.House-Robber "0198.House-Robber" b
class Solution {
public:
    int rob(vector<int>& nums) 
    {
        if (nums.size()==0)  return 0;
        
        int rob = nums[0], norob = 0;
        
        for (int i=1; i<nums.size(); i++)
        {
            int rob_tmp = rob, norob_tmp = norob;
            norob = max(rob_tmp, norob_tmp);
            rob = norob_tmp + nums[i];
        }
        return max(rob, norob);
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/0213.House-Robber-II/Readme.md <==
snippet 0213.House-Robber-II "0213.House-Robber-II" b
### 213.House-Robber-II

#### 解法1：双状态动态规划
考虑环的影响，首位和末位不能同时为yes。这说明至少有一个的选择是no。

(1) 如果首位我们选择no，那么从nums[1]到nums[n-1]的选择就没有环形的首尾制约，完全就是一个198.House Robber I的问题。

(2) 如果末位我们选择no，那么从nums[0]到nums[n-2]的选择就没有环形的首尾制约，同样也是一个198.House Robber I的问题。

我们将两种情况下的最优解再取最大值，就是答案。

注意，(1)和(2)并不是互斥的。他们是有交叠的。但是它们的并集一定是全集。

#### 解法2：记忆化搜索（递归）
我们考虑是否打劫第零家（nums[0]）：是的话，那么下一步我们可以在[2,n-2]中任意选择打劫。如果不打劫第零家，那么下一步我们可以在[1,n-1]中任意选择打劫。也就是说，最顶层的答案就是```max( nums[0]+dfs(2,n-2), dfs(1,n-1) )```其中DFS的两个参数就是可供打劫的区间。这里特别注意的是n-2，这是因为题目中loop的要求（不能打劫任意相邻两家），打劫了第0家的话我们就不可能打劫第n-1家。

对于任意区间[i,j]作为打劫对象，我们可以同样处理，考虑是否打劫最前面的（也就是第i家）。根据不同的决策，我们分别有：```nums[i]+dfs(i+1,j)```和```dfs(i+1,j)```.两者分别递归处理得到结果后，取较大作为返回值。

当然，我们也可以用区间型的二维dp来实现上面的算法。

#### Follow-up
此题有一个更难一点的follow up，参见```1388.Pizza-With-3n-Slices```.

[Leetcode Link](https://leetcode.com/problems/house-robber-ii)

$0
endsnippet

# ==> ./Dynamic_Programming/0213.House-Robber-II/213.House-Robber-II.cpp <==
snippet 0213.House-Robber-II "0213.House-Robber-II" b
class Solution {
public:
    int rob(vector<int>& nums) 
    {
        int n = nums.size();
        if (n==0) return 0;
        if (n==1) return nums[0];
        
        int ret = 0;
        
        int rob = nums[1], norob = 0;        
        for (int i=2; i<n; i++)
        {
            int rob_tmp = rob, norob_tmp = norob;
            rob = norob_tmp + nums[i];
            norob = max(rob_tmp, norob_tmp);            
        }
        ret = max(rob, norob);
        
        rob = nums[0], norob =0;
        for (int i=1; i<n-1; i++)
        {
            int rob_tmp = rob, norob_tmp = norob;
            rob = norob_tmp + nums[i];
            norob = max(rob_tmp, norob_tmp);   
        }
        ret = max(ret, max(rob, norob));
        return ret;
        
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/0213.House-Robber-II/213.House-Robber-II_v2.cpp <==
snippet 0213.House-Robber-II "0213.House-Robber-II" b
class Solution {
public:
    int rob(vector<int>& nums) 
    {
        int n = nums.size();
        if (n==0) return 0;
        if (n==1) return nums[0];
        
        auto dp = vector<vector<int>>(n, vector<int>(n,0));
        for (int i=0; i<n; i++)
            dp[i][i] = nums[i];
        
        for (int len = 2; len <=n; len++)
            for (int i= 0; i+len-1<n; i++)
            {
                int j = i+len-1;
                dp[i][j] = max(nums[i]+ ((i+2>j)?0:dp[i+2][j]), dp[i+1][j]);
            }
        
        return max(nums[0]+((2>n-2)?0:dp[2][n-2]), dp[1][n-1]);
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/0221.Maximal-Square/Readme.md <==
snippet 0221.Maximal-Square "0221.Maximal-Square" b
### leetcode-221-Maximal-Square  
##### 解法1：brutal search
首先预处理得到矩阵sum[i][j]，表示从左上角(0,0)到(i,j)处的所有元素之和。注意技巧，sum在定义时两个维度大小都增1。

对于每一个sum[i][j]，判断是否存在以(i,j)为右下角、边长为k的正方形，k的取值从1到不越界。判断表达式是：
```cpp
if (sum[i][j]-sum[i-1][j]-sum[i][j-1]+sum[i-1][j-1] == k*k) 
```
73ms

##### 解法2：逐行判断，贪心法
完全类似于 leetcode 85 maximal rectangular，变换成在一维上求最大正方形。

核心思想：不断加入数组元素，维护一个非减的栈序列，注意栈元素是数组的index而不是数值本身。遇到下一个数组元素比栈顶元素小的时候，退栈，判断该栈顶元素能够围成的最大正方形空间。
```cpp
if （height[i]>=height[s.top()])  
  {push(i); continue;}
else    
  { int H=height[s.top()];
    s.pop();
    result = max(result,min(H,i-s.top()-1);
  }  
```
9ms

##### 解法3：动态规划  
设计dp[i][j]表示右下角为(i,j)的最大正方形边长。则有动态转移方程： 
```cpp
if (matrix[i][j]==1)
  dp[i][j]=min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1])+1
else
  dp[i][j]=0;
```
可以这么理解上述的动态转移方程。假设matrix[i][j]==1，那么对于右下角为（i,j）的可能的最大正方形，主要取决于dp[i-1][j-1]有多大，其次还要考虑第i行和第j列分别有多少1与（i,j）连着。所以，这个最大正方形，其下边长由min(dp[i-1][j-1],dp[i][j-1])决定，有边长由min(dp[i-1][j-1],dp[i-1][j])决定。

最后注意，输出的面积应该是最长边长的平方。


[Leetcode Link](https://leetcode.com/problems/maximal-square)
$0
endsnippet

# ==> ./Dynamic_Programming/0221.Maximal-Square/221.Maximal-Square_brutal.cpp <==
snippet 0221.Maximal-Square "0221.Maximal-Square" b
class Solution {
public:
    int maximalSquare(vector<vector<char>>& matrix) 
    {
        int M=matrix.size();
        if (M==0) return 0;
        int N=matrix[0].size();
        
        auto sum=vector<vector<int>>(M+1,vector<int>(N+1,0));
        
        for (int i=1; i<M+1; i++)
            for (int j=1; j<N+1; j++)
            {
                sum[i][j]=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]+matrix[i-1][j-1]-'0';
            }
            
        /*
        for (int i=1; i<M+1; i++)
        {
            for (int j=1; j<N+1; j++)
            {
                cout<<sum[i][j]<<" ";
            }
            cout<<endl;
        }
        */
        
        int result = 0;
        
        for (int i=1; i<M+1; i++)
            for (int j=1; j<N+1; j++)
            {
                int k=1;
                while (j-k>=0 && i-k>=0)
                {
                    int temp = sum[i][j]-sum[i-k][j]-sum[i][j-k]+sum[i-k][j-k];
                    if (temp == k*k)
                        result = max(result, temp);
                    k++;    
                }
            }
            
        return result;
        
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/0221.Maximal-Square/221.Maximal-Square_dp.cpp <==
snippet 0221.Maximal-Square "0221.Maximal-Square" b
class Solution {
public:
    int maximalSquare(vector<vector<char>>& matrix) 
    {
        int M=matrix.size();
        if (M==0) return 0;
        int N=matrix[0].size();
        auto dp=vector<vector<int>>(M+1,vector<int>(N+1,0));
        int result=0;
        
        for (int i=1; i<=M; i++)
            for (int j=1; j<=N; j++)
            {
                if (matrix[i-1][j-1]=='0')
                    dp[i][j]=0;
                else
                {
                    int temp=min(dp[i-1][j],dp[i][j-1]);
                    temp = min(temp,dp[i-1][j-1]);
                    dp[i][j]=temp+1;
                    result=max(result,dp[i][j]*dp[i][j]);
                }
            }
        
        return result;
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/0221.Maximal-Square/221.Maximal-Square_stack.cpp <==
snippet 0221.Maximal-Square "0221.Maximal-Square" b
class Solution {
public:
    int maximalSquare(vector<vector<char>>& matrix) 
    {
        int M=matrix.size();
        if (M==0) return 0;
        int N=matrix[0].size();
        
        vector<int>q(N,0);
        
        int result=0;
        for (int i=0; i<M; i++)
        {
            for (int j=0; j<N; j++)
            {
                if (matrix[i][j]=='0')
                    q[j]=0;
                else
                    q[j]=q[j]+1;
                    
            }

            result = max(result,helper(q));
        }
        
        return result;
        
    }
    
    int helper(vector<int>height)
    {
        if (height.size()==1) return (height[0]>0);
        height.push_back(0);
        height.insert(height.begin(),0);
        
        stack<int>s;
        int result=0;
        
        for (int i=0; i<height.size(); i++)
        {
            if (s.empty() || height[i]>=height[s.top()])
            {
                s.push(i);
                continue;
            }
            
            if (height[i]<height[s.top()])
            {
                while (!s.empty() && height[i]<height[s.top()])
                {
                    int H=height[s.top()];
                    
                    s.pop();
                    int d = min(H,i-s.top()-1);
                    result = max(result,d*d);
                }
                s.push(i);
            }
        }
    
        return result;

        
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/0264.Ugly-Number-II/Readme.md <==
snippet 0264.Ugly-Number-II "0264.Ugly-Number-II" b
### 264.Ugly-Number-II

#### 解法1： PQ
此题的常规解法是类似BFS。对于当前ugly number的某一个元素k，由它可以生成另外三个ugly number，分别是k\*2,k\*3,k\*5，于是将这三个数添加进一个小顶堆的优先队列，自动冒出候选者中的最小值。注意需要做去重。因为每次弹出一个数，会加入三个数，这样的时间复杂度是o(3Nlog3N).

#### 解法2： DP
事实上有更好的解法，时间复杂度是o(N).上面的解法的问题在于，对于k\*2,k\*3,k\*5，他们的差距可能很大，加入BFS队列的时候也并不都放在最后，可能需要排序才能插入到合适的位置。如何避免这样的排序呢？也就是说，如何生成一个新丑数使得它恰好就是下一个最小的？

我们思考，对于任何丑数，它只能由某一个丑数乘以2，或者某一个丑数乘以3，或者某一个丑数乘以5得到。OK，假设有三个丑数a,b,c,它们对应的a\*2,b\*3,c\*5,如果这三个都是新丑数，我们必然就只先取最小的那个，假设是a\*2，OK，可以放入队列。那么这时候我们想一想，下一个最小的、并且靠\*2得到的丑数会是什么呢？必然是丑数a的下一个丑数(假设是d)再乘以2.注意，这里的“下一个丑数”指的是，在已有的丑数队列里，紧跟在a后面的那个数。同时，下一个最小的、并且靠\*3得到的丑数会是什么呢？依然是b\*3。同理下一个最小的、并且靠\*5得到的丑数会是什么呢？依然是c\*5。所以，对整个队列而言，下一个最小的丑数是什么呢？因为丑数只可能是靠\*2，\*3，或者\*5得到，所以它有三个候选，那就是d\*2，b\*3，c\*5，我们需要从中间挑一个最小的。可见，d是从a往后移动一个位置得到的，而b和c都不变，直接带入了下一轮的竞争。

所以完整的算法描述是：我们维护三个指针idx2,idx3,idx5。当我们想生成队列的下一个最小的丑数时，只需要从nums[idx2]\*2,nums[idx3]\*3,nums[idx5]\*5三个候选之间选一个最小的数m。如果m==nums[idx2]\*3，那么我们就将idx2右移；同理如果m==nums[idx3]\*3，那么我们就将idx3右移；如果m==nums[idx5]\*5，那么我们就将idx5右移。注意，这三种情况可能同时发生。示意图如下。
```
nums X X X X X X 
idx2       ^
idx3     ^
idx5 ^
```
这种算法直接精准确定下一个最小的丑数，避免了常规的BFS一下子生成多个候选数、再通过排序来挑选最小的。

[Leetcode Link](https://leetcode.com/problems/ugly-number-ii)

$0
endsnippet

# ==> ./Dynamic_Programming/0264.Ugly-Number-II/264.Ugly-Number-II_dp.cpp <==
snippet 0264.Ugly-Number-II "0264.Ugly-Number-II" b
class Solution {
public:
    int nthUglyNumber(int n) 
    {
        vector<int>q({1});
        int i=0, j=0, k=0;
        while (q.size()<n)
        {
            int x = min(q[i]*2, min(q[j]*3, q[k]*5));
            if (x==q[i]*2) i++;
            if (x==q[j]*3) j++;
            if (x==q[k]*5) k++;
            q.push_back(x);
        }
        return q[n-1];
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/0264.Ugly-Number-II/264.Ugly-Number-II_pq.cpp <==
snippet 0264.Ugly-Number-II "0264.Ugly-Number-II" b
class Solution {
public:
    int nthUglyNumber(int n) 
    {
        priority_queue<long,vector<long>,greater<>>pq;
        pq.push(1);

        for (int t=0; t<n; t++)
        {
            long cur = pq.top();
            pq.pop();
            if (t==n-1) return cur;
            while (!pq.empty() && pq.top()==cur)
                pq.pop();

            if (cur*2 < INT_MAX) pq.push(cur*2);
            if (cur*3 < INT_MAX) pq.push(cur*3);
            if (cur*5 < INT_MAX) pq.push(cur*5);
        }

        return -1;
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/0265.Paint-House-II/Readme.md <==
snippet 0265.Paint-House-II "0265.Paint-House-II" b
### 265.Paint-House-II

本题比较正常的DP解法就是令dp[i][j]表示刷完第i个房子、且第i个房子刷第j种漆，此时所需要的全部代价。

此题可以做到o(N\*K)的解法。这是因为我们在确定第i座房子刷第j种漆后，本质上只需要关心前面第i-1座房子刷完漆的最小代价是什么，再加上costs[i][j]即可。唯一需要考虑的就是：如果给第i-1座房子刷漆的最小代价所用的油漆也是第j种漆，和第i个房子所用的油漆重合了怎么办？遇到这种情况，我们需要同时也记录下刷完第i-1座房子第二最小代价及其油漆种类就行。

一个比较粗暴的方法就是，考虑刷完第i-1座房子之后，将所有的```dp[i-1][k](k=0,1,2,...,K-1)```排个序，记录下最小的两个值以及对应的油漆编号，比如说a和b。所以计算dp[i][j]时，如果j!=a，则```dp[i][j]=dp[i-1][a]+costs[i][j]```；否则我们就要采用备选方案，即```dp[i][j]=dp[i-1][b]+costs[i][j]```

因为我们不能肯定最后一座房子会刷什么颜色，所以最后的答案是在```dp[N-1][k](k=0,1,2,...,K-1)```挑选最小值。

此题和```1289. Minimum Falling Path Sum II```本质一模一样。


[Leetcode Link](https://leetcode.com/problems/paint-house-ii)
$0
endsnippet

# ==> ./Dynamic_Programming/0265.Paint-House-II/265.Paint-House-II.cpp <==
snippet 0265.Paint-House-II "0265.Paint-House-II" b
class Solution {
public:
    int minCostII(vector<vector<int>>& costs) 
    {
        int N = costs.size();
        if (N==0) return 0;
        int K = costs[0].size();
                
        auto dp = vector<vector<int>>(N,vector<int>(K,0));
        int minColor1 = -1;
        int minColor2 = -1;
        
        for (int i=0; i<N; i++)
        {
            int min1 = INT_MAX, min2 = INT_MAX;
            int newMinColor1, newMinColor2;
            
            for (int j=0; j<K; j++)
            {
                if (j==minColor1)                
                    dp[i][j] = (i==0)? costs[i][j] : dp[i-1][minColor2]+costs[i][j];
                else
                    dp[i][j] = (i==0)? costs[i][j] : dp[i-1][minColor1]+costs[i][j];
                
                if (dp[i][j]<min1)
                {
                    min2 = min1; newMinColor2 = newMinColor1;
                    min1 = dp[i][j]; newMinColor1 = j;                    
                }
                else if (dp[i][j]<min2)
                {
                    min2 = dp[i][j]; newMinColor2 = j;
                }
            }
            minColor1 = newMinColor1;
            minColor2 = newMinColor2;
        }
        return dp[N-1][minColor1];        
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/0265.Paint-House-II/265.Paint-House-II_v2.cpp <==
snippet 0265.Paint-House-II "0265.Paint-House-II" b
class Solution {
public:
    int minCostII(vector<vector<int>>& costs) 
    {
        int N = costs.size();
        if (N==0) return 0;
        int K = costs[0].size();
                
        auto dp = vector<vector<int>>(N,vector<int>(K,0));
        for (int k=0; k<K; k++)
            dp[0][k] = costs[0][k];
        
        for (int i=1; i<N; i++)
        {
            vector<pair<int,int>>temp;
            for (int k=0; k<K; k++)
                temp.push_back({dp[i-1][k],k});
            sort(temp.begin(),temp.end());                
                
            for (int k=0; k<K; k++)
            {
                if (k!=temp[0].second)
                    dp[i][k] = temp[0].first + costs[i][k];
                else
                    dp[i][k] = temp[1].first + costs[i][k];
            }
        }
        
        int ret = INT_MAX;
        for (int k=0; k<K; k++)
            ret = min(ret, dp[N-1][k]);
        return ret;
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/0276.Paint-Fence/Readme.md <==
snippet 0276.Paint-Fence "0276.Paint-Fence" b
### 276.Paint-Fence

这种排列组合的题，可能会想到是否有数学的解析方法．但解析方法往往也是由递归得到．所以不妨我们直接考虑递归或者ＤＰ的方法．

如果思考f(n)和f(n-1)的关系，那么解法就呼之欲出了．我们喷涂第ｎ个柱子，就是两种方案：和n-1的颜色一致，和n-1的颜色不一致．对于前者，我们必须保证n-2和n-1的颜色已经不能相同了，而对于后者，我们允许n-2和n-1的颜色相同．于是可以考虑dual status的ＤＰ方案，用same表示最近的两个柱子颜色一致的方案总数，diff表示最近的两个柱子颜色不一致的方案总数．

对于n，如果想喷涂和n-1一样的颜色，那么same(n)就要更新为diff(n-1)，颜色没有选择的余地

对于n，如果想喷涂和n-1不一样的颜色，那么diff(n)就要更新为[diff(n-1)+same(n-1)]*(k-1)，其中k-1表示颜色的选择种类．

上述的递归公式显示，我们只要不断更新两个状态变量same和diff即可．最后的答案就是两者之和．


[Leetcode Link](https://leetcode.com/problems/paint-fence)
$0
endsnippet

# ==> ./Dynamic_Programming/0276.Paint-Fence/276.Paint-Fence.cpp <==
snippet 0276.Paint-Fence "0276.Paint-Fence" b
class Solution {
public:
    int numWays(int n, int k) 
    {
        if (n==0) return 0;
        if (n==1) return k;
        int same = k;
        int diff = k*(k-1);
        for (int i=2; i<n; i++)
        {
            int same_temp = same;
            int diff_temp = diff;
            diff = same_temp*(k-1) + diff_temp*(k-1);
            same = diff_temp;
        }
        return same+diff;
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/0309.Best-Time-to-Buy-and-Sell-Stock-with-Cooldown/Readme.md <==
snippet 0309.Best-Time-to-Buy-and-Sell-Stock-with-Cooldown "0309.Best-Time-to-Buy-and-Sell-Stock-with-Cooldown" b
### 309.Best-Time-to-Buy-and-Sell-Stock-with-Cooldown

此题和该系列的其他题目一样，用几个状态变量来做DP。此题比较特殊的情况是，仅有hold和sold两个状态是不够的。我们考虑hold表示手头有股票时候的收益，sold表示手头已经卖出了股票的收益，题目可知我们试图更新sold的时候不能用hold+price[i]，所以我们还需要sold_cd表示手头的股票已经出手了一天以上。

我们不难分析出这三个状态的转移方程是：
```
hold = max(hold, sold_cd-prices[i])
sold = max(sold, hold+prices[i])
sold_cd = sold
```
注意所有等号右边的状态变量应该是上一轮的，所以会需要在更新前先缓存一下。


[Leetcode Link](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown)
$0
endsnippet

# ==> ./Dynamic_Programming/0313.Super-Ugly-Number/Readme.md <==
snippet 0313.Super-Ugly-Number "0313.Super-Ugly-Number" b
### 313.Super-Ugly-Number

#### 解法1
仿效BFS的想法. 从1开始，每次从优先队列里弹出当前最小的数，然后分别乘以k个质数再放入队列中。直至弹出n个数为止。时间复杂度是```NKlog(NK)```.

#### 解法2：
仿效```264	Ugly Number II```，每一个回合，下一个最小的丑数nxt，必然是某个老丑数乘以某个质数。现在有k个质数，说明nxt的候选者其实有k个，分别对应着k个老丑数分别乘以k个质数。所以我们给每个质数prime[j]分配一个指针p[j]指老丑数的位置，这个指针在整个过程中必然是要顺次移动。假设当前nxt的所有候选者中，```prime[j]*rets[p[j]]```最小而胜出，那么就把它加入rets，并且这个质数的指针以后就要右移一位，即```p[j]++```；其他质数的指针不变。

注意到丑数序列的第一个是1，我们重复n-1遍上述的过程，就可以得到答案（第n个丑数）。总的时间复杂度是```o(NK)```.

#### 解法3：
在解法2的基础上，在K个候选新丑数中选择最小的那个时，可以用一个优先队列来实现log(K)的弹出。这样时间复杂度就化简为了```o(NlogK)```.

$0
endsnippet

# ==> ./Dynamic_Programming/0313.Super-Ugly-Number/313.Super-Ugly-Numbe_dp.cpp <==
snippet 0313.Super-Ugly-Number "0313.Super-Ugly-Number" b
class Solution {
public:
    int nthSuperUglyNumber(int n, vector<int>& primes) 
    {
        int k = primes.size();
        vector<int>p(k,0);

        vector<int>rets({1});

        for (int i=0; i<n-1; i++)
        {
            int nxt = INT_MAX;
            for (int j=0; j<k; j++)
                nxt = min(nxt, primes[j]*rets[p[j]]);
            for (int j=0; j<k; j++)
            {
                if (nxt == primes[j]*rets[p[j]])
                    p[j]++;
            }
            rets.push_back(nxt);
        }

        return rets.back();
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/0313.Super-Ugly-Number/313.Super-Ugly-Numbe_pq.cpp <==
snippet 0313.Super-Ugly-Number "0313.Super-Ugly-Number" b
class Solution {
public:
    int nthSuperUglyNumber(int n, vector<int>& primes) 
    {
        set<long>Set={1};
        int count=0;
        long x;
        while (count<n)
        {
            x = *Set.begin();
            Set.erase(x);
            for (int i=0; i<primes.size(); i++)
            {
                if (x*primes[i]<INT_MAX)
                    Set.insert(x*primes[i]);
                else
                    break;
            }
                
            count++;
        }
        return x;  
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/0313.Super-Ugly-Number/313.Super-Ugly-Number_dp_pq.cpp <==
snippet 0313.Super-Ugly-Number "0313.Super-Ugly-Number" b
typedef pair<int,int> PII;
class Solution {
public:
    int nthSuperUglyNumber(int n, vector<int>& primes) 
    {
        vector<int>p(primes.size(),0);

        vector<int>rets({1});
        priority_queue<PII, vector<PII>, greater<>>pq;                
        for (int i=0; i<primes.size(); i++)
            pq.push({primes[i]*rets[0], i});

        for (int t=0; t<n-1; t++)
        {            
            int cur = pq.top().first;
            rets.push_back(cur);

            while (!pq.empty() && pq.top().first==cur)                
            {
                int i = pq.top().second;
                pq.pop();

                p[i]++;                
                pq.push({primes[i]*rets[p[i]], i});
            }            
        }

        return rets.back();
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/0322.Coin-Change/Readme.md <==
snippet 0322.Coin-Change "0322.Coin-Change" b
### 322.Coin-Change

基本的动态转移方程很明确 dp[n] = min(dp[n-k1],dp[n-k2], ..., dp[n-ki]) +1，其中k_i表示coins数组中提供的面额.

需要注意的很多细节：
1. 因为dp数组开辟的大小为 vector<int>dp(amount+1,0)，所以初始化的时候，如果 k>amount, 则 dp[k]则不需要考虑。否则越界.
2. 在动态转移方程中，可能会有n<k以及dp[n-k]==-1的情况，要通过判断语句提前预防。此外，这说明dp[n]是有可能无解的，也要及时做好-1的标注。


[Leetcode Link](https://leetcode.com/problems/coin-change)
$0
endsnippet

# ==> ./Dynamic_Programming/0322.Coin-Change/322.Coin Change.cpp <==
snippet 0322.Coin-Change "0322.Coin-Change" b
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) 
    {
        if (amount==0) return 0;
        
        vector<int>dp(amount+1,-1);
        
        for (int i=0;i<coins.size(); i++)
        {
            if (coins[i]>amount) continue;
            dp[coins[i]]=1;
        }
        
        for (int k=1; k<=amount; k++)
        {
            if (dp[k]!=-1) continue;

            
            int temp = INT_MAX;
            for (int i=0; i<coins.size(); i++)
            {
                if (k-coins[i]>0 && dp[k-coins[i]]!=-1)
                {
                    temp = min(temp, dp[k-coins[i]]+1);
                }
            }
            if (temp==INT_MAX) 
                dp[k] = -1;
            else
                dp[k] = temp;
        
        return dp[amount];
        
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/0368.Largest-Divisible-Subset/Readme.md <==
snippet 0368.Largest-Divisible-Subset "0368.Largest-Divisible-Subset" b
### 368.Largest-Divisible-Subset

本题最直接的想法就是将nums排序之后用DFS搜索。但是DFS会超时。很显然其中有非常多的重复路径。

那是否可以通过一个visited的数组来标记已经访问过的元素来避免重复搜索呢？这样是不行的，因为按照从小到大的次序优先搜索到的并不是最优的解。例如 1,3,5,10,30,60 这个例子，会首先搜索到 1-3-30-60，但是它不及 1-5-10-30-60. 如果30和60在第一次搜索中已经标记为visited的的话，那么就会错过第二次搜索的最优解。

于是只有考虑o(n^2)的DP算法，思路和动态转移方程也是非常明确的。只不过本题不仅求最长解的长度，而且要把这个最长解打印出来。这样的DP问题虽不常见，但也是很容易解决的。除了用一个DP数组记录“状态”外；再用一个prev数组记录当前i元素在Largest-Divisible-Subset里之前的那个元素的位置。回溯的大致代码是：
```cpp
    while (prev[k]!=k)
    {
      result.push_back(nums[k]);
      k = prev[k];
    }
```


[Leetcode Link](https://leetcode.com/problems/largest-divisible-subset)

$0
endsnippet

# ==> ./Dynamic_Programming/0368.Largest-Divisible-Subset/368.Largest-Divisible-Subset.cpp <==
snippet 0368.Largest-Divisible-Subset "0368.Largest-Divisible-Subset" b
class Solution {
public:
    vector<int> largestDivisibleSubset(vector<int>& nums) 
    {
        sort(nums.begin(),nums.end());
        int n = nums.size();
        if (n==0) return {};
        vector<int>dp(n,1);
        vector<int>prev(n,-1);

        for (int i=0; i<n; i++)
            for (int j=0; j<i; j++)
            {                
                if (nums[i]%nums[j]==0)
                {
                    dp[i] = max(dp[i], dp[j]+1);
                    if (dp[i]==dp[j]+1)
                        prev[i] = j;
                }                    
            }
        
        int len = 0, idx;
        for (int i=0; i<n; i++)
        {
            if (dp[i]>len)
            {
                len = dp[i];
                idx = i;
            }
        }

        vector<int>ret;
        while (idx!=-1)
        {
            ret.push_back(nums[idx]);
            idx = prev[idx];
        }
        return ret;
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/0375.Guess-Number-Higher-or-Lower-II/Readme.md <==
snippet 0375.Guess-Number-Higher-or-Lower-II "0375.Guess-Number-Higher-or-Lower-II" b
### 375.Guess-Number-Higher-or-Lower-II

此题的第一反应是：难道最优解不应该是每次取最中间的数吗？其实不是，每次取最中间的数，其实得到的是最快的策略，而不一定是代价最小的策略。比如说：1,2,3,4,5，按每次取最中间的策略，代价应该是3+4=7；但更优的策略应该是2+4=6.

那么应该怎么决策呢？那就要紧紧结合这个“代价函数”来考虑。假设F(1,n)表示对于从1~n的进行猜数游戏所需要付出的最小代价，我们应该怎么从中选择第一个数x才是最优的呢？假设我们选择了报数x，那么对应的代价是什么。显然，当前付出的的代价是x，那么之后呢？这就涉及到了对剩下两个区间的选择，之后的代价是F(1,x-1)还是F(x+1,n)？根据题意，其实应该是两者的最大值 max(F(1,x-1),F(x+1,n))。于是整个递归的思路就已经呼之欲出了：
```
F(1,n) = min( x + max(F(1,x-1),F(x+1,n)) )  for x=1,2,...,n
```
有了递归的思路，我们再考虑是否能够用DP来实现（本质就是加记忆化），来避免重复的搜索。很显然，递归的关系已经揭示了该如何自下而上地填充DP数组。

dp[i][j]表示对于i~j的区间进行猜数游戏所需要的最小代价。最终的结果就是返回dp[1][n]。从递归关系来看，我们应该先从小的区间片段开始填充，不断得到较大的、更大的区间片段，直至得到dp[1][n]。所以这个多层的for循环架构，最外层的应该是控制区间的长度len。
```cpp
          for (int len=2; len<=n; len++)        
            for (int i=1; i+len-1<=n; i++)
            {
                int j = i+len-1;
                dp[i][j] = INT_MAX/2;
                                
                for (int k=i; k<=j; k++)                                   
                    dp[i][j] = min(dp[i][j] , k + max(dp[i][k-1], dp[k+1][j]));                
            }     
```
以上是主体的架构。接下来需要考虑边界条件。边界条件主要是两个：一个是i==j的时候，即len==1，此时注意dp[i][j]=0（只有一个候选，不用猜就知道答案）。另外就是i>j，这种情况出现在k在[i:j]边界的时候，观察状态转移方程，应该使dp[i][j]不影响结果，可以设置为0.

[Leetcode Link](https://leetcode.com/problems/guess-number-higher-or-lower-ii)

$0
endsnippet

# ==> ./Dynamic_Programming/0375.Guess-Number-Higher-or-Lower-II/375.Guess-Number-Higher-or-Lower-II.cpp <==
snippet 0375.Guess-Number-Higher-or-Lower-II "0375.Guess-Number-Higher-or-Lower-II" b
class Solution {
public:
    int getMoneyAmount(int n) 
    {
        vector<vector<int>>dp(n+2,vector<int>(n+2,0));                
               
        for (int len=2; len<=n; len++)        
            for (int i=1; i+len-1<=n; i++)
            {
                int j = i+len-1;
                dp[i][j] = INT_MAX/2;
                                
                for (int k=i; k<=j; k++)                                   
                    dp[i][j] = min(dp[i][j] , k + max(dp[i][k-1], dp[k+1][j]));                
            }            
        return dp[1][n];        
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/0376.Wiggle-Subsequence/Readme.md <==
snippet 0376.Wiggle-Subsequence "0376.Wiggle-Subsequence" b
### 376.Wiggle-Subsequence

#### 解法1：贪心

我们将整个数组的函数曲线画出来，其实只要数有多少个“拐点”，就是最后的答案了。道理也很简单，最长的wiggle序列，一定会是尽量充分利用所有的拐点。

这里特别要注意的是如果有两个相邻的点相同怎么处理？算是“拐点”吗？不一定。我们只有定义某点斜率前后的正负号的改变才是算拐点。举个例子，当nums[i]>nums[i-1]的时候，这中间的斜率k为正；但如果之前的nums[i-2]==nums[i-1]的话，我们无法判定斜率是否改变了符号。因此我们需要记录下nums[i-1]之前最近的一个非零斜率k'，查看它的正负号再与当前的k作比较。所以我们每次更新某两个相邻点之间的斜率的时候，如果是零，我们认为这段斜率依然保持为之前最近的一个非零斜率。

核心代码如下
```cpp
        for (int i=1; i<nums.size(); i++)
        {
            int dir_pre = dir;
            
            if (nums[i]-nums[i-1]>0)
                dir = 1;
            else if (nums[i]-nums[i-1]<0)
                dir = -1;
            else   
                dir = dir_pre;

            if (dir!=dir_pre)
                ret++;
        }
```

#### 解法2：DP

设计两个状态变量：p表示截止目前为止，最后一个元素是上升趋势的最长wiggle子序列；q表示截止目前为止，最后一个元素是下降趋势的最长wiggle子序列。

首先我们要有这样一个概念。无论当前元素x是什么，p序列的最后一个元素要么是x，要么只能是在x前面、但是比x大的元素。反证：如果存在一个元素y在x前面、且比x要小，那么这个将y从p序列的结尾里去掉、改成x加入p序列的结尾，同样不影响p序列的性质和长度。同理，无论当前元素x是什么，q序列的最后一个元素要么是x，要么只能是在x前面、但是比x小的元素。

回到我们的问题。我们每查看一个数字，尝试更新两个变量p和q。当nums[i]>nums[i-1]大时，由前面可知，原先q序列的结尾元素一定比nums[i]小，于是再接上nums[i]的话q序列一定不会变的更长。同时，原先q序列的结尾一定比nums[i]小，接上nums[i]之后，就可以得到一个新的p的序列。故有```q不变，p=q+1```.

类似地，当nums[i]<nums[i-1]小时，由前面可知，原先p序列的结尾元素一定比nums[i]大，于是再接上nums[i]的话p序列一定不会变的更长。同时，原先p序列的结尾一定比nums[i]大，接上nums[i]之后，就可以得到一个新的q的序列。故有```p不变，q=p+1```.

因为无法确定最长wiggle序列的最后一段是上升还是下降，因此最后的答案是在p和q之间选最大值。


[Leetcode Link](https://leetcode.com/problems/wiggle-subsequence)

$0
endsnippet

# ==> ./Dynamic_Programming/0376.Wiggle-Subsequence/376.Wiggle-Subsequence_DP.cpp <==
snippet 0376.Wiggle-Subsequence "0376.Wiggle-Subsequence" b
class Solution {
public:
    int wiggleMaxLength(vector<int>& nums) 
    {
        if (nums.size()==0) return 0;
        
        int p=1;
        int q=1;
        
        for (int i=1; i<nums.size(); i++)
        {
            if (nums[i]>nums[i-1])
                p=q+1;
            else if (nums[i]<nums[i-1])
                q=p+1;
        }
        
        return max(p,q);
        
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/0376.Wiggle-Subsequence/376.Wiggle-Subsequence_v1.cpp <==
snippet 0376.Wiggle-Subsequence "0376.Wiggle-Subsequence" b
class Solution {
public:
    int wiggleMaxLength(vector<int>& nums) 
    {
        if (nums.size()==0) return 0;

        int ret = 1, dir = -2;
        for (int i=1; i<nums.size(); i++)
        {
            int dir_pre = dir;
            
            if (nums[i]-nums[i-1]>0)
                dir = 1;
            else if (nums[i]-nums[i-1]<0)
                dir = -1;
            else   
                dir = dir_pre;

            if (dir!=dir_pre)
                ret++;
        }

        return ret;
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/0377.Combination-Sum-IV/Readme.md <==
snippet 0377.Combination-Sum-IV "0377.Combination-Sum-IV" b
### 377.Combination-Sum-IV

此题直观上可以用DFS（也就是递归）来实现对所有的comb的完整遍历，然后统计总数。但结果发现会超时。

此时应该立刻想到，这种求总数的题目，很大概率是可以用DP算法来实现的。用dp[i]表示总和为i的组合的数目，我们想一下怎么建立起它与其他dp[j]的传递关系。这里的突破口就是：在这些总和为i的组合里，最后一个数字可能是什么。假设最后一个数是x（x是nums中的一个元素），那么dp[i-x]就是总和为i-x的组合的数目，如果我们已经知道了这些组合，只要直接再附上x，就能满足总和为i的条件。因此传递关系是：
```cpp
dp[i] = 0;
for (int x: nums)
    if (i>=x) dp[i]+=dp[i-x];
```
对于所有```i=1,2,..,target```，算出每个数对应的dp值。最终的答案就是dp[target]。

需要注意到，这种DP算法的前提是target不能非常大，否则dp数组会很占空间。

另外，对于C++程序可能会遇到个别dp[i]的值非常大，计算的时候会整形溢出而报错。我们可以设计```vector<unsigned int>dp```，这是因为对于无符号的整形，其溢出后的操作是C++定义好的行为，可以避免程序终止。当然，这只是一种hack的技巧，我们使用它是因为题目保证dp[target]一定返回的是整形，我们猜测最终结果不会依赖于这些溢出的dp值。


[Leetcode Link](https://leetcode.com/problems/combination-sum-iv)
$0
endsnippet

# ==> ./Dynamic_Programming/0377.Combination-Sum-IV/377.Combination-Sum-IV.cpp <==
snippet 0377.Combination-Sum-IV "0377.Combination-Sum-IV" b
class Solution {
public:
    int combinationSum4(vector<int>& nums, int target) 
    {
        vector<unsigned int>dp(target+1,0);
        dp[0] = 1;
        for (int sum=1; sum<=target; sum++)
        {
            for (int x: nums)
            {
                if (sum-x>=0)
                    dp[sum] += dp[sum-x];
            }
        }
        return dp[target];
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/0410.Split-Array-Largest-Sum/Readme.md <==
snippet 0410.Split-Array-Largest-Sum "0410.Split-Array-Largest-Sum" b
### 410.Split-Array-Largest-Sum

#### 解法1: DP  
大多数的数组问题都可以用动态规划解决。 

设计dp[i][k]表示元素1~i分成k份的最佳方案，即最大子区段的最小可能值。  

如何设计转移方程呢？无非就是考虑dp[i][k]和这些前态的关系：dp[i-？][k], dp[i][k-？]。  
可以发现，dp[i][k]和dp[i-1][k-1]有直接关系。遍历所有将前j个元素（j最小就是k-1）分成k-1份的方案，加上最后一份（就是 sum[i]-sum[j]）的影响。 

所以转移方程是： dp[i][k]=min{j} ( max(dp[j][k-1],sum[i]-sum[j]) )

注意的细节是，sum[i]的计算可能会溢出。sum[i]-sum[j]可以转化为 dp[i][1]-dp[j][1].

#### 解法2: Binary Search
进行k的二分搜索，k就是代表nums分成m份后最大自区段的和。
分析：k的最小值是nums里的最大值；k的最大值是数组元素的总和；对于任一个mid，另写函数用贪心法判断是否满足要求。满足要求的话，就继续缩小k来尝试。

如何判断k是否可行呢？两个判据：
1. 如果任何nums[i]>k，则不可行。
2. 尽可能地合并元素，使得任何子区段的和都不超过k，并在遍历的过程中记录这些子区段的数目，超过m的话就说明不可行。

此题和 ```1011. Capacity To Ship Packages Within D Days``` 几乎一模一样。


[Leetcode Link](https://leetcode.com/problems/split-array-largest-sum)
$0
endsnippet

# ==> ./Dynamic_Programming/0410.Split-Array-Largest-Sum/410.Split Array Largest Sum_Binary.cpp <==
snippet 0410.Split-Array-Largest-Sum "0410.Split-Array-Largest-Sum" b
class Solution {
public:
    int splitArray(vector<int>& nums, int m) 
    {
        long left = 0, right = INT_MAX;
        
        while (left<right)
        {
            int mid = left+(right-left)/2;
            if (checkOK(nums, m, mid))
                right = mid;
            else
                left = mid+1;
        }
        
        return left;
    }
    
    bool checkOK(vector<int>& nums, int m, long val)
    {
        int count = 0;
        for (int i=0; i<nums.size(); i++)
        {
            if (nums[i] > val) return false;
            
            int j = i;
            long sum = 0;
            while (j<nums.size() && sum+(long)nums[j]<=val)
            {
                sum += (long)nums[j];
                j++;
            }
            count++;
            i = j-1;
        }
        
        return count <= m;
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/0410.Split-Array-Largest-Sum/410.Split Array Largest Sum_dp.cpp <==
snippet 0410.Split-Array-Largest-Sum "0410.Split-Array-Largest-Sum" b
class Solution {
public:
    int splitArray(vector<int>& nums, int m) 
    {
        int N = nums.size();
        auto dp = vector<vector<long>>(N+1,vector<long>(m+1, INT_MAX));
        nums.insert(nums.begin(),0);
        
        dp[0][0] = 0;
        
        for (int i=1; i<=N; i++)
            for (int k=1; k<=min(m,i); k++)
            {
                long sum = 0;
                for (int j=i; j>=k; j--)
                {
                    sum += nums[j];
                    dp[i][k] = min(dp[i][k], max(dp[j-1][k-1], sum));
                }
            }
        
        return dp[N][m];
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/0416.Partition-Equal-Subset-Sum/Readme.md <==
snippet 0416.Partition-Equal-Subset-Sum "0416.Partition-Equal-Subset-Sum" b
### 416.Partition-Equal-Subset-Sum

本题是个NP问题。可以采用DFS的方法来暴力枚举，虽然可以利用各种剪枝优化的手段，但根本的时间复杂度仍然是o(2^N)。早期的时候DFS的版本是可以AC的，但是最近被TLE了。

于是我们可以换一个“答案空间”去切入，那就是用背包问题的想法。DFS的解法其实是寻找在一个N维空间上搜索答案(1,0,0,....,0,1,1)，其中0/1表示该数字我们是否选择。显然这个空间的候选数目的order达到了指数级别。“背包问题”就是改变解答空间，思考如果我们构建任意和为s的subset的话，是否能够实现目标。对于s而言，它的范围是从0到nums.size()*nums[i]=2e4. 这个空间是大大缩小的了。举个例子，假如dp[10]=true表示我们可以选择一部分数字加起来是10，那么我们试图思考，我们能否利用这部分数字再加上一些其他数字，使得总和是20呢？也就是说，我们能否通过dp[10]=true来帮助判断dp[20]=true呢？

这就是01背包问题的基本思想。如果dp的空间大小合理，那么我们就可以来解决之前DFS所无法处理的复杂度。基本的模板如下：
```
for (auto x: nums) // 遍历物品
  for (auto s= 0 to sum/2) // 遍历容量
    if dp'[s-x] = true
      dp[s] = true   // 如果考察x之前，已经能够凑出s-x，那么加上x这个数字就一定能凑出和为x的subset。
``` 

此外还有另外一种dp的写法
```
for (auto x: nums) // 遍历物品
  for (auto s= 0 to sum/2) // 遍历容量
    if dp'[s] = true
      dp[s+x] = true   // 如果考察x之前，已经能够凑出s，那么加上x这个数字就一定能凑出和为s+x的subset。
``` 


$0
endsnippet

# ==> ./Dynamic_Programming/0416.Partition-Equal-Subset-Sum/416.Partition-Equal-Subset-Sum.cpp <==
snippet 0416.Partition-Equal-Subset-Sum "0416.Partition-Equal-Subset-Sum" b
class Solution {
public:
    bool canPartition(vector<int>& nums) 
    {
        int sum = accumulate(nums.begin(),nums.end(),0);
        if (sum%2!=0) return false;
        
        vector<bool>dp(sum/2+1,0);
        dp[0] = true;

        for (auto x: nums)
        {
            for (int s = sum/2; s>=1; s--)
            {
                if (s-x>=0 && dp[s-x]==true)
                    dp[s] = true;
            }
        }
        return dp[sum/2];
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/0416.Partition-Equal-Subset-Sum/416.Partition-Equal-Subset-Sum_dfs_v1.cpp <==
snippet 0416.Partition-Equal-Subset-Sum "0416.Partition-Equal-Subset-Sum" b
class Solution {
    unordered_set<int>visited;
public:
    bool canPartition(vector<int>& nums) 
    {
        int sum = accumulate(nums.begin(), nums.end(), 0);
        sort(nums.begin(), nums.end());
        if (sum%2!=0) return false;
        return dfs(nums, 0, 0, sum/2);        
    }
    
    bool dfs(vector<int>& nums, int cur, int curSum, int targetSum)
    {
        int hash = curSum * 1000 + cur;
        if (visited.find(hash)!=visited.end()) 
            return false;
        
        if (curSum == targetSum) return true;
        if (curSum > targetSum) return false;
        if (cur==nums.size()) return false;
        
        for (int i=cur; i<nums.size(); i++)
        {
            if (i>cur && nums[i]==nums[i-1])
            {
                visited.insert((curSum+nums[i])*1000 + i);
                continue;
            }
            if (dfs(nums, i+1, curSum+nums[i], targetSum))
                return true;            
        }
        visited.insert(hash);
        return false;        
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/0416.Partition-Equal-Subset-Sum/416.Partition-Equal-Subset-Sum_dfs_v2.cpp <==
snippet 0416.Partition-Equal-Subset-Sum "0416.Partition-Equal-Subset-Sum" b
class Solution {
    unordered_set<int>visited;
public:
    bool canPartition(vector<int>& nums) 
    {
        int sum = accumulate(nums.begin(), nums.end(), 0);
        if (sum%2!=0) return false;
        return dfs(nums, sum/2, 0, 0);        
    }
    
    bool dfs(vector<int>& nums, int targetSum, int i, int sum)
    {
        int hash = sum * 1000 + i;
        if (visited.find(hash)!=visited.end())
            return false;
        
        if (sum== targetSum)
            return true;
        
        if (sum> targetSum)
            return false;
        
        if (i == nums.size())
            return false;
        
        if (dfs(nums, targetSum, i + 1, sum+ nums[i]) || dfs(nums, targetSum, i + 1, sum))
            return true;
        
        visited.insert(hash);
        return false;        
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/0416.Partition-Equal-Subset-Sum/416.Partition-Equal-Subset-Sum_v2.cpp <==
snippet 0416.Partition-Equal-Subset-Sum "0416.Partition-Equal-Subset-Sum" b
class Solution {
public:
    bool canPartition(vector<int>& nums) 
    {
        int sum = accumulate(nums.begin(),nums.end(),0);
        if (sum%2!=0) return false;
        
        unordered_set<int>dp;
        dp.insert(0);

        for (auto x: nums)
        {
            vector<int>temp;
            for (auto s: dp)
            {
                if (s+x==sum/2) return true;
                temp.push_back(s+x);
            }
            for (auto a: temp)
                dp.insert(a);
        }
        return false;
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/0416.Partition-Equal-Subset-Sum/416.Partition-Equal-Subset-Sum_v3.cpp <==
snippet 0416.Partition-Equal-Subset-Sum "0416.Partition-Equal-Subset-Sum" b
class Solution {
public:
    bool canPartition(vector<int>& nums) 
    {
        int sum = accumulate(nums.begin(),nums.end(),0);
        if (sum%2!=0) return false;
        
        vector<bool>dp(sum/2+1,0);
        dp[0] = true;

        for (auto x: nums)
        {
            for (int s = sum/2; s>=0; s--)
            {
                if (dp[s]==false) continue;
                if (s+x<=sum/2)
                    dp[s+x] = true;
            }        
        }
        return dp[sum/2];
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/0465.Optimal-Account-Balancing/Readme.md <==
snippet 0465.Optimal-Account-Balancing "0465.Optimal-Account-Balancing" b
### 465.Optimal-Account-Balancing

此题是个经典的NP-complete问题。我们知道，如果N个人的净负债为零的话，我们最多需要N-1次转账就可以实现抹平。所以我们的目的是将所有人尽量多的拆成若干个净负债为零的小组。这样，最优答案就是总人数减去小组的个数。

NP问题的搜索算法，一般有两个方向：DFS和状态压缩DP。对于本题，状态压缩DP是经典的解法。

令一个Ｎ位的二进制数state来记录哪些人被选中组成小组，sum[state]表示这群人的集体净负债，dp[state]表示这群人实现账目平衡需要的最少操作数（也就是对应最多包含了多少个零净负债小组）。对于满足```sum[state]==0```的集合，我们试图将其拆分成两个零净负债的子集，所以我们遍历其子集subset：如果sum[subset]也为零，那么dp[state]就有机会更新为两部分子集的dp之和。
```cpp
      for (int state = 0; state < (1<<n); state++)
        {
            if (sum[state] != 0)  continue;
            dp[state] = __builtin_popcount(state)-1;
            for (int subset=state-1; subset>0; subset=(subset-1)&state)
            {
                if (sum[subset]==0)
                  dp[state] = min(dp[state], dp[subset]+dp[state-subset]);
            }
        }
```
最终输出的答案就是dp[(1<<N)-1]. 上述两层for循环实现了遍历所有状态的子集，时间复杂度是o(3^N).

[Leetcode Link](https://leetcode.com/problems/optimal-account-balancing)

$0
endsnippet

# ==> ./Dynamic_Programming/0465.Optimal-Account-Balancing/465.Optimal-Account-Balancing.cpp <==
snippet 0465.Optimal-Account-Balancing "0465.Optimal-Account-Balancing" b
class Solution {
public:
    int minTransfers(vector<vector<int>>& transactions) 
    {
        unordered_map<int,int>balance;
        for (auto& t: transactions)
        {
            balance[t[0]]+=t[2];
            balance[t[1]]-=t[2];
        }
        vector<int>nums;
        for (auto x: balance)
            nums.push_back(x.second);

        int n = nums.size();        
        vector<int>sum(1<<n, 0);
        for (int state = 0; state < (1<<n); state++)
        {            
            for (int i=0; i<n; i++)
            {
                if ((state>>i)&1)
                    sum[state] += nums[i];
            }             
        }

        vector<int>dp(1<<n, INT_MAX/2);
        for (int state = 0; state < (1<<n); state++)
        {
            if (sum[state] != 0)  continue;
            dp[state] = __builtin_popcount(state)-1;
            for (int subset=state-1; subset>0; subset=(subset-1)&state)
            {
                if (sum[subset]==0)
                {
                    dp[state] = min(dp[state], dp[subset]+dp[state-subset]);
                }
                    
            }
        }
        return dp[(1<<n)-1];
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/0471.Encode-String-with-Shortest-Length/Readme.md <==
snippet 0471.Encode-String-with-Shortest-Length "0471.Encode-String-with-Shortest-Length" b
### 471.Encode-String-with-Shortest-Length

令dp[i][j]表示区间s[i:j]可以encode的最短字符串。我们需要知道，对于任意区间s[i:j]，high level的encode方式有三类:
1. dp[i][j]就是s[i:j].
2. s[i:j]是若干个相同子串t的k次重复，每个子串长度是len，那么dp[i][j]可以写成```k[t]```的形式，注意t应该是dp[i][i+len-1]而不是原始的子串。另外，我们需要对k进行遍历得到最优的encode。
3. 我们还可以探索合适的切割点将dp[i][j]分为前后两部分，得到长度最优的```dp[i][j] = dp[i][k]+dp[k+1][j]```。

这是第二类区间型DP，动态规划的顺序是先小区间、后大区间。最终的答案就是dp[0][n-1].

$0
endsnippet

# ==> ./Dynamic_Programming/0471.Encode-String-with-Shortest-Length/471.Encode-String-with-Shortest-Length.cpp <==
snippet 0471.Encode-String-with-Shortest-Length "0471.Encode-String-with-Shortest-Length" b
class Solution {
    string dp[150][150];
public:
    string encode(string s) 
    {
        int n = s.size();
        for (int i=0; i<n; i++)
            dp[i][i] = s.substr(i,1);
                               
        for (int len = 2; len <=n; len++)
            for (int i=0; i+len-1<n; i++)
            {
                int j = i+len-1;
                dp[i][j] = help(s, i, j);
                for (int k=i; k<j; k++)
                {
                    if (dp[i][k].size() + dp[k+1][j].size() < dp[i][j].size())
                        dp[i][j] = dp[i][k]+dp[k+1][j];
                }
            }
        return dp[0][n-1];        
    }
    
    string help(string& str, int a, int b)
    {
        string s = str.substr(a, b-a+1);
        string ret = s;
        for (int len=1; len<s.size(); len++)
        {
            if (s.size()%len!=0) continue;
            int flag = 1;
            for (int i=len; i<s.size(); i+=len)
            {
                if (s.substr(i, len)!=s.substr(0, len))
                {
                    flag = 0;
                    break;
                }
            }
            if (flag == 1)
            {
                string t = to_string(s.size()/len)+"["+dp[a][a+len-1]+"]";
                if (t.size() < ret.size())
                    ret = t;
            }
        }
        return ret;
    }    
};

$0
endsnippet

# ==> ./Dynamic_Programming/0474.Ones-and-Zeroes/Readme.md <==
snippet 0474.Ones-and-Zeroes "0474.Ones-and-Zeroes" b
### 474.Ones-and-Zeroes

本题本质就是0-1背包问题，只不过cost变成了两个量。0-1背包问题已经有非常成熟的套路了。dp[i][j]表示用i个0和j个1最多可以拼出多少个完整的字符串。

```cpp
        for (int k=0; k<strs.size(); k++)  //遍历所有的字符串
        {
            检查当前字符串strs[k]，得到有zeros个0，ones个1;
                            
            auto temp=dp;
            for (int i=zeros; i<=m; i++)
             for (int j=ones; j<=n; j++)
             {
                 dp[i][j]=max(temp[i][j],temp[i-zeros][j-ones]+1);
                 //在循环体里更新所有的dp[i][j]。
                 //这里用了一个temp来保存上一轮（即处理上一个字符串时）的dp
                 //对于当前的字符串，有两种选择，要么不加入，则dp[i][j]不变；要么加入，则更新为temp[i-zeros][j-ones]+1                
             }            
        }
```

这里用temp的原因是方便起见，以免更新dp时使用了这一轮的新dp值。当然，也有取巧的办法省下temp的开辟，即在两个内存for循环里将i，j都按从大到小遍历，那么更新dp时就不会与新值冲突。


[Leetcode Link](https://leetcode.com/problems/ones-and-zeroes)
$0
endsnippet

# ==> ./Dynamic_Programming/0474.Ones-and-Zeroes/474.Ones-and-Zeroes.cpp <==
snippet 0474.Ones-and-Zeroes "0474.Ones-and-Zeroes" b
class Solution {
public:
    int findMaxForm(vector<string>& strs, int m, int n) 
    {
        auto dp=vector<vector<int>>(m+1,vector<int>(n+1,0));
        
        for (int k=0; k<strs.size(); k++)
        {
            int ones=0;
            int zeros=0;
            for (int i=0; i<strs[k].size(); i++)
            {
                if (strs[k][i]=='0') zeros++;
                else ones++;
            }
                            
            auto temp=dp;
            for (int i=zeros; i<=m; i++)
             for (int j=ones; j<=n; j++)
             {
                 dp[i][j]=max(temp[i][j],temp[i-zeros][j-ones]+1);
             }
        }
                
        return dp[m][n];
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/0487.Max-Consecutive-Ones-II/Readme.md <==
snippet 0487.Max-Consecutive-Ones-II "0487.Max-Consecutive-Ones-II" b
### 487.Max Consecutive Ones II  

类似于动态规划的思想，设计两个状态变量： count1记录当前从未使用反转权力、可以得到的连续1的个数；count2记录当前已经使用反转权力、可以得到的连续1的个数。

如果nums[i]==1，那么count1和count2各自加1，没有问题。

如果nums[i]==0，那么count1要置零；count2怎么办呢？事实上count2=count1+1既可。

一路上追踪最大曾出现过的count2就是最后的答案。


[Leetcode Link](https://leetcode.com/problems/max-consecutive-ones-ii)
$0
endsnippet

# ==> ./Dynamic_Programming/0487.Max-Consecutive-Ones-II/487.Max-Consecutive-Ones-II.cpp <==
snippet 0487.Max-Consecutive-Ones-II "0487.Max-Consecutive-Ones-II" b
class Solution {
public:
    int findMaxConsecutiveOnes(vector<int>& nums) 
    {
        int s0=0,s1=0;        
        
        int result=0;
        for (int i=0; i<nums.size(); i++)
        {
            if (nums[i]==0)
            {
                s1 = s0+1;
                s0 = 0;                
            }
            else
            {
                s0++;
                s1++;
            }
            result = max(result,s0);
            result = max(result,s1);
        }
        
        return result;
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/0494.Target-Sum/Readme.md <==
snippet 0494.Target-Sum "0494.Target-Sum" b
### 494.Target-Sum

此题用DFS最为直观，但是容易超时，所以记忆化是必须的。除此之外，仍有剪枝的空间。比如当前剩余的数字之和仍小于target的绝对值，那么就可以提前终止。

此题还有一个比较巧妙的解法是DP。这主要得益于题目给出的维度不大，所有元素的SUM小于1000，元素总数N小于20.于是我们可以开辟DP数组```DP[i][s]```，表示前i个数可以通过加减运算得到s的个数。那么显然就有动态转移方程：
```
for i = 0 to N-1
   for s = -SUM to SUM
   {
      dp[i][s]+=dp[i-1][s-nums[i]]
      dp[i][s]+=dp[i-1][s+nums[i]]
   }
```
唯一需要考虑的问题是，s可能是负数，而s作为数组的index不能为负。解决方法就是给s加上一个SUM的偏移，将```[-SUM,SUM]```的区间平移至```[0,SUM*2]```作为DP数组的第二个维度的index


[Leetcode Link](https://leetcode.com/problems/target-sum)
$0
endsnippet

# ==> ./Dynamic_Programming/0494.Target-Sum/494.Target-Sum_DP_v2.cpp <==
snippet 0494.Target-Sum "0494.Target-Sum" b
class Solution {
public:
    int findTargetSumWays(vector<int>& nums, int S) 
    {
        unordered_map<int,int>Map;
        Map[0] = 1;
        
        for (auto x: nums)
        {
            auto Map_temp = Map;
            Map.clear();
            for (auto a: Map_temp)
            {
                Map[a.first+x] += a.second;
                Map[a.first-x] += a.second;
            }
        }
        return Map[S];
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/0494.Target-Sum/494.Target-Sum_DP_v3.cpp <==
snippet 0494.Target-Sum "0494.Target-Sum" b
class Solution {
public:
    int findTargetSumWays(vector<int>& nums, int S) 
    {
        int sum = accumulate(nums.begin(), nums.end(), 0);
        if (S>sum || S<-sum) return false;
        
        int offset = sum;        
        vector<int>dp(2*offset+1);
        dp[0+offset] = 1;
        
        for (auto x: nums)
        {
            auto temp = dp;
            for (int i=-offset; i<=offset; i++)
            {
                dp[i+offset] = 0;
                if (i-x>=-offset)
                    dp[i+offset] += temp[i-x+offset];
                if (i+x<=offset)
                    dp[i+offset] += temp[i+x+offset];
                //cout<<x<<" "<<i<<" "<<dp[i+offset]<<endl;
            }
        }
        
        return dp[S+offset];
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/0514.Freedom-Trail/Readme.md <==
snippet 0514.Freedom-Trail "0514.Freedom-Trail" b
### 514.Freedom-Trail

我们知道第i次操作的时候，一定是将key[i]这个字符移动到12点位置，并且我们还知道，在操作之前，处在12点位置的字符一定是key[i-1].

于是有两个问题：当ring存在多个重复的字符时，我们移动哪个key[i]到12点位置？另外，已经处于12点位置的那个key[i-1]又是ring上面的哪一个？

其实我们把所有的“最优子问题”都带上这两个参数就可以轻松来做动态规划了。

我们定义dp[i][cur_pos]表示第i轮我们要将ring上的cur_pos这个字符移动到12点位置，所对应的最优解（也就是最少转动次数）。显然这个cur_pos一定会是对应着key[i]。那么它的前驱状态是什么？显然是dp[i-1][prev_pos]，表示前一轮的时候我们是把ring上的prev_pos这个字符移动在了12点位置；同理，这个prev_pos一定会是对应着key[i-1]。

于是这个问题就变成了从prev_pos对着12点，转动到cur_pos对着12点，最少需要转动几步？无非就是顺时针转或逆时针转而以。于是
```cpp
dp[i][cur_pos] = dp[i-1][prev_pos]+min( abs(prev_pos-cur_pos), ring.size()-abs(prev_pos-cur_pos) )
```
特别注意，这样的prev_pos会有多个，我们需要取它们之中的最小值。

$0
endsnippet

# ==> ./Dynamic_Programming/0514.Freedom-Trail/514.Freedom-Trail.cpp <==
snippet 0514.Freedom-Trail "0514.Freedom-Trail" b
class Solution {
public:
    int findRotateSteps(string ring, string key) 
    {
        unordered_map<char,vector<int>>letter2pos;
        for (int i=0; i<ring.size(); i++)
            letter2pos[ring[i]].push_back(i);

        int n = key.size();
        int m = ring.size();
        auto dp = vector<vector<int>>(n, vector<int>(m, INT_MAX/2));

        for (int i=0; i<n; i++)
        {
            if (i==0)
            {
                for (int cur_pos : letter2pos[key[i]])
                    dp[i][cur_pos] = min(cur_pos, abs(m-cur_pos));                    
            }
            else if (i>=1)
            {
                for (int cur_pos : letter2pos[key[i]])                
                    for (int prev_pos : letter2pos[key[i-1]])                                        
                        dp[i][cur_pos] = min(dp[i][cur_pos], dp[i-1][prev_pos] + min(abs(cur_pos-prev_pos), m-abs(cur_pos-prev_pos)));                     
            }
        }

        int ret = INT_MAX;
        for (int pos: letter2pos[key[n-1]])
            ret = min(ret, dp[n-1][pos]);
        return ret+n;
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/0516.Longest-Palindromic-Subsequence/Readme.md <==
snippet 0516.Longest-Palindromic-Subsequence "0516.Longest-Palindromic-Subsequence" b
### 516.Longest-Palindromic-Subsequence

这是一道典型的DP题。凡是以数组形式出现的，求最大/最小/最多/最少而求非完整策略的题目，都不妨考虑一下DP算法的可能性。最常见的状态数组就是设计成```dp[i][j]```，表示在```[i,j]```区间内的最优解，我们需要考察这个状态能否向下（即更小规模的区间）转移。

既然是判断```dp[i][j]```是否包含构成回文的subsequence，那么自然从两头往中间思考。如果```s[i]==s[j]```的话，那么不要犹豫，这两个一定就是最长回文子序列中的成员。所以```dp[i][j]=dp[i+1][j-1]+2```

如果```s[i]!=s[j]```呢？这说明```s[i]```和```s[j]```两个中必然有一个不是最长回文子序列的成员（否则如果这两个都是的话，会造成最长回文子序列的两端不对称），于是我们就可以排除一个。所以```dp[i][j]=max(dp[i][j-1],dp[i+1][j]```，这是一个很常见的处理方法。

有了以上的动态转移方程，就可以写DP算法了。注意虽然整体思路是从上往下分析，但DP算法的实现是从下往上的。在这一题里，总体思想是先构建较短区间的dp值，慢慢扩展到较长区间的dp值。所以在最外层的循环里，我们控制一个len的变量，使其从到大变化。

此外，对于DP的初始条件，不难分析出```dp[i][i]==1```是必然的。然而，我们还需要铺垫所有的```dp[i][i+1]```，目的是避免在动态转移的过程中出现```dp[x][y], x>y```的情况。

#### Follow Up:
如果用若干个一维数组代替这个N\*N的二维数组，速度会有更大的提升。


[Leetcode Link](https://leetcode.com/problems/longest-palindromic-subsequence)
$0
endsnippet

# ==> ./Dynamic_Programming/0516.Longest-Palindromic-Subsequence/516.Longest-Palindromic-Subsequence.cpp <==
snippet 0516.Longest-Palindromic-Subsequence "0516.Longest-Palindromic-Subsequence" b
class Solution {
public:
    int longestPalindromeSubseq(string s) 
    {
        int N = s.size();
        s = "#" + s;
        auto dp = vector<vector<int>>(N+1,vector<int>(N+1,0));
        
        for (int i=1; i<=N; i++)
            dp[i][i] = 1;
        
        for (int len=2; len<=N; len++)
            for (int i=1; i+len-1<=N; i++)
            {                
                int j = i+len-1;
                if (s[i]==s[j])
                    dp[i][j] = dp[i+1][j-1]+2;
                else
                    dp[i][j] = max(dp[i][j-1], dp[i+1][j]);
            }
        return dp[1][N];
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/0518.Coin-Change-2/Readme.md <==
snippet 0518.Coin-Change-2 "0518.Coin-Change-2" b
### 518.Coin-Change-2

这道题看上去很像完全背包问题，因为所有的硬币可以无限使用。让我们回顾一下传统的完全背包是怎么做的。我们令dp[c]表示总（实际使用）容量为c的时候可以装的最大价值。外层循环遍历容量，内层循环遍历最后一件放入的物品：
```
for c in capcity:
    for i in obj:
        dp[c] = max(dp[c], dp[c-cost[i]]+val[i];
```
但是如果将完全背包的算法套到这个问题上来是不对的。上述的完全背包问题里，如果A、B两件物品构成了容量c的最优解，那么计算dp[c]时无论考虑A是最后一件还是B是最后一件，得到的dp[c]都是一样的（即两件物品的价值之和）。

但是在本题中，我们求的是组合方法的种类。如果我们定义dp[c]表示容量c的组合数，那么考虑先A后B的方法的话，dp[c]+=dp[a];但是考虑先B后A的方法的话，dp[c]+=dp[b]. 显然这两次的自增是重复计算AB这套组合了。所以此题的本质并不是一个完全背包问题，因为它的问题并不是求总价值的最优。

那么抛开完全背包问题的思维束缚，该如何思考这道题呢？我们知道为了避免在组合选数中重复计数，一个常见的办法就是排个序：意思是如果取若干个A之后再取若干个B的话，那么之后我们就不能再取A了。所以我们可以依次考虑每个硬币、以及每个硬币能选几个：
```cpp
for (int i=0; i<coins.size(); i++)
    for (int c=1; c<=amount; c++)
    {
        for (int k=0; k<=c/coins[i]; k++)
            dp[i][c] += dp[i-1][c - k*coins[i]];
    }
```
其中dp[i][c]表示使用前i种硬币、组成面值为c的组合方法数。注意，外层的两个循环其实可以对调，不影响结果。并且我们还可以只用一维数组：
```cpp
for (int i=0; i<coins.size(); i++)
{            
    auto dp_temp = dp;            
    for (int c=1; c<=amount; c++)
    {
        dp[c] = 0;
        for (int k=0; k<=c/coins[i]; k++)
            dp[c] += dp_temp[c-k*coins[i]];
    }
}
```

但是这三重循环的效率有点低。如果我们只用dp[c]来表示面值为c的组合方法数，那么可以化简为
```cpp
for (int i=0; i<coins.size(); i++)
    for (int c=1; c<=amount; c++)
    {        
        dp[c] += dp[c - coins[i]];
    }
```
这是因为我们在计算dp[c]时，考虑的是末尾是coins[i]的方案。巧妙的是，我们不需要分类考虑dp[c]的末尾到底应该有几个，只需要考虑如果有一个的话，可以直接转化为dp[c-coins[i]]。而dp[c-coins[i]]是已经提前计算好了的（因为c-coins[i]比c小）、同样也表示末尾是coins[i]的方案。有点递归的感觉。

[Leetcode Link](https://leetcode.com/problems/coin-change-2)

$0
endsnippet

# ==> ./Dynamic_Programming/0518.Coin-Change-2/518.Coin-Change-2_v1.cpp <==
snippet 0518.Coin-Change-2 "0518.Coin-Change-2" b
class Solution {
public:
    int change(int amount, vector<int>& coins) 
    {
        vector<int>dp(amount+1,0);
        dp[0] = 1;
        for (int i=0; i<coins.size(); i++)
        {            
            auto dp_temp = dp;            
            for (int c=1; c<=amount; c++)
            {
                dp[c] = 0;
                for (int k=0; k<=c/coins[i]; k++)
                    if (c>=k*coins[i])
                        dp[c] += dp_temp[c-k*coins[i]];
            }
        }
        return dp[amount];        
    }    
};

$0
endsnippet

# ==> ./Dynamic_Programming/0518.Coin-Change-2/518.Coin-Change-2_v2.cpp <==
snippet 0518.Coin-Change-2 "0518.Coin-Change-2" b
class Solution {
public:
    int change(int amount, vector<int>& coins) 
    {
        vector<int>dp(amount+1,0);
        dp[0] = 1;
        for (int i=0; i<coins.size(); i++)
        {                        
            for (int c=1; c<=amount; c++)
            {        
                if (c>=coins[i])
                    dp[c] += dp[c-coins[i]];
            }
        }
        return dp[amount];        
    }    
};

$0
endsnippet

# ==> ./Dynamic_Programming/0552.Student-Attendance-Record-II/Readme.md <==
snippet 0552.Student-Attendance-Record-II "0552.Student-Attendance-Record-II" b
### 552.Student-Attendance-Record-II

此题明显要用DP，但是如何设计状态和状态转移方程都非常难想。但最终的解法其实也非常巧妙，原来用到了多元状态的转移。

任何一种排列，可以归结为六种状态：dp00,dp01,dp02,dp10,dp11,dp12. 状态dp_ij的定义是：其中i表示这个数列里absence出现的次数，显然对于一个valid的数列，i的范围只能是0和1；j表示这个数列里末尾连续出现late的次数，显然对于一个valid的数列，i的范围只能是0，1，2。因此有六种状态的定义。

显然我们可以发现，随着record长度的增加，序列的状态就是在这六种之间转移。规律如下：
```
新状态   旧状态
dp02[i]  =  do01[i-1]  // 加'L'转变而来
dp01[i]  =  dp00[i-1]  // 加'L'转变而来
dp00[i]  =  dp00[i-1]+dp01[i-1]+dp02[i-1] // 分别加'P'转变而来
dp12[i]  =  dp11[i-1]  // 加'L'转变而来
dp11[i]  =  dp10[i-1]  // 加'L'转变而来
dp10[i]  =  dp10[i-1]+dp11[i-1]+dp12[i-1]+dp00[i-1]+dp01[i-1]+dp02[i-1] // 前三种加'P'转变而来，后三种加'A'转变而来
```
当然，因为dp**[i]的状态只取决于dp**[i-1]，所以也可以不用设置六个一位数组，节省一点空间。

另外，唯一需要需要注意的边界条件是```dp00[0]=1```

类似的DP题目还有：    
714.Best-Time-to-Buy-and-Sell-Stock-with-Transaction-Fee    
487.Max Consecutive Ones II   
376.Wiggle Subsequence    
只不过用两个状态变量就够了.


[Leetcode Link](https://leetcode.com/problems/student-attendance-record-ii)
$0
endsnippet

# ==> ./Dynamic_Programming/0552.Student-Attendance-Record-II/552.Student-Attendance-Record-II.cpp <==
snippet 0552.Student-Attendance-Record-II "0552.Student-Attendance-Record-II" b
class Solution {
public:
    int checkRecord(int n) 
    {
        vector<long>dp00(n+1,0);
        vector<long>dp01(n+1,0);
        vector<long>dp02(n+1,0);
        vector<long>dp10(n+1,0);
        vector<long>dp11(n+1,0);
        vector<long>dp12(n+1,0);
        
        dp00[0] = 1;
        long M = 1e9+7;
        
        for (int i=1; i<=n; i++)
        {
            dp00[i] = (dp00[i-1] + dp01[i-1] + dp02[i-1])%M;
            dp01[i] = dp00[i-1];
            dp02[i] = dp01[i-1];
            dp10[i] = (dp00[i-1] +  dp01[i-1] + dp02[i-1] + dp10[i-1] + dp11[i-1] + dp12[i-1])%M;
            dp11[i] = dp10[i-1];
            dp12[i] = dp11[i-1];
        }
        
        return (dp00[n]+dp01[n]+dp02[n]+dp10[n]+dp11[n]+dp12[n])%M ;
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/0576.Out-of-Boundary-Paths/Readme.md <==
snippet 0576.Out-of-Boundary-Paths "0576.Out-of-Boundary-Paths" b
### 576.Out-of-Boundary-Paths

本题最简洁的解法是考虑从边界到出发点的逆向移动。令边界上的格子的初始值为1（起点），考虑经过N步之后，到达(i,j)的方案有多少。在不考虑边界情况下，容易知道
```
dp[i,j,k] = dp[i-1,j,k-1] +  dp[i+1,j,k-1] + dp[i,j-1,k-1] + dp[i,j+1,k-1];
```
需要注意的是，对于那些处在边界的格子，必须在每一步都赋值为1，即源源不断地要作为起始点。
```
dp[i,j,k] = 1;
```
输出结果就是dp[i0,j0,N]。当然，不必开那么多二维数组，只要两个就行了。


[Leetcode Link](https://leetcode.com/problems/out-of-boundary-paths)
$0
endsnippet

# ==> ./Dynamic_Programming/0576.Out-of-Boundary-Paths/576.Out-of-Boundary-Paths.cpp <==
snippet 0576.Out-of-Boundary-Paths "0576.Out-of-Boundary-Paths" b
class Solution {
public:
    int findPaths(int m, int n, int N, int i, int j) 
    {
        auto p = vector<vector<int>>(m,vector<int>(n,0));
        auto q =p;
        int M=pow(10,9)+7;
        
        for (int k=0; k<N; k++)
        {
            for (int i=0; i<m; i++)
             for (int j=0; j<n; j++)
             {
                 long n1= (i==0)?1:q[i-1][j];
                 long n2= (i==m-1)?1:q[i+1][j];
                 long n3= (j==0)?1:q[i][j-1];
                 long n4= (j==n-1)?1:q[i][j+1];
                 p[i][j]=(n1+n2+n3+n4)%M;
             }
            q=p;
        }
        return p[i][j];
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/0583.Delete-Operation-for-Two-Strings/Readme.md <==
snippet 0583.Delete-Operation-for-Two-Strings "0583.Delete-Operation-for-Two-Strings" b
### 583.Delete-Operation-for-Two-Strings

#### 解法1
此题可以转化为LCS(longest common sequence)，典型的DP算法的应用。

```dp[i][j]```表示word1的前i个元素、word2的前j个元素的最长共同元素数目。

递推关系：
```
dp[i][j] =   dp[i-1][j-1]+1              (if word1[i]==word2[j]) 
             max(dp[i-1][j],dp[i][j-1])   (if word1[i]!=word2[j])
```
最后的结果应该是 ```m+n-dp[m][n]*2```


#### 解法2

也可以直接根据题目的意思来设计状态变量。```dp[i][j]```就表示the minimum number of steps required to make ```word1[1:i]``` and ```word2[1:j]``` the same.

状态转移方程和上面很类似：
```
dp[i][j] =   dp[i-1][j-1]                   (if word1[i]==word2[j]) 
             min(dp[i-1][j],dp[i][j-1])+1   (if word1[i]!=word2[j])
```
最后的结果就是 ```dp[m][n]```

需要注意设置边界条件```dp[0][j]```和```dp[i][0]```.


[Leetcode Link](https://leetcode.com/problems/delete-operation-for-two-strings)
$0
endsnippet

# ==> ./Dynamic_Programming/0583.Delete-Operation-for-Two-Strings/583.Delete-Operation-for-Two-Strings.cpp <==
snippet 0583.Delete-Operation-for-Two-Strings "0583.Delete-Operation-for-Two-Strings" b
class Solution {
public:
    int minDistance(string word1, string word2) 
    {
        int n1=word1.size();
        int n2=word2.size();
        auto dp=vector<vector<int>>(n1+1,vector<int>(n2+1,0));
        word1.insert(word1.begin(),'0');
        word2.insert(word2.begin(),'0');
        
        for (int i=1; i<=n1; i++)
         for (int j=1; j<=n2; j++)
         {
             if (word1[i]==word2[j])
                 dp[i][j]=dp[i-1][j-1]+1;
             else
                 dp[i][j]=max(dp[i-1][j],dp[i][j-1]);
         }
        
        return n1+n2-dp[n1][n2]*2;
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/0583.Delete-Operation-for-Two-Strings/583.Delete-Operation-for-Two-Strings_v2.cpp <==
snippet 0583.Delete-Operation-for-Two-Strings "0583.Delete-Operation-for-Two-Strings" b
class Solution {
public:
    int minDistance(string word1, string word2) 
    {
        int m = word1.size();
        int n = word2.size();
        auto dp = vector<vector<int>>(m+1,vector<int>(n+1,INT_MAX/2));
        word1.insert(word1.begin(),'#');
        word2.insert(word2.begin(),'#');
        
        for (int i=0; i<=m; i++)
            dp[i][0]=i;
        for (int j=0; j<=n; j++)
            dp[0][j]=j;        
        
        for (int i=1; i<=m; i++)
            for (int j=1; j<=n; j++)
            {
                if (word1[i]==word2[j])
                    dp[i][j] = min(dp[i][j], dp[i-1][j-1]);
                dp[i][j] = min(dp[i][j], dp[i-1][j]+1);
                dp[i][j] = min(dp[i][j], dp[i][j-1]+1);
            }
        
        return dp[m][n];

    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/0600.Non-negative-Integers-without-Consecutive-Ones/Readme.md <==
snippet 0600.Non-negative-Integers-without-Consecutive-Ones "0600.Non-negative-Integers-without-Consecutive-Ones" b
### 600.Non-negative-Integers-without-Consecutive-Ones

先考虑一个简单的问题：对于一个n位的01字符串，没有连续1的排列有多少？这是一个简单的DP问题。考虑dp[i]时，如果第i位是0，则1～i-1位可以自由排列为任何无连续1的组合，即dp[i-1]。如果第i位是1，则第i-1位只能是0，那么从1～i-2位可以自由排列为任何无连续1的组合，即dp[i-2].所以动态转移方程是：
```
dp[i]=dp[i-1]+dp[i-2]
```
注意初始条件，dp[0]=1, dp[1]=2; dp[0]是起辅助作用。

那么对于本题而言，我们先将num转化为二进制的字符串。

考虑第i位是1的情况： \***1xxxxxxxxxx，那么如果保留所有的\*且第i位取0，那么第i+1～n位可以自由排列为任何无连续1的组合，都是小于\***1xxxxxxxxxx的，即有dp[n-i]个; 如果第i位取1，那么就要继续查看后面的数组才能保证不大于num。

比如，假设往后看到 \***101xxxxxxxx， 即第i+2位是1（隔了一个0），那么可以重复之前的分析：保留所有\*，将第i+2位取0，则有dp[n-i-2]种排列，它们满足小于\***101xxxxxxxx，且无连续1的条件；如果将第i+2位取1，则需要继续往后查看。

但是，如果看到第i+1位出现了这种情况：\***11xxxxxxxxx，即第i+1位和第i位一样都是1。注意到，第i+1位是不能取1的（否则连续两个1），所以第i+1位只能取0，这样则有dp[n-i-1]种组合符合要求。但特别注意，num在第i+1位之后的数字我们其实就不用查看了，因为第i+1位已经锁定为0了，这样的01组合一定小于等于num。此时就要退出循环。

注意一个细节：如果num从头到尾都没有任何连续的1出现，那么最后就要把result++，因为虽然一路都是把当前位的取值等同于digits[i]，但最后并没有包含num本身。


[Leetcode Link](https://leetcode.com/problems/non-negative-integers-without-consecutive-ones)
$0
endsnippet

# ==> ./Dynamic_Programming/0600.Non-negative-Integers-without-Consecutive-Ones/600.Non-negative-Integers-without-Consecutive-Ones.cpp <==
snippet 0600.Non-negative-Integers-without-Consecutive-Ones "0600.Non-negative-Integers-without-Consecutive-Ones" b
class Solution {
public:
    int findIntegers(int num) 
    {        
        if (num==0) return 0;
        if (num==1) return 2;
        
        vector<int>f(33);
        f[0]=1;
        f[1]=2;
        for (int i=2; i<32; i++)        
            f[i]=f[i-2]+f[i-1];        
        
        vector<int>digits(32,0);
        for (int i=0; i<32; i++)    
            digits[i]=((num>>i)&1);   
        
        int count=0;
        for (int i=31; i>=0; i--)
        {
            if (digits[i]==0) continue;
            
            // 第i位取0
            count+=f[i-1+1];  
            
            // 第i位取1
            if (i-1>=0 && digits[i-1]==1)
            {
                count+=f[i-2+1];
                return count;
            }
        }
        
        count++;
        
        return count;
        
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/0629.K-Inverse-Pairs-Array/Readme.md <==
snippet 0629.K-Inverse-Pairs-Array "0629.K-Inverse-Pairs-Array" b
### 629.K-Inverse-Pairs-Array

有一定难度的DP题。

约定dp[n][k]表示从1~n的任意排列中inverse pair数目为k的组合数目。
```
For example, if we have some permutation of 1...4   
5 x x x x creates 4 new inverse pairs   
x 5 x x x creates 3 new inverse pairs   
...   
x x x x 5 creates 0 new inverse pairs   
```
如上的例子：    
假设xxxx代表dp[4][j]的所有排列可能。易知xxxx5并不会增加inverse pair的数目，所以dp[4][j]是dp[5][j]的一部分。   
假设xxxx代表dp[4][j-1]的所有排列可能。易知xxx5x增加了一个inverse pair的数目，所以dp[4][j-1]是dp[5][j]的一部分。   
假设xxxx代表dp[4][j-2]的所有排列可能。易知xx5xx增加了两个inverse pair的数目，所以dp[4][j-2]是dp[5][j]的一部分。   
假设xxxx代表dp[4][j-3]的所有排列可能。易知x5xxx增加了三个inverse pair的数目，所以dp[4][j-3]是dp[5][j]的一部分。   
假设xxxx代表dp[4][j-4]的所有排列可能。易知5xxxx增加了四个inverse pair的数目，所以dp[4][j-4]是dp[5][j]的一部分。   

所以，可以得到递推关系是：
```cpp
dp[i][j] = dp[i-1][j]+dp[i-1][j-1]+dp[i-1][j-2]+...+dp[i-1][j-i+1]
```
直接用上述的递推关系仍然会超时。这个递推关系还可以进一步简化。考虑
```cpp
dp[i][j-1] = dp[i-1][j-1]+dp[i-1][j-2]+...+dp[i-1][j-i]
```
将dp[i][j-1]带入dp[i][j]，可以得到
```cpp
dp[i][j] = dp[i-1][j]+dp[i][j-1]-dp[i-1][j-i]
```
需要注意的是，上述关系式仅当j>=i时才有dp[i-1][j-i]。否则，最后一项省略。

另外，dp的边界条件是d[i][0]=1，表示没有任何inverse pair的排列只有一种，那就是从小到大顺序排列。


[Leetcode Link](https://leetcode.com/problems/k-inverse-pairs-array)
$0
endsnippet

# ==> ./Dynamic_Programming/0629.K-Inverse-Pairs-Array/629.K Inverse Pairs Array.cpp <==
snippet 0629.K-Inverse-Pairs-Array "0629.K-Inverse-Pairs-Array" b
class Solution {
public:
    int kInversePairs(int n, int k) 
    {
        auto dp=vector<vector<int>>(n+1,vector<int>(k+1,0));
        
        const int mod = pow(10, 9) + 7;
        
        for (int i=1; i<=n; i++)
            dp[i][0]=1;
        
        for (int i=2; i<=n; i++)
         for (int j=1; j<=k; j++)
         {
            if (j>=i)
                dp[i][j]=(dp[i-1][j]+dp[i][j-1]-dp[i-1][j-i])%mod;
            else
                dp[i][j]=(dp[i-1][j]+dp[i][j-1])%mod;
                
            if (dp[i][j]<0)
                dp[i][j]+=mod;
         }
        
        return dp[n][k];
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/0634.Find-the-Derangement-of-An-Array/Readme.md <==
snippet 0634.Find-the-Derangement-of-An-Array "0634.Find-the-Derangement-of-An-Array" b
### 634.Find the Derangement-of-An-Array

此题的递归关系的分析很有难度。可以借助人来选帽子的情景这么分析：

考虑dp[n]。假设第一个人选择了第i顶帽子（除去第1顶不能选，他共有n-1种选择）。OK，接下来如何呢？此时对于第i个人（注意这个i不是泛指，是和第一个人的选择对应的），此时有两种选择：

1. 第i个人选择了第1顶帽子。则剩下的人的编号和帽子的编号
```
人:     2,3,4,...,i-1,i+1,...,n
帽子:   2,3,4,...,i-1,i+1,...,n
```
要使得每个人都不拿与自己编号相同的帽子，这就相当于dp[n-2]的子问题。

2. 第i个人不选择第1顶帽子。则剩下的人（包括第i个人，因为他还没确定）编号和剩下的帽子编号如下。特别注意，我们把第i个人和第1顶帽子写成了一对：
```
人:     2,3,4,...,i-1, [i], i+1,...,n
帽子:   2,3,4,...,i-1, [1], i+1,...,n
```
要使得每个人不拿与自己编号相同的帽子（也意味着第i个人不能拿第一顶帽子），这就转化为了dp[n-1]的问题。

综上，只要第一个人选择了第i顶帽子，那么接下来就有```dp[n-1]+dp[n-2]```种方案。

考虑到第一个人选择的第i顶帽子，其实共有n-1种选择，每种选择的后续分析都是一模一样的，故总的递推关系是：
```
dp[n] = (n-1)*(dp[n-1]+dp[n-2])
```


[Leetcode Link](https://leetcode.com/problems/find-the-derangement-of-an-array)
$0
endsnippet

# ==> ./Dynamic_Programming/0634.Find-the-Derangement-of-An-Array/634.Find-the-Derangement-of-An-Array.cpp <==
snippet 0634.Find-the-Derangement-of-An-Array "0634.Find-the-Derangement-of-An-Array" b
class Solution {
public:
    int findDerangement(int n) 
    {
        if (n==1) return 0;
        if (n==2) return 1;
        
        long long a=0;
        long long b=1;
        long long c;
        long long m=pow(10,9)+7;
        
        for (int k=3; k<=n; k++)
        {
            c = (a+b)%m*(k-1)%m;
            a = b;
            b = c;
        }
        
        return c;
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/0639.Decode-Ways-II/Readme.md <==
snippet 0639.Decode-Ways-II "0639.Decode-Ways-II" b
### 639.Decode-Ways-II

此题是和91.Decode-Ways类似的DP做法，但分情况讨论的类别更加复杂。

#### 情况I：如果s[i]是数字，分别考虑单位译码和双位译码（和前一个字符组合）。
1. 单位译码，dp[i] = dp[i-1]\*1，

2. 双位译码，得考虑前面是否是数字。
```cpp
                if (isdigit(s[i-1]))  // 如果前面也是数字，查看最后两位组合的数字是否合法
                {
                    int num = (s[i-1]-'0')*10+(s[i]-'0');
                    if (num>=10 && num<=26)
                        dp[i]+=dp[i-2];
                }
                else   // 如果是通配符，则需要讨论s[i]本身
                {
                    if (s[i]<='6') dp[i] += dp[i-2]*2;  // 类似*5，其中通配符可以代表1或者2
                    else dp[i] += dp[i-2];              // 类似*9，其中通配符只能代表12
                }   
```
#### 情况II：如果s[i]是通配符，同样分别考虑单位译码和双位译码（和前一个字符组合）。
1. 单位译码，dp[i] = dp[i-1]\*9，最后一位可以是1~9.

2. 双位译码，同样得考虑前面是否是数字。
```cpp
                if (s[i-1]=='1') dp[i]+=dp[i-2]*9;        // 1*
                else if (s[i-1]=='2') dp[i]+=dp[i-2]*6;   // 2*
                else if (s[i-1]=='*') dp[i]+=dp[i-2]*15;  // **，注意通配符不能代表零
```

$0
endsnippet

# ==> ./Dynamic_Programming/0639.Decode-Ways-II/639.Decode-Ways-II.cpp <==
snippet 0639.Decode-Ways-II "0639.Decode-Ways-II" b
class Solution {
public:
    int numDecodings(string s) 
    {
        int n = s.size();
        s = "#"+s;
        vector<long>dp(n+1,0);
        long M = 1e9+7;

        dp[0] = 1;
        if (s[1] == '*') dp[1] = 9;
        else if (s[1] == '0') dp[1] = 0;
        else dp[1] = 1;

        for (int i=2; i<=n; i++)
        {
            if (isdigit(s[i]))
            {
                dp[i] += s[i]=='0' ? 0:dp[i-1];
                if (isdigit(s[i-1]))
                {
                    int num = (s[i-1]-'0')*10+(s[i]-'0');
                    if (num>=10 && num<=26)
                        dp[i]+=dp[i-2];
                }
                else
                {
                    if (s[i]<='6') dp[i] += dp[i-2]*2;
                    else dp[i] += dp[i-2];
                }                
            }
            else
            {
                dp[i] += dp[i-1]*9;
                if (s[i-1]=='1') dp[i]+=dp[i-2]*9;
                else if (s[i-1]=='2') dp[i]+=dp[i-2]*6;
                else if (s[i-1]=='*') dp[i]+=dp[i-2]*15;
            }
            dp[i]%=M;
        }
        return dp[n];
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/0644.Maximum-Average-Subarray-II/Readme.md <==
snippet 0644.Maximum-Average-Subarray-II "0644.Maximum-Average-Subarray-II" b
### 644.Maximum-Average-Subarray-II

#### 解法1
首先最基本o(N^2)的思路要搞清楚。设置两层循环，第一层控制subarray的尾元素位置，第二层控制subarray的首元素位置
```cpp
for (int i=k; i<nums.size(); i++)
 for (int j=0; j<=i-k+1; j++)
 {
    考察 nums[j]~nums[i]这个subarray的平均值，更新全局最大。
 }
```

可见第二重循环有点大，把所有大于等于K程度的subarray都遍历了一遍。能否利用之前的信息呢？比如，若知道了nums[i-1]的最优解，对于解nums[i]的最优解有什么帮助呢？这种思想很像是DP了。

我们考虑如果已经找到了nums[i-1]的最优解：即以nums[i-1]为尾元素、长度为len的subarray，是所有这种这种subarray里均值最大的情况。这说明什么？说明处于len长度之前的那些元素是拖后腿的！它们会拉低以nums[i-1]为尾元素的subarray的均值，同样也会拉低以nums[i]为尾元素的subarray的均值。所以说，第二重循环我么不需要从0开始找。根据nums[i-1]最优解对应的subarray队首开始找就行了。
```cpp
for (int i=k; i<nums.size(); i++)
{
  for (int j=i-dp[i-1]; j<=i-k+1; j++)
  {
    考察 nums[j]~nums[i]这个subarray的平均值，更新全局最大。
  }
  dp[i] = ...
}
```

#### 解法2
上述的解法在lintcode中仍然会超时。下面介绍一个非常巧妙的二分搜索法。

显然二分搜索的上限就是nums里的最大值，下限就是nums里的最小值。我们每次通过low和high确定一个mid，查找nums里是否存在一个子数组是的其平均值大于mid。如果有，那么我们就调高下限至mid；如果没有，我们就降低上限至mid

但是我们如何知道是否存在一个子数组，其平均值大于mid呢？如果我们将这个数组整体都减去mid，那么任务就等价于找到一个平均值大于零的子数组，也就是是说，找到一个和为正数的子数组。

如何确认一个数组里有一段子数组的和为正数呢？我们只要遍历一遍前缀和，发现curSum[i]>preMin即说明存在。这里的preMin就是在i之前的最小的前缀和。可见只要o(n)的搜索就可以完成判断。总体的时间长度就是o(NlogK)，其中K是nums最大最小值之差。


[Leetcode Link](https://leetcode.com/problems/maximum-average-subarray-ii)
$0
endsnippet

# ==> ./Dynamic_Programming/0644.Maximum-Average-Subarray-II/644.Maximum-Average-Subarray-II.cpp <==
snippet 0644.Maximum-Average-Subarray-II "0644.Maximum-Average-Subarray-II" b
class Solution {
public:
    double findMaxAverage(vector<int>& nums, int k) 
    {
        
        vector<int>cumSum(nums.size()+1);
        cumSum[0]=0;
        for (int i=1; i<=nums.size(); i++)
            cumSum[i]=cumSum[i-1]+nums[i-1];

        vector<int>dp(nums.size()+1);
        dp[k]=1;               
        double result=(cumSum[k]-cumSum[0])*1.0/k;
        
        for (int i=k+1; i<=nums.size(); i++)
        {
            double maxAvg=INT_MIN;
            
            for (int j=dp[i-1]; j<=i-k+1; j++)
            {
                double avg= (cumSum[i]-cumSum[j-1])*1.0/(i-j+1);
                if (avg>maxAvg)
                {
                    maxAvg=avg;
                    dp[i]=j;
                }
                if (avg>result)
                    result=avg;
                
                // cout<<avg<<endl;
            }
        }
        
        return result;
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/0644.Maximum-Average-Subarray-II/644.Maximum-Average-Subarray-II_v2.cpp <==
snippet 0644.Maximum-Average-Subarray-II "0644.Maximum-Average-Subarray-II" b
class Solution {
public:
    double findMaxAverage(vector<int>& nums, int k) 
    {
        double low = INT_MAX, high = INT_MIN;
        for (int i:nums)
        {
            low = min((int)low,i);
            high = max((int)high,i);
        }
    
        while (high-low>1e-6)
        {
            double mid = (high-low)/2+low;
            
            if (check(nums,mid,k))
                low = mid;
            else
                high = mid;            
        }
        
        return high;
    }
    
    bool check(vector<int>&nums, double avg, int k)
    {
        int N = nums.size();
        vector<double> prefixSum(N+1,0);
        
        for (int i=1; i<k; i++)
            prefixSum[i] = prefixSum[i-1]+nums[i-1]-avg;

        double preMin = 0;
        
        for (int i=k; i<=N; i++)
        {
            prefixSum[i] = prefixSum[i-1]+nums[i-1]-avg;
            
            if(prefixSum[i] > preMin) 
                return true;
            preMin = min(preMin, prefixSum[i-k+1]);
        }
        return false;
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/0650.2-Keys-Keyboard/Readme.md <==
snippet 0650.2-Keys-Keyboard "0650.2-Keys-Keyboard" b
### 650.2-Keys-Keyboard

本题从题意上倾向于DP的解法。设计状态数组dp[n]表示恰好得到n个A的最小操作数。

我们思考dp[n]怎么得到。考虑到只有copy和paste两种模式，必然要求在得到n个A之前，纸面上必然是：有n/2个A，然后粘贴复制翻一番；或者有n/3个A，然后粘贴复制翻两番；或者依次类推，直面上有n/j个A，然后粘贴复制翻倍j-1次。所以这就得到了dp[n]的更新表达式。dp[n] = min(dp[n/j]+j) for j=2,3,...,n.

当然，如果采用贪心的策略可以优化上面的解。例如，我们要得到6个A，直觉上通过3个A翻一番的方法，要比通过2个A翻两番的方法更高效，更是会比通过1个A拷贝粘贴翻五番更高效。所以我们将j从小往大尝试，一旦遇到n/j整除的情况，就不再考虑其他j的可能性，取那样的j就能得到计算dp[n]的最优方案。


[Leetcode Link](https://leetcode.com/problems/2-keys-keyboard)
$0
endsnippet

# ==> ./Dynamic_Programming/0650.2-Keys-Keyboard/650.2-Keys-Keyboard.cpp <==
snippet 0650.2-Keys-Keyboard "0650.2-Keys-Keyboard" b
class Solution {
public:
    int minSteps(int n) 
    {
        int s=0;
        for (int i=2; i<=n; i++)
        {
            while (n%i==0)
            {
                s+=i;
                n/=i;
            }
        }
        return s;
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/0650.2-Keys-Keyboard/650.2-Keys-Keyboard_dp.cpp <==
snippet 0650.2-Keys-Keyboard "0650.2-Keys-Keyboard" b
class Solution {
public:
    int minSteps(int n) 
    {
        vector<int>dp(n+1,INT_MAX);  
        dp[1] = 0;
        for (int i=2; i<=n; i++)
        {
            for (int j=2; j<=i; j++)
            {
                if (i%j!=0) continue;
                int k = i/j;
                dp[i] = min(dp[i], dp[k]+1+j-1);
                break;
            }
        }
        return dp[n];
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/0651.4-Keys-Keyboard/Readme.md <==
snippet 0651.4-Keys-Keyboard "0651.4-Keys-Keyboard" b
### 651.4-Keys-Keyboard

这题看上去和```650. 2 Keys Keyboard```有些类似，但是状态变量dp的定义还是明显不同。这里根据题意，就定义dp[i]表示为i次操作能产生的字符个数。

我们考虑一下第i次操作可能是什么：

1.最后一次操作是A。那么显然```dp[i] = dp[i-1]+1```

2.最后一次操作是ctrl-V。那么我们会想这个ctrl-V连续操作了几次？显然最多可以连续操作i-2次。再多就不行了，因为我们至少要预留一个ctrl+A, 一个ctrl+C，然后才能做ctrl-V的操作。所以我们可以遍历```j=1,...,i-2```，其中j就表示了最后的ctrl-V连续做了多少次。这样的话```dp[i] = dp[i-j-2]\*(j+1)```

3.最后一步操作是ctrl-A或者ctrl-C，这些都是不可能的，无法使得dp[i]最大化。

所以最终的答案就是1和2两种情况中（第2种情况还需要一层循环）最大的值。


[Leetcode Link](https://leetcode.com/problems/4-keys-keyboard)
$0
endsnippet

# ==> ./Dynamic_Programming/0651.4-Keys-Keyboard/651.4-Keys-Keyboard.cpp <==
snippet 0651.4-Keys-Keyboard "0651.4-Keys-Keyboard" b
class Solution {
public:
    int maxA(int N) 
    {
        if (N==1) return 1;
        
        vector<int>dp(N+1,0);
        dp[0] = 0;
        dp[1] = 1;
        dp[2] = 2;
        
        for (int i=3; i<=N; i++)
        {            
            dp[i] = dp[i-1]+1;
            for (int j=0; j<=i-2; j++)
            {                                
                dp[i] = max(dp[i], dp[i-j-2]*(j+1));
            }
        }
        return dp[N];        
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/0656.Coin-Path/Readme.md <==
snippet 0656.Coin-Path "0656.Coin-Path" b
### 656.Coin-Path

如果仅是输出最优路径，那么就是一道简单的DP题。本题的特殊性在于要求 the lexicographically smallest path

如果从正向考虑，考察dp[i]时，必须考察从 i-B 到 i-1 之间的元素，如果有若干并列的最小权重路径，该如何取舍呢？比如dp[x]和dp[y]都符合要求，且x<y，那么选择x吗？显然不行，因为从0行进到x的路径，可能就比从0行进到y的路径，在字典序上更大。反之，选择y也没有道理。

怎么解决呢？最巧妙的方法是，从反向考虑，考察从N-1行进到0的最优路径。

比如，考察dp[i]时，必须考察从 i+1 到 i+B 之间的元素，如果有若干并列的最小权重路径，该如何取舍呢？比如dp[x]和dp[y]都符合要求，且x<y，那么我们就要选择x。因为从0到i到x到N-1的路径，肯定要比从0到i到y到N-1的路径在字典序上更小。


[Leetcode Link](https://leetcode.com/problems/coin-path)
$0
endsnippet

# ==> ./Dynamic_Programming/0656.Coin-Path/656.Coin-Path.cpp <==
snippet 0656.Coin-Path "0656.Coin-Path" b
class Solution {
public:
    vector<int> cheapestJump(vector<int>& A, int B) 
    {
        int n=A.size();
        vector<int>dp(n,INT_MAX);
        vector<int>path(n,-1);
        dp[n-1]=A[n-1];
        
        for (int i=n-1; i>=0; i--)
        {
            for (int k=1; k<=B; k++)
            {
                if (i+k>=A.size())
                    continue;
                if (A[i+k]==-1)
                    continue;
                
                if (dp[i+k]+A[i]<dp[i])
                {
                    dp[i]=dp[i+k]+A[i];
                    path[i]=i+k;
                }
            }
        }
        
        vector<int>result;
        int i=0;
        while (i<A.size())
        {
            result.push_back(i+1);   
            
            if (i==A.size()-1)
                break;
            
            if (path[i]==-1) 
                return {};
            else
                i=path[i];  
        }
                
        return result;
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/0664.Strange-Printer/Readme.md <==
snippet 0664.Strange-Printer "0664.Strange-Printer" b
### 664.Strange-Printer

我们查看这样一个例子，考虑如何独立地打印出区间[i:j]（即不受区间左边界外的字符影响）。我们记最少的打印操作是dp[i][j].
```
a X X X X a X X a X X X a X X X
i         x     y       z     j
```
首先，第一个字符'a'是无法靠打印其他字符所顺带得到，所以必须主动打印。那么我们显然会思考这样一个问题，我们可以顺带多打印一些'a'，岂不是能够方便后续对'a'的打印？想到这里，是不是觉得无脑把整个[i:j]区间都打印成'a'最省事？理论上是，但对于我们拆分问题没有帮助。假设最优解里，位置z上的'a'并不是和位置i上的'a'一起打印出来，那么上述的将[i:j]都打印成'a'的操作就没有意义，因为它并不能帮助省下位置z的打印操作。除非我们限定：位置z上的'a'是和位置i一起打印出来的，那么我们就知道第一步操作必须将区间[i:z]都打印成'a'。那么之后问题如何转化呢？因为位置z不能再被打印，所以整个区间被割裂成了两部分，即[i:z-1]和[z+1:j]. 首先观察后面的[z+1:j]，显然它不受自己区间左边界外的字符影响（因为打印了位置z后，不允许其他字符的打印范围可以跨越z），所以最少打印操作就是dp[z+1][j]. 再观察前面的[i:z-1]，它显然也不受自己区间左边界外的字符影响，所以最少打印操作是dp[i][z-1]. 

特别注意，这种情况下，我们记```dp[i][j] = dp[i][z-1] + dp[z+1][j]```. 那么位置z上的打印操作哪里去了？这是因为我们打印[i:z-1]时必然会打印第一个'a'，顺手将其打印到位置z即可。

由此我们总结，将dp[i][j]分解的关键，就在于考察首字符“有意义的”打印范围可以持续到哪里，所谓的有意义，其实就是说打印范围的最后一个'a'字符要限定和首字符一起打印出来后就不会再被覆盖。如果未来还会被覆盖，那么首字符的打印范围就没有必要延伸到哪里。在上面的例子里，这样的打印范围其实只有四种选择，就是从i到i，从i到x，从i到y，从i到z，分别对应了“最后一个与首字符一起打印的位置”是i, x，y和z。这四种情况是互斥且互补的。所以我们可以将dp[i][j]的求解，就转化为在这四类后续中取最优解：
```cpp
dp[i][j] = min { dp[i][k-1] + dp[k+1][j] }  for all i<=k<=j && s[k]==s[i]
```
特别地，当k==i时，上述的表达式有些不方便，可以单独分开来写一下：
```cpp
dp[i][j] = 1 + dp[i+1][j];   
dp[i][j] = min { dp[i][k-1] + dp[k+1][j] } // for i<k<j && s[k]==s[i]
```

如果有人思考地比较深入，或许会有这样的疑问。在第一步拆分```dp[i][j] = dp[i][z-1] + dp[z+1][j]```的情况下，我们已经认定首字母的打印范围从i延伸到了z。但是我们在接下来计算dp[i][z-1]的时候，类似地，会讨论首字母的打印范围从i延伸到y的情况。这两个前提是否矛盾？其实不矛盾。我们在讨论dp[i][j]时，其实讨论的是在区间[i:j]内最后一个与首字符一起打印的位置。我们在讨论dp[i][z-1]时，其实讨论的是在区间[i:z-1]内最后一个与首字符一起打印的位置。对于不同的区间，最后一个与首字符一起打印的位置是可以不同的。事实上，真正的首字符打印范围，可以一直延伸到全局最后一个与首字符一起打印的那个位置。

最后，因为是典型的区间型DP，我们需要从小区间推导出大区间，所以两层循环的模板如下：
```cpp
          for (int len=2; len<=N; len++)
            for (int i=0; i<=N-len; i++)
            {
                int j = i+len-1;
                dp[i][j] = 1+dp[i+1][j];
                
                for (int k=i+1; k<=j; k++)
                {
                    if (s[k]==s[i])                    
                        dp[i][j] = min(dp[i][j], dp[i][k-1] + ((k+1>j)?0:dp[k+1][j]));
                }
            }      
```
初始条件是：
1. dp[i][j]==1 when i==j，即len的长度为1; 
2. dp[i][j]==0 when i>j. 注意这个是允许遇到的，比如上面的例子，如果区间[i:j]里面的s[j]==s[i]，于是k可以取到j，转移方程的dp[k+1][j]就会出现这种情况。


[Leetcode Link](https://leetcode.com/problems/strange-printer)

$0
endsnippet

# ==> ./Dynamic_Programming/0664.Strange-Printer/664.Strange-Printer.cpp <==
snippet 0664.Strange-Printer "0664.Strange-Printer" b
class Solution {
public:
    int strangePrinter(string s) 
    {        
        int N = s.size();
        if (N==0) return 0;
        
        auto dp = vector<vector<int>>(N,vector<int>(N));
        for (int i=0; i<N; i++)
            dp[i][i] = 1;
                
        for (int len=2; len<=N; len++)
            for (int i=0; i<=N-len; i++)
            {
                int j = i+len-1;
                dp[i][j] = 1+dp[i+1][j];
                
                for (int k=i+1; k<=j; k++)
                {
                    if (s[k]==s[i])
                    {
                        dp[i][j] = min(dp[i][j], dp[i][k-1] + ((k+1>j)?0:dp[k+1][j]));
                    }                        
                }    
                
            }        
        return dp[0][N-1];
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/0673.Number-of-Longest-Increasing-Subsequence/Readme.md <==
snippet 0673.Number-of-Longest-Increasing-Subsequence "0673.Number-of-Longest-Increasing-Subsequence" b
### 673.Number-of-Longest-Increasing-Subsequence

在传统的LIS的DP解法基础上，再设置一个表征LIS数目的数组。len[i]表示以i元素结尾的LIS的长度；num[i]表示以i元素结尾的LIS的数目。

递推关系是：

```len[i] = max (len[j]+1) for 0<=j<i && nums[j]<nums[i]```

```num[i] = sum (num[j]) for 0<=j<i && len[j]+1=len[i]```


[Leetcode Link](https://leetcode.com/problems/number-of-longest-increasing-subsequence)
$0
endsnippet

# ==> ./Dynamic_Programming/0673.Number-of-Longest-Increasing-Subsequence/673.Number-of-Longest-Increasing-Subsequence.cpp <==
snippet 0673.Number-of-Longest-Increasing-Subsequence "0673.Number-of-Longest-Increasing-Subsequence" b
class Solution {
public:
    int findNumberOfLIS(vector<int>& nums) 
    {
        int N=nums.size();
        vector<int>len(N,1);
        vector<int>num(N,1);
        
        for (int i=1; i<N; i++)
        {
            int maxLen=1;
            int maxNum=1;
            for (int j=0; j<i; j++)
            {
                if (nums[i]<=nums[j])
                    continue;
                    
                if (len[j]+1>maxLen)
                {
                    maxLen=len[j]+1;
                    maxNum=num[j];
                }
                else if (len[j]+1==maxLen)
                {
                    maxNum+=num[j];
                }
            }
            len[i]=maxLen;
            num[i]=maxNum;
        }
        
        int maxLen=1;
        int maxNum=0;
        for (int i=0; i<N; i++)
        {
            if (len[i]>maxLen)
            {
                maxLen=len[i];
                maxNum=num[i];
            }
            else if (len[i]==maxLen)
                maxNum+=num[i];
        }
        
        return maxNum;
    }
    
};

$0
endsnippet

# ==> ./Dynamic_Programming/0691.Stickers-to-Spell-Word/Readme.md <==
snippet 0691.Stickers-to-Spell-Word "0691.Stickers-to-Spell-Word" b
 ### 691.Stickers-to-Spell-Word
 
设置状态数组dp[i],dp的大小是 N = 2^n, 其中n是target的大小。怎么理解？将dp的索引i进行二进制拆解，i的每一个bit表示的是target对应位置的字符是否得到了满足。比如n=3时，dp数组的大小N=8，对应的状态有 000,001,010,011,100,101,110,111. 举个例子，i=3 (即011)表示target的末两位的字符得到了满足，但第一位的字符还没有得到满足。dp[i]表示在状态i下，需要的sticker的最少数目。

注意：这种状态的排列有一个非常好的性质。任何状态，只可能由位于其前面的状态转移得到，不可能从后面的状态转移得到。比如i=3(即 011)这个状态，只可能从i=0,1,2转移过来（通过使用某些合适的sticker）；再比如i=4(即100)这个状态，只可能从i=0转移过来。这种状态转移的性质，非常适合dp根据i从前往后的遍历。

所以，dp的大循环就是 ```for (state=0; state<(1<<n); state++)```. 对于该状态state，我们尝试每一个sticker[k]，计算状态i经过sticker[k]的帮助后得到的状态new_state（注意已经分析过new_state肯定是大于state的），那么dp[new_state]就可以得到更新```dp[new_state]=min(dp[new_state], dp[state]+1)```

所有的状态i都遍历过之后，答案的输出就是 dp[N-1]


[Leetcode Link](https://leetcode.com/problems/stickers-to-spell-word)

$0
endsnippet

# ==> ./Dynamic_Programming/0691.Stickers-to-Spell-Word/691.Stickers-to-Spell-Word.cpp <==
snippet 0691.Stickers-to-Spell-Word "0691.Stickers-to-Spell-Word" b
class Solution {
public:
    int minStickers(vector<string>& stickers, string target) 
    {
        int n = target.size();
        vector<int>dp(1<<n,INT_MAX);
        dp[0] = 0;

        for (int state=0; state<(1<<n); state++)
        {
            if (dp[state]==INT_MAX) continue;
            for (string str:stickers)
            {
                int new_state = findNextStatusByUsingStr(state,target,str);
                dp[new_state] = min(dp[new_state], dp[state]+1);
            }
        }
        return dp[(1<<n)-1]==INT_MAX?-1: dp[(1<<n)-1];
    }
    
    int findNextStatusByUsingStr(int status, string target, string s)
    {
        int n = target.size();
        for (auto ch:s)
        {
            // loop over each character in target, if equals to ch and not filled, then set as filled
            for (int k=0; k<n; k++)
            {
                if (((status>>k)&1)==0 && target[k]==ch)
                {
                    status = status+(1<<k);   
                    break;
                }              
            }
        }
        return status;
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/0712.Minimum-ASCII-Delete-Sum-for-Two-Strings/Readme.md <==
snippet 0712.Minimum-ASCII-Delete-Sum-for-Two-Strings "0712.Minimum-ASCII-Delete-Sum-for-Two-Strings" b
### 712.Minimum-ASCII-Delete-Sum-for-Two-Strings

对于此类有两个字符串、求最终使得彼此相同的操作的题目，一个典型的DP算法套路就是：设置状态数组dp[i][j]，代表s1前i个字符、s2前j个字符时的目标值。考虑dp[i][j]和dp[i-1][j-1]、dp[i-1][j]、dp[i][j-1]的递推关系。

当s1[i]==s2[j]时，说明不需要删减任何字符，即能由状态(i-1,j-1)到(i,j)，即 dp[i][j]==dp[i-1][j-1]。

当s1[i]!=s2[j]时，可以从状态(i-1,j)通过删减s1[i]到(i,j)，或者才从状态(i,j-1)通过删减s2[j]到(i,j)，所以 dp[i][j]= min (dp[i-1][j]+s1[i], dp[i][j-1]+s2[j])

另外需要特别注意边界条件dp[0][j]和dp[i][0]。

类似此题的还有：583	Delete Operation for Two Strings，97	Interleaving String，72	Edit Distance


[Leetcode Link](https://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings)
$0
endsnippet

# ==> ./Dynamic_Programming/0712.Minimum-ASCII-Delete-Sum-for-Two-Strings/712.Minimum-ASCII-Delete-Sum-for-Two-Strings.cpp <==
snippet 0712.Minimum-ASCII-Delete-Sum-for-Two-Strings "0712.Minimum-ASCII-Delete-Sum-for-Two-Strings" b
class Solution {
public:
    int minimumDeleteSum(string s1, string s2) 
    {
        int m=s1.size();
        int n=s2.size();
        auto dp=vector<vector<int>>(m+1,vector<int>(n+1,0));
        
        s1.insert(s1.begin(),'0');
        s2.insert(s2.begin(),'0');
        
        for (int i=1; i<=m; i++)
            dp[i][0]=dp[i-1][0]+s1[i];
        
        for (int j=1; j<=n; j++)
            dp[0][j]=dp[0][j-1]+s2[j];
        
        for (int i=1; i<=m; i++)
         for (int j=1; j<=n; j++)
         {
             if (s1[i]==s2[j])
                 dp[i][j]=dp[i-1][j-1];
             else
             {
                 dp[i][j] = min(dp[i-1][j]+s1[i],dp[i][j-1]+s2[j]);                 
             }
         }
        
        return dp[m][n];
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/0714.Best-Time-to-Buy-and-Sell-Stock-with-Transaction-Fee/Readme.md <==
snippet 0714.Best-Time-to-Buy-and-Sell-Stock-with-Transaction-Fee "0714.Best-Time-to-Buy-and-Sell-Stock-with-Transaction-Fee" b
### 714.Best-Time-to-Buy-and-Sell-Stock-with-Transaction-Fee

设置两个变量，sold表示此时没有存货的利润，hold表示此时有存货的利润。

遍历prices的所有元素，递推公式如下：
```cpp
sold = max(sold_tmp, hold_tmp+prices[i]-fee)  // sold的两种选择：保持原先的sold保持不变，或者将原先hold的存货卖掉
hold = max(hold_tmp, sold_tmp-prices[i])      // hold的两种选择：保持原先的hold保持不变，或者在原先sold状态下购入当前的股票
```

注意，初始状态是：
1. ```sold = 0```手头没有股票自然利润是0.
2. ```hold = -math.inf```初始状态下怎么可能hold任何股票呢？解决的技巧是将hold设置为最小值，那么下一步无论更新sold还是hold，都不会考虑之前的hold_tmp状态。

类似的题目还有：376.Wiggle-Subsequence，487.Max-Consecutive-Ones-II


[Leetcode Link](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee)
$0
endsnippet

# ==> ./Dynamic_Programming/0718.Maximum-Length-of-Repeated-Subarray/Readme.md <==
snippet 0718.Maximum-Length-of-Repeated-Subarray "0718.Maximum-Length-of-Repeated-Subarray" b
### 718.Maximum-Length-of-Repeated-Subarray

本题的本质就是Longest Common Subarray，和Longest Common Subsequence属于同一类的题目，双序列DP是最常规的解法。本题的状态转移方程更直观。

根据双序列DP的套路，令dp[i][j]表示以i结尾的subarray和以j结尾的subarray相等的最大长度，则有：
```
dp[i][j] = dp[i-1][j-1]+1 if A[i]==B[j] else 0
```

$0
endsnippet

# ==> ./Dynamic_Programming/0718.Maximum-Length-of-Repeated-Subarray/718.Maximum-Length-of-Repeated-Subarray.cpp <==
snippet 0718.Maximum-Length-of-Repeated-Subarray "0718.Maximum-Length-of-Repeated-Subarray" b
class Solution {
public:
    int findLength(vector<int>& A, vector<int>& B) 
    {
        int m = A.size();
        int n = B.size();
        A.insert(A.begin(), 0);
        B.insert(B.begin(), 0);
        int dp[m+1][n+1];
        memset(dp, 0, sizeof(int)*(m+1)*(n+1));
        int ret = 0;

        for (int i=1; i<=m; i++)
            for (int j=1; j<=n; j++)
            {
                dp[i][j] = A[i]==B[j]? dp[i-1][j-1]+1 : 0;
                ret = max(ret, dp[i][j]);
            }
        return ret;
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/0730.Count-Different-Palindromic-Subsequences/Readme.md <==
snippet 0730.Count-Different-Palindromic-Subsequences "0730.Count-Different-Palindromic-Subsequences" b
###  730.Count-Different-Palindromic-Subsequences

我们定义dp[i][j]为区间[i,j]内的不同的回文序列的个数。那么怎么区分不同的回文序列呢？可以采用层层剥离的思想，也就是分别考虑回文序列的最外层配对是'a','b','c','d'的四种情况.按照这种思路去分类的话，不同类之间的回文序列肯定是不会有重复的。也就是说dp[i][j]，可以拆分为：[i,j]区间里以字符k为最外层配对的回文数的和，其中k分别为'a','b','c','d'.

dp[i][j]里以'a'为最外层配对的回文数怎么找呢？显然我们要把这个最外层配对找到，这是一定可以确定下来的。如果我们要找到i后面第一个为'a'的位置m，以及j前面第一个为'a'的位置n，并且m<n，显然就有递推的关系dp[i][j] += dp[m+1][n-1]，可以这么理解：拔掉了最外层的配对'a'，里面还有多少个回文数，就说明dp[i][j]有多少以'a'为最外层配对的回文数。同理我们可以找其他最外层配对的情况，也就是'b','c','d'。所以递推关系是：
```cpp
for (int k=0; k<4; k++)
{
  if (next[i][k]<prev[j][k])  //小于号保证了这个配对一定是成双的
    dp[i][j] += dp[next[i][k]+1][prev[j][k]-1];
 }
```
其中```next[i][k]```定义了i位置之后第一个为字符k的位置（可以是i本身），```prev[j][k]```定义了j位置之前第一个为字符k的位置（可以是j本身）。这两个next和prev数组可以预处理得到。

上面的递推关系还有一个疏漏。如果[i,j]区间内没有以字符k的配对，但是有单独的一个字符k存在。这种情况也需要加进dp[i][j]的统计中去。所以完整的递推关系：
```cpp
for (int k=0; k<4; k++)
{
  if (next[i][k]<prev[j][k])  //小于号保证了这个配对一定是成双的
    dp[i][j] += dp[next[i][k]+1][prev[j][k]-1];
  if (next[i][k]<=j)
    dp[i][j] += 1;
 }
```
以上的语句再加上最外层对于i,j的大循环，即是完整的代码。最终的答案是dp[0][N-1]。

本题其实也可以通过定义dp[i][j][k]三维状态数组来实现这个算法，最终输出是```sum{k=0,1,2,3} dp[0][N-1][k]```。但是空间上可能无法通过。


[Leetcode Link](https://leetcode.com/problems/count-different-palindromic-subsequences)
$0
endsnippet

# ==> ./Dynamic_Programming/0730.Count-Different-Palindromic-Subsequences/730.Count-Different-Palindromic-Subsequences.cpp <==
snippet 0730.Count-Different-Palindromic-Subsequences "0730.Count-Different-Palindromic-Subsequences" b
class Solution {
public:
    int countPalindromicSubsequences(string S) 
    {
        int N = S.size();
        auto dp = vector<vector<int>>(N,vector<int>(N,0));
        
        auto first = vector<vector<int>>(N,vector<int>(4,-1));
        auto last = vector<vector<int>>(N,vector<int>(4,-1));
        
        int MOD = 1e9+7;
        
        for (int len = 1; len<=N; len++)
            for (int i=0; i+len<=N; i++)
            {
                int j = i+len-1;
                
                if (first[i][S[j]-'a']==-1)
                    first[i][S[j]-'a'] = j;
                else
                    last[i][S[j]-'a'] = j;
                
                for (int k=0; k<4; k++)
                {
                    if (last[i][k]>=0)                    
                        dp[i][j]+=dp[first[i][k]+1][last[i][k]-1]+1;                    
                    if (first[i][k]>=0)
                        dp[i][j]+=1;                    
                    dp[i][j]%=MOD;
                }                
                
                //cout<<i<<" "<<j<<" "<<dp[i][j]<<endl;
            }
        
        return dp[0][N-1];
        
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/0730.Count-Different-Palindromic-Subsequences/730.Count-Different-Palindromic-Subsequences_v2.cpp <==
snippet 0730.Count-Different-Palindromic-Subsequences "0730.Count-Different-Palindromic-Subsequences" b
class Solution {
public:
    int countPalindromicSubsequences(string S) 
    {
        int M = 1e9+7;
        int N = S.size();
        auto next = vector<vector<int>>(N,vector<int>(4,N));
        auto prev = vector<vector<int>>(N,vector<int>(4,-1));        
        auto dp = vector<vector<int>>(N,vector<int>(N,0));  
        
        for (int k=0; k<4; k++)
        {
            int i = 0;
            for (int j=0; j<N; j++)
            {
                if (S[j]!='a'+k) continue;
                while (i<=j)
                {
                    next[i][k] = j;
                    i++;
                }
            }
        }
        
        for (int k=0; k<4; k++)
        {
            int i = N-1;
            for (int j=N-1; j>=0; j--)
            {
                if (S[j]!='a'+k) continue;
                while (i>=j)
                {
                    prev[i][k] = j;
                    i--;
                }
            }
        }
        
        for (int i=0; i<N; i++) dp[i][i]=1;
        
        for (int len = 2; len<=N; len++)
            for (int i=0; i<=N-len; i++)
            {
                int j = i+len-1;
                for (int k=0; k<4; k++)
                {
                    if (next[i][k]<prev[j][k])
                        dp[i][j]+=dp[next[i][k]+1][prev[j][k]-1]+1;
                    if (next[i][k]<=j)
                        dp[i][j]+=1;
                    dp[i][j] = dp[i][j]%M;                                        
                }
            }
        return dp[0][N-1];
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/0740.Delete-and-Earn/Readme.md <==
snippet 0740.Delete-and-Earn "0740.Delete-and-Earn" b
### 740.Delete-and-Earn

#### 解法1：

本题有一个特点，如果我们选择了数值k，那么所有值为k的元素都会被计入gain而不能再被访问。这就提示了我们其实不应该按照元素的index顺序遍历（否则可能会遇到很多次已经被处理过的数值），更方便的做法是应该按照元素的value顺序（比如说从小到大）来遍历。

假设我们处理完当前数值k，记目前位置的最大收益是dp[k]。注意这个dp[k]不能保证k被earn与否。可能k这个数被delete and earn了，那么意味着实际的收益应该是dp[k-2]+k;也有可能这个k并没有被delete and earn,那么它的收益完全就取决于dp[k-1]。最终我们会在这两个决策中挑更大的作为dp[k]。

于是动态转移方程就是
```cpp
dp[k] = max(dp[k-2]+gain[k], dp[k-1])
```
其中gain[k]表示对k这个数值进行delete and earn的收益，其中包括了数组中出现重复的k的情况。如果数组中没有k，那么显然gain[k]=0.

应为我们是按照数值的从小到大顺序遍历的，所以最终答案应该是dp[数组最大的value]。

#### 解法2：

此题也可以和198.House Robber做类比。如果你能看出来它的本质是“不能选取任何相邻的两个数”，那么可以用dual status的DP方法：用ｐ表示抢劫此家的价值，用ｑ表示不抢劫此家的价值．那么我们可以用上一家的(p,q)来更新下一家的(p',q')：
```cpp
p'= q + gain[k];
q'= max(p,q);
```


[Leetcode Link](https://leetcode.com/problems/delete-and-earn)
$0
endsnippet

# ==> ./Dynamic_Programming/0740.Delete-and-Earn/740.Delete-and-Earn.cpp <==
snippet 0740.Delete-and-Earn "0740.Delete-and-Earn" b
class Solution {
public:
    int deleteAndEarn(vector<int>& nums) 
    {
        vector<int>gain(10001,0);
        for (auto x: nums)
            gain[x] += x;

        vector<int>dp(10001,0);
        dp[1] = gain[1];

        for (int i=2; i<=10000; i++)
        {
            dp[i] = max(dp[i-2]+gain[i], dp[i-1]);
        }
        return dp[10000];
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/0740.Delete-and-Earn/740.Delete-and-Earn_v2.cpp <==
snippet 0740.Delete-and-Earn "0740.Delete-and-Earn" b
class Solution {
public:
    int deleteAndEarn(vector<int>& nums) 
    {
        vector<int>gain(1e5+1,0);
        for (int x:nums)
            gain[x]+=x;
            
        int p = 0;  // robbed the last one
        int q = 0;  // did not rob the last one
        for (int i=1; i<=1e5; i++)
        {
            int p_tmp = p;
            int q_tmp = q;
            p = q_tmp + gain[i];
            q = max(q_tmp,p_tmp);
        }
        
        return max(p,q);
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/0741.Cherry-Pickup/Readme.md <==
snippet 0741.Cherry-Pickup "0741.Cherry-Pickup" b
### 741.Cherry-Pickup

本题可以解读为，从左上角到右下角，找出两条可行的线路，使得两条线路采集到的cherry数量最多．如果两条线路有重复的部分，则只算一次．

如果只有一条线路，那很明显用ＤＰ算法，每一个点的状态仅仅取决于它左边和上边两个点，转移方程为```DP[i][j]＝max{DP[i-1][j],DP[i][j-1]}+grid[i][j]```．

那么对于两条线路，我们需要考虑两个点的状态，那么可以设置DP[i][j][x][y]表示的就是两条线路目前的两个位置(i,j),(x,y)．显然它的状态取决于这两个点分别的左边和上边的两个点．即四个之前的状态：
```DP[i][j][x][y]＝max{DP[i-1][j][x-1][y],DP[i][j-1][x-1][y],DP[i][j-1][x-1][y],DP[i][j-1][x][y-1]}```
此外还要加上当前的grid[i][j]和grid[x][y]．注意此时等考虑这两个点是否重合：
```
if (i==x && j==y)
  DP[i][j][x][y]+=grid[i][j]
else
  DP[i][j][x][y]+=grid[i][j]+grid[x][y]
```

事实上，ＤＰ数组不需要设置为４维．因为i+j=x+y，所以通过三重循环，第四维可以通过y=i+j-x得到．


[Leetcode Link](https://leetcode.com/problems/cherry-pickup)

$0
endsnippet

# ==> ./Dynamic_Programming/0741.Cherry-Pickup/741.Cherry-Pickup.cpp <==
snippet 0741.Cherry-Pickup "0741.Cherry-Pickup" b
class Solution {
public:
    int cherryPickup(vector<vector<int>>& grid) 
    {
        int N = grid.size();
        int dp[N+1][N+1][N+1];
        
        for (int i=0; i<=N; i++)
            for (int j=0; j<=N; j++)
                for (int x=0; x<=N; x++)
                    dp[i][j][x] = INT_MIN;
        
        for (int i=1; i<=N; i++)
            for (int j=1; j<=N; j++)
                for (int x=1; x<=N; x++)
                {
                    int y = i+j-x;
                    if (y<1||y>N) continue;
                    if (grid[i-1][j-1]==-1||grid[x-1][y-1]==-1) continue;
                    if (i==1&&j==1&&x==1)
                    {
                        dp[i][j][x] = grid[0][0];
                        continue;
                    }

                    dp[i][j][x] = max(dp[i][j][x], dp[i-1][j][x-1]);
                    dp[i][j][x] = max(dp[i][j][x], dp[i][j-1][x-1]);
                    dp[i][j][x] = max(dp[i][j][x], dp[i-1][j][x]);
                    dp[i][j][x] = max(dp[i][j][x], dp[i][j-1][x]);
                    
                    if (i==x && j==y)
                        dp[i][j][x] += grid[i-1][j-1];
                    else
                        dp[i][j][x] += grid[i-1][j-1] + grid[x-1][y-1];
                    
                }
        
        return max(0,dp[N][N][N]);
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/0801.Minimum-Swaps-To-Make-Sequences-Increasing/Readme.md <==
snippet 0801.Minimum-Swaps-To-Make-Sequences-Increasing "0801.Minimum-Swaps-To-Make-Sequences-Increasing" b
### 801.Minimum-Swaps-To-Make-Sequences-Increasing

对于第i轮的决策而言，是否交换A[i]和B[i]，完全取决于A[i-1]和B[i-1]是否交换以及它们所在的位置。显然这是第I类基本型的DP：第i轮的状态只与第i-1轮的状态有关，且每轮的“状态”只有两种：交换或者不交换。

我们定义changed[i]表示第i轮交换且满足递增性质的最少操作数，unchanged[i]表示第i轮不交换且仍满足递增性质的最少操作数。

我们更新unchanged[i]的时候，考虑第i-1轮是否交换这两种情况，并检验是否合法。也就说，如果第i-1轮不交换，第i轮不交换，那么需要检查是否```A[i-1]<A[i] && B[i-1]<B[i]```，是的话，说明可以更新```unchanged[i]=unchanged[i-1]```。如果第i-1轮交换，第i轮不交换，那么需要检查是否```B[i-1]<A[i] && A[i-1]<B[i]```，是的话，说明可以更新```unchanged[i]=changed[i-1]```。

同理可以更新changed[i].

最终的答案就是最后一轮里changed和unchanged中的最大值。

$0
endsnippet

# ==> ./Dynamic_Programming/0801.Minimum-Swaps-To-Make-Sequences-Increasing/801.Minimum-Swaps-To-Make-Sequences-Increasing.cpp <==
snippet 0801.Minimum-Swaps-To-Make-Sequences-Increasing "0801.Minimum-Swaps-To-Make-Sequences-Increasing" b
class Solution {
public:
    int minSwap(vector<int>& A, vector<int>& B) 
    {
        int changed = 1, unchanged = 0;
        for (int i=1; i<A.size(); i++)
        {
            int changed_prev = changed;
            int unchanged_prev = unchanged;

            unchanged = INT_MAX, changed = INT_MAX;
            if (A[i-1]<A[i] && B[i-1]<B[i])
                unchanged = min(unchanged, unchanged_prev);
            if (B[i-1]<A[i] && A[i-1]<B[i])
                unchanged = min(unchanged, changed_prev);

            if (A[i-1]<B[i] && B[i-1]<A[i])
                changed = min(changed, unchanged_prev+1);
            if (B[i-1]<B[i] && A[i-1]<A[i])
                changed = min(changed, changed_prev+1);            
        }
        return min(changed, unchanged);

    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/0805.Split-Array-With-Same-Average/Readme.md <==
snippet 0805.Split-Array-With-Same-Average "0805.Split-Array-With-Same-Average" b
### 805.Split-Array-With-Same-Average

#### 解法1: DFS
此题的第一个想法依然是搜索．也就是在这个集合里面，挑出一个真子集，使得该子集的平均值，等于targetAvg（也就是整个集合的平均数）。

这种搜索是要遍历每个元素的两种选择：是否放在这个子集中，最坏情况是需要把所有的分类情况都列举完全才能得到最后结果（比如要判定结论是false的话），那么时间复杂度就达到了o(2^N)级别，所以这是NP问题．对于NP问题的搜索解法，我们只能寄希望于高效的剪枝来减少搜索范围，但需要注意一般而言剪枝并不能从根本上改变时间复杂度．

我们将数组从小到大拍之后，能想到的这么几个优化剪枝的条件：

1. 如果当前已选择的子集元素的平均值太小，即使加上后面全部的元素也没法提升到targetAvg，可以提前退出。

2. 如果当前已选择的子集元素的平均值太大，已经超过了targetAvg，可以提前退出。

3. 如果当前idx开始有若干个连续的元素都是相等的：要么选择将这个元素加入子集中，然后递归处理下一个元素(idx+1)；要么选择不将这个元素加入子集中，然后机柜处理下一个不同的元素(A[i]!=A[idx])。

可惜结果仍然是TLE。

#### 解法2: DFS
我们考虑一个合法的真子集的元素个数是num，元素总和是sum，因为这个子集的平均数和整体的平均数相等，所以我们有
```
total/n = sum/num
```
转换一下
```
total * num = sum * n
```
可以发现{sum,num}是需要有制约关系的，而且不是任意的num都会有一个整数的sum对应。考虑到num最多也就是30个，所以这样的pair最多30个（事实上由于二者的整除关系，符合条件的配对肯定更少）。我们尝试遍历这些pair，将题目转化为：查看数组里是否能有一个真子集，元素个数是num，元素的总数是sum。

这看上去又是一个常规的DFS，而且也是o(2^n)的复杂度。DFS的过程中，我们遍历每一个元素A[idx]，有两种选择：不取它加入子集，于是递归处理下一个元素idx+1；取它加入子集，同时```num-=1```以及```sum-=A[idx]```，然后递归处理下一个元素。

搜索的截止条件有这么几个：
1. 当恰好num==0且sum==0的时候，返回true

2. 当num或者sum有任意一个先小于等于零的时候，返回false

3. idx已经处理到头了仍未满足条件，返回false.

解法1中的第三个剪枝条件也可以用上。事实上这个暴力搜索的代码跑得非常快。可能是因为上面条件2的触发概率很高。

#### 解法3: DP
大家都知道，DP就等于记忆化搜索。解法2给了我们一个提示，就是找寻一个真子集满足如下条件的sum和num配对即可：
```
total * num = sum * n  (1)
```
于是我们定义状态变量dp[sum][num]来表示一个布尔值：是否可能存在这样的一个子集使得它们的元素和是sum，个数是num。我们可以联想到背包问题：我们依次遍历当前的元素A[i]=a，如果dp[sum-a][num-1]存在，那么就说明dp[sum][num]存在。对于任何dp[sum][num]为真的sum和num，如果满足上面的关系式就可以返回true。

注意在背包问题中，这一轮的dp状态取决于的是上一轮的dp状态（也就是说对应的A[i]不同）。如果在本轮中dp[sum-a][num-1]已经被修改了，那么在更新dp[sum][num]的结果就会出现错误。解决方法是再开一个数组储存之前的状态```auto temp=dp```，或者是将sum和num都从大到小遍历。这样在同一轮里，更新dp[sum][num]的时候dp[sum-a][num-1]肯定还没有更新。

这样的时间复杂度是o(N\*N\*Sum).

#### 解法4: DP
上述的DP算法仍然不是很快，主要是这个二维DP的遍历有点麻烦。这里有一个非常优秀的解法，我们可以优化dp[sum][num]的储存。原先这个状态变量储存的只是一个bool值，有些浪费。现在我们定义dp[sum]表示一个二进制整数，其中从低到高第i位bit是1的话，就表示存在一个真子集，使得元素和为sum，元素个数是i。

也就是说，如果dp[sum]=b01010010，那么就等效于解法3中的dp[sum][1]=true,dp[sum][4]=true和dp[sum][6]=true，

算法的框架和解法3一样，也是一个背包问题。我们遍历所有的元素A[i]=a，此时考虑加入元素a之后，dp[sum]就取决于取决于dp[sum-a]。对于所有子集元素和是sum-a的方案，只要再加上一个元素a就可以实现子集元素和是sum。因此我们有这么一个表达式：
```
dp[sum] |= dp[sum-a]
```
我们在有了dp[sum]之后，就可以知道对应的有哪些num了，逐个判断一下那个num和sum满足表达式(1)，就可以返回true。更高效的方法根据sum和表达式(1)，直接求出对应的num（而且必须是整数），然后查看dp[sum]里面对应那一位bit是否为1.


[Leetcode Link](https://leetcode.com/problems/split-array-with-same-average)

$0
endsnippet

# ==> ./Dynamic_Programming/0805.Split-Array-With-Same-Average/805.Split-Array-With-Same-Average_DFS.cpp <==
snippet 0805.Split-Array-With-Same-Average "0805.Split-Array-With-Same-Average" b
class Solution {
    double avg;
public:
    bool splitArraySameAverage(vector<int>& A) 
    {
        sort(A.begin(),A.end());
        int sum = accumulate(A.begin(), A.end(), 0);
        int n = A.size();
        
        for (int cnt = 1; cnt <= n/2; cnt++)
        {
            if (sum*cnt%n!=0) continue;
            if (DFS(A,cnt,sum*cnt/n,0))
                return true;
        }
        
        return false;
    }
    
    bool DFS(vector<int>&A, int cnt, int total, int idx)
    {
        if (total==0 && cnt==0) return true;
        
        if (idx==A.size()) return false;
                       
        if (cnt==0 || total ==0) return false;
        
        if (DFS(A, cnt-1, total-A[idx], idx+1)) return true;
        
        int i = idx;
        while (i<A.size() && A[i]==A[idx])
            i++;        
        if (i<A.size() && DFS(A, cnt, total, i)) return true;       
        
        return false;
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/0805.Split-Array-With-Same-Average/805.Split-Array-With-Same-Average_DP1.cpp <==
snippet 0805.Split-Array-With-Same-Average "0805.Split-Array-With-Same-Average" b
class Solution {
public:
    bool splitArraySameAverage(vector<int>& A) 
    {
        int total = accumulate(A.begin(),A.end(),0);
        int n = A.size();
        if (n==1) return false;
        auto dp = vector<vector<int>>(n+1, vector<int>(total+1,0));
        dp[0][0] = 1;

        int curSum = 0;

        for (auto a: A)
        {
            curSum+=a;
            for (int num = n/2+1; num>=1; num--)
                for (int sum = curSum; sum>=a; sum--)
                {
                    if (dp[num-1][sum-a]==1)
                    {
                        dp[num][sum] = 1;
                        if (num!=n && total*num==sum*n)
                            return true;
                    }
                }
        }
        return false;        
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/0805.Split-Array-With-Same-Average/805.Split-Array-With-Same-Average_DP2.cpp <==
snippet 0805.Split-Array-With-Same-Average "0805.Split-Array-With-Same-Average" b
class Solution {
public:
    bool splitArraySameAverage(vector<int>& A) 
    {
        int n = A.size();
        if (n==1) return false;
        int total = accumulate(A.begin(),A.end(),0);        
        if (total==0) return true;
        
        auto dp = vector<int>(total+1,0);
        dp[0] = 1;

        int curSum = 0;

        for (auto a: A)
        {
            curSum+=a;
            for (int sum = curSum; sum>=a; sum--)
            {
                dp[sum] |= dp[sum-a]<<1;

                if (sum*n%total!=0) continue;
                int num = sum*n/total;
                if (num!=0 && num!=n && (dp[sum]&(1<<num))) return true;
            }            
        }
        return false;        
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/0813.Largest-Sum-of-Averages/Readme.md <==
snippet 0813.Largest-Sum-of-Averages "0813.Largest-Sum-of-Averages" b
### 813.Largest-Sum-of-Averages

本题求“最大值”，一般可以朝DP的方向考虑。另外，题意里有明确的分成k个subarray的要求，大概率就是第I类区间型DP。

这类DP的套路就是定义dp[i][k]，表示将前i个元素分成k个subarray的最优解，这里表示the maximzied sum of the average of each subarray. 突破口就是针对最后一个元素A[i]，它必定是在当前的最后一个subarray，考虑这个区间的首元素j会在哪里？如果选定了这个位置j，那么dp[i][k]就分解为了两个子问题，一个是dp[j-1][k-1]，是以前已经解决的状态，另一个就是s[j:k]这段区间的平均值。两者相加就是dp[i][k].我们搜索所有的j的位置，选择使dp[i][k]最大化的结果。

大致的状态转移方程如下:
```cpp
for (i=1; i<=N; i++)
  for (k=1; k<=min(i,K); k++)
  {
      // find the best break point j
      for (int j=i; j>=k; j--)
        dp[i][k] = max(dp[i][k], dp[j-1][k-1] + sum[j:i] );
  }
```
对于第I类区间型DP，最常需要关注的边界值就是dp[i][0].通常这种边界条件是非法的（就像除数不能为零一样），为了避免涉及这个量，我们把dp[i][0]都设计成最差的结果从而避免被使用，在这里就是INT_MIN. 

另外边界条件dp[0][0]通常都会是零。

[Leetcode Link](https://leetcode.com/problems/largest-sum-of-averages)

$0
endsnippet

# ==> ./Dynamic_Programming/0813.Largest-Sum-of-Averages/813.Largest-Sum-of-Averages.cpp <==
snippet 0813.Largest-Sum-of-Averages "0813.Largest-Sum-of-Averages" b
class Solution {
public:
    double largestSumOfAverages(vector<int>& A, int K) 
    {
        int N = A.size();
        A.insert(A.begin(), 0);
        auto dp = vector<vector<double>>(N+1, vector<double>(K+1,0));
        
        dp[0][0] = 0;        
        for (int i=1; i<=N; i++)
            dp[i][0] = INT_MIN/2;        
        
        for (int i=1; i<=N; i++)
            for (int k=1; k<=min(i,K); k++)
            {
                double sum = 0;
                for (int j=i; j>=k; j--)
                {
                    sum += A[j];
                    dp[i][k] = max(dp[i][k], dp[j-1][k-1]+sum*1.0/(i-j+1));
                }
            }
        
        double ret = 0;
        for (int k=1; k<=K; k++)
            ret = max(ret, dp[N][k]);
        return ret;
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/0818.Race-Car/Readme.md <==
snippet 0818.Race-Car "0818.Race-Car" b
### 818.Race-Car

试想一下，到达target的路径可能会有哪几种模式。需要特别注意的是，最后达到终点的时候可能是正向的，也可能是反向的。所以需要分成这么两大类：

1. 到达target时是正向的。这包括：
a. 最幸运的是，直接加速一路恰好到达。（这种情况可以提前处理）
b. 先正向加速一段，然后停止（为了减速到零），然后继续到达终点。
c. 先正向加速一段，然后反向走一段，然后再正向，最后继续到达终点。
其中b和c两种情况其实可以归并为一类，只是反向走的路程的长短不一样而已。

2. 到达target时是反向的。于是这需要先正向加速一段冲过target，然后反向，继续到达终点。

在第一大类和第二大类的情况中，正向加速分别到什么时候为止呢？直觉告诉我们：加速到恰好不超过target的时候，即为分界线。也就是当```n=log2(target+1)```时，```2^(n)-1```表示正向加速不超过target的最远距离；相应的```2^(n+1)-1```就是恰好超过target的最近距离。

第一大类中，确定了n，那么可以遍历反向的步数k，再用递归求解总的步数。也就是说：前向走n步，反向，反向走ｋ步，再反向，剩下的递归．
```cpp
for k = 0,1,2,...,n-1
  dp[target] = min(n+1+k+1+racecar(target-(2^n-1) + (2^k-1)))
```
第二大类中，确定了n，可以直接用递归求解剩余的步数
```cpp
dp[target] = n+1+1+(2^(n+1)-1-target)
```
最后dp[target]取上述几种讨论的最小值．


[Leetcode Link](https://leetcode.com/problems/race-car)
$0
endsnippet

# ==> ./Dynamic_Programming/0818.Race-Car/818.Race-Car.cpp <==
snippet 0818.Race-Car "0818.Race-Car" b
class Solution {
    int dp[10001]={0};
public:
    int racecar(int target) 
    {
        if (dp[target]!=0) return dp[target];
        
        int n = log2(target+1);
        if (pow(2,n)-1==target)
        {
            dp[target] = n;
            return n;   
        }
        
        // run past the taget
        dp[target] = (n+1)+1+racecar(pow(2,n+1)-1-target);
        
        // stop before the target
        for (int k = 0; k<n; k++)
        {
            int temp = n+1+k+1+ racecar( target - (pow(2,n)-1) + (pow(2,k)-1) );
            dp[target] = min(dp[target],temp);
        }
        
        return dp[target];
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/0818.Race-Car/818.Race-Car_BFS.cpp <==
snippet 0818.Race-Car "0818.Race-Car" b
class Solution {
public:
    int racecar(int target) 
    {
        queue<pair<int,int>>q;
        q.push({0,1});           
        set<pair<int,int>>visited;
        visited.insert({0,1});
        
        int count = 0;
        while (!q.empty())
        {
            int len = q.size();
            count++;                        
            
            for (int k=0; k<len; k++)
            {
                int pos = q.front().first;
                int speed = q.front().second;
                q.pop();
            
                int speed_r = speed>0? -1:1;
                if (visited.find({pos,speed_r})==visited.end())
                {
                    visited.insert({pos,speed_r});
                    q.push({pos,speed_r});
                }
            
                int pos_a = pos+speed;
                int speed_a = speed*2;
                if (pos_a==target) return count;
                if (abs(pos_a-target)>target) continue;
                if (visited.find({pos_a,speed_a})==visited.end())
                {
                    visited.insert({pos_a,speed_a});
                    q.push({pos_a,speed_a});
                }                
            }            
        }
        return -1;
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/0823.Binary-Trees-With-Factors/823.Binary-Trees-With-Factors.cpp <==
snippet 0823.Binary-Trees-With-Factors "0823.Binary-Trees-With-Factors" b
class Solution {
public:
    int numFactoredBinaryTrees(vector<int>& A) 
    {
        sort(A.begin(),A.end());
        
        int N=A.size();
        vector<long long>dp(N,1);
        long long M=pow(10,9)+7;
        unordered_map<int,long long>Map;
        
        for (int i=0; i<A.size(); i++)
            Map[A[i]]=i;
        
        for (int i=0; i<A.size(); i++)
        {
            for (int j=0; j<=i; j++)
            {                                
                if (A[i]%A[j]==0 && Map.find(A[i]/A[j])!=Map.end())
                {                    
                    int idx = Map[A[i]/A[j]];
                    dp[i]+=(dp[idx]*dp[j])%M;
                }
            }
            if (i>0 && A[0]==1)
                dp[i]+=2;
        }
        
        long long sum=0;
        for (int i=0; i<A.size(); i++)
            sum = (sum+dp[i])%M;
        
        return sum%M;
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/0837.New-21-Game/Readme.md <==
snippet 0837.New-21-Game "0837.New-21-Game" b
### 837.New-21-Game

首先关于理解题意。这道题是基于赌场游戏black Jack的规则。玩家每一轮拿一张牌，可以拿任意轮(hit)。玩家也可以随时停止拿牌(stand)。但是如果拿到的所有牌的点数大于21，就爆炸了(bust)，也就是输。同时庄家也会陪玩家玩一样的规则，但是庄家是后手，当庄家拿满17的分数之后就会主动stand。

因为每一轮都是玩家先决策。因此玩家有先爆的风险。而且玩家可以赌博在大于17的时候继续hit.

再回到这一题。这题其实是帮助分析庄家赢的概率。也就是N=21,K=17的情况。

#### 解法1：

一种比较常见的思想就是自上而下地递归处理。f(x)表示从手头积分是x时，最终实现目标（也就是等到停牌时积分小于等于N）的概率。那么从x可以通过一步跳转到x+1,x+2,x+3...,x+W。因此有递归方程
```
f(x) = [f(x+1)+f(x+2)+...+f(x+W)]/W
```
其中递归的终点是，当x>=K时停止递归.在这个边界条件，当x<=N时，f(x)=1；当x>N时，概率是f(x)=0.

本题中递归的解法会超时，显然会有很多重复的计算。

#### 解法2：

另一种完全不同的思想，就是计算f(x)表示从0开始能走到x的概率。显然得到当前的积分x，完全取决于之前的积分。比如说当前积分x，可能是通过前一轮x-3的积分，再抽中一张3而来，而抽中3的概率永远是1/W。

我们有递归关系：
```
f(x) = f(x-1)/W + f(x-2)/W +...+ f(x-W)/W
```
这就是动态规划的思想。需要注意f(x)里面x必须是大于等于0的。也就是说，当W=10的时候，计算f(3) = f(0)/W+f(1)/W+f(2)/W，3只有三个前驱状态，而不是W个。

以上的算法会超时。为了节省时间，我们发现f(x)通常情况下就是它之前一个宽度为W的滑窗的和的1/W。特别注意，对于较大的x和较小的x，这个滑窗的宽度不见得都是W。可以想象，当x较小时，滑窗会不断增长；而x较大时，滑窗会不断缩短。滑窗每滑动一个，需要新增最近的元素，减去最远的元素，这要求
```
x-1<K
x-W-1>=0
```


[Leetcode Link](https://leetcode.com/problems/new-21-game)
$0
endsnippet

# ==> ./Dynamic_Programming/0837.New-21-Game/837.New-21-Game.cpp <==
snippet 0837.New-21-Game "0837.New-21-Game" b
class Solution {
public:
    double new21Game(int N, int K, int W) 
    {
        vector<double>dp(N+W,1);       
        for (int i=N+1; i<N+W; i++)
            dp[i]=0;
        for (int i=K; i<=N; i++)
            dp[i]=1;       
        
        double temp = 0;        
        for (int k=K-1; k>=0; k--)
        {            
            if (k==K-1)
            {
                for (int i=1; i<=W; i++)
                    temp+=dp[k+i];
                dp[k]= temp*1.0/W;
            }            
            else if (k<K)
            {
                temp -= dp[k+W+1];
                temp += dp[k+1];
                dp[k]= temp*1.0/W;
            }            
        }
            
        return dp[0];
        
    }
    
};

$0
endsnippet

# ==> ./Dynamic_Programming/0879.Profitable-Schemes/Readme.md <==
snippet 0879.Profitable-Schemes "0879.Profitable-Schemes" b
### 879.Profitable-Schemes

非常常规的DP题。设计状态变量dp[person][profit]表示：恰好用person个人力、并恰好达到profit的利润的方案数。我们遍历所有的project，根据这个project来更新dp状态。基本的状态转移方程是：对于一个project (x,y)，我们有```dp[person+x][profit+y] += dp[person][profit]```。

需要注意的技巧。我们不需要对于利润大于P的dp开辟更多空间，即dp的第二个维度开到P就可以了。这是因为对于利润是P,P+1...P+M的情况，对于我们都没有区别（我们只在乎他们的总和），并且以后我们不会用这些状态给别的状态赋值。所以，我们把利润大于P的状态，都会累加进状态dp[person][P]里面去。

因此最后的结果应该是 ```sum{dp[i][P]} over i=1,2,...,G```，其中P特殊地用来表示P及P以上的利润。


[Leetcode Link](https://leetcode.com/problems/profitable-schemes)
$0
endsnippet

# ==> ./Dynamic_Programming/0879.Profitable-Schemes/879.Profitable-Schemes.cpp <==
snippet 0879.Profitable-Schemes "0879.Profitable-Schemes" b
class Solution {
public:
    int profitableSchemes(int G, int P, vector<int>& group, vector<int>& profit) 
    {
        auto dp = vector<vector<int>>(G+1, vector<int>(P+1,0));
        int M = 1e9+7;
        
        dp[0][0] = 1;
        
        auto dp_new = dp;
        
        for (int k=0; k<group.size(); k++)
        {
            int x = group[k];
            int y = profit[k];
            
            dp_new = dp;
            
            for (int i = 0; i <= G; i++)
                for (int j = 0; j <= P; j++)
                {
                    if (i+x<=G)
                    {
                        int pp = min(j+y,P);
                        
                        dp_new[i+x][pp] += dp[i][j];
                        dp_new[i+x][pp] %= M;
                    }
                }
            
            dp = dp_new;
        }
        
        int ret = 0;
        for (int i = 0; i <= G; i++)
            ret = (ret+dp[i][P])%M;
        
        return ret;
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/0887.Super-Egg-Drop/Readme.md <==
snippet 0887.Super-Egg-Drop "0887.Super-Egg-Drop" b
### 887.Super-Egg-Drop

此题网上可以搜索到的解法是:令dp[k][n]表示用k个鸡蛋来测试n层楼,需要用的最少的trial次数.这种定义是和题意一致的.动态转移方程是:
```
dp[k][n] = min_i {max(dp[k-1][i-1],dp[k][n-i])+1}  for i =1,2,...,n (+1是因为0 index)
```
基本思想是我们考虑将一个蛋放在第i层去实验.如果碎了,那么我们只能继续尝试dp[k-1][i-1];如果没有碎,那么我们相当于可以继续用k个蛋去尝试第i层以上共N-i层楼的实验.但这种遍历n的循环非常耗时,因为n可以非常大.

另一种巧妙的解法是改变状态的定义,令dp[k][m]表示用k个鸡蛋和m次尝试,最多可以测试的楼层的高度.那么转移方程是:
```
dp[k][m] = dp[k-1][m-1]+dp[k][m-1]+1
```
这个思想是,我们设x=dp[k-1][m-1],那么我们在第x+1层扔一个鸡蛋:如果碎了,我们就用(k-1,m-1)的策略,能测量的楼层仍然是x.如果没碎,我们就能在x+1层之上,用(k,m-1)的策略,再检测x2 = dp[k][m-1]层楼.所以总的来说,高度在x1+1+x2之内的楼层,我们必然都可以通过(k,m)来实现检测.


[Leetcode Link](https://leetcode.com/problems/super-egg-drop)
$0
endsnippet

# ==> ./Dynamic_Programming/0887.Super-Egg-Drop/891.Super-Egg-Drop.cpp <==
snippet 0887.Super-Egg-Drop "0887.Super-Egg-Drop" b
class Solution {
public:
    int superEggDrop(int K, int N) 
    {
        auto dp = vector<vector<int>>(K+1,vector<int>(N+1,0));
        
        int m = 0;
        
        while (dp[K][m]<N)
        {
            m++;
            for (int k=1; k<=K; k++)
                dp[k][m] = dp[k-1][m-1]+1+dp[k][m-1];
        }
        return m;
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/0903.Valid-Permutations-for-DI-Sequence/Readme.md <==
snippet 0903.Valid-Permutations-for-DI-Sequence "0903.Valid-Permutations-for-DI-Sequence" b
### 903.Valid-Permutations-for-DI-Sequence

此题可以用DP来解决。首先我们做一些索引上的调整，方便我们理解：
```cpp
int dp[205][205];
N = S.size();
S = "#"+S;
```
这里dp[i][j]表示第i位上（以0为起点）的数值为j的方案数目。这里，j的取值范围是```0~i```。相当于```0~i```的一个permuatation。

我们考虑在往第i位上填数时，显然应该受到S[i]的影响。

S[i]为“I”的时候，说明要求第i位上的数字要比第i-1位上的数字大。那么第i-1位上可以是什么呢？因为第i位上是j，那么第i-1位上只能是1~j-1.所以
```cpp
if (S[i]=='I')
  for (int k = 0; k<j; k++)
    dp[i][j] += dp[i-1][k];
```
有人会问，dp[i-1][?]表示的是```0~i-1```的permutation啊，而dp[i][?]表示的是```0~i```的permutation啊。为什么```0~i-1```的某个全排列接上一个任意的j，就可以是```0~i```的全排列呢？其实我们只要将前i-1位的所有大于等于j的数字都抬高一位，给第i位上的j腾出空间来就行了。我们可以想象，将前i-1位的所有大于等于j的数字都抬高一位，对前i-1位的dp状态没有任何影响。

同理，S[i]为“D”的时候，说明要求第i位上的数字要比第i-1位上的数字小。那么第i-1位上的数是不是从j+1到i-1呢？其实不然，是从j到i-1都可以。为什么呢？我们也只需要将前i-1位大于等于j的数字都抬高一位即可。这样dp[i-1][j]就可以接上第i位的j了。
```cpp
if (S[i]=='D')
  for (int k = j; k<=i-1; k++)
    dp[i][j] += dp[i-1][k];
```
最终的答案是dp[N][j]，将j从0到N遍历一遍，收集这个全排列最后一位的所有可能性，取和即可。


[Leetcode Link](https://leetcode.com/problems/valid-permutations-for-di-sequence)

$0
endsnippet

# ==> ./Dynamic_Programming/0903.Valid-Permutations-for-DI-Sequence/903.Valid-Permutations-for-DI-Sequence.cpp <==
snippet 0903.Valid-Permutations-for-DI-Sequence "0903.Valid-Permutations-for-DI-Sequence" b
class Solution {
    long dp[205][205];
    long M = 1e9+7;
public:
    int numPermsDISequence(string s) 
    {
        int n = s.size();
        s = "#"+s;  
        dp[0][0] = 1;      
        for (int i=1; i<=n; i++)
            for (int j=0; j<=i; j++)
            {
                if (s[i]=='I')
                {
                    for (int k=0; k<j; k++)
                        dp[i][j] = (dp[i][j] + dp[i-1][k]) % M;
                }
                else
                {
                    for (int k=i-1; k>=j; k--)
                        dp[i][j] = (dp[i][j] + dp[i-1][k]) % M;
                }
            }

        long ret = 0;
        for (int j=0; j<=n; j++)
            ret = (ret + dp[n][j]) % M;
        return ret;
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/0920.Number-of-Music-Playlists/Readme.md <==
snippet 0920.Number-of-Music-Playlists "0920.Number-of-Music-Playlists" b
### 920.Number-of-Music-Playlists

此题看到结果需要mod 1e9+7,毫无疑问就需要用到DP.怎么定义状态呢?如果没有任何思路的话,不妨就先顺着题目的意思来.题目里说求L个播放器位置播放N首歌的方法,那么就令dp[i][j]表示有i个播放位置,总共用了j首歌的方案总数.注意,这里的"方案"意思是,每相同的两首歌之间至少要有m个间隔.并且"用了j首歌"的意思是,肯定j首歌每首至少用到了一次.

那么dp[i][j]的状态怎么转移呢?一般而言,我们都会考察dp[i-1][j],dp[i][j-1],dp[i-1][j-1]这些旧状态,看看能否通过它们导出新状态.

我们先考虑dp[i-1][j],也就是说在第i-1个位置的时候,已经用了j首歌.那么在考虑dp[i][j]时,第i个位置上,我们依旧只需要从这j首歌里找,只要满足间隔条件就行.那么可供选择的歌的数目就是j-K.当然这里要求j>K才行.

然后我们考虑dp[i-1][j-1],也就是说在第i-1个位置的时候,才用了j-1首歌.那么在考虑dp[i][j]时,在第i个位置上,我们必须用新歌.那么可供选择的歌的数目就是N-(j-1).当然,这里要求N>(j-1).

至于其他的dp[i][j-1],我们无法从这个状态转移到dp[i][j].

所以转移方程为:
```
if (j>K)
  dp[i][j] += dp[i-1][j]*(j-K)
if (N>j-1)
  dp[i][j] += dp[i-1][j-1]*(N-j+1)
```
那么边界条件是什么呢？其实非常简单，就是dp[1][1]=N. 只有一个播放位置,并且只能放一首歌,自然有N种选择.

回过头来看一看上面的方程,发现确实很巧妙,任何不符合逻辑的dp[i][j]都不会被赋值。


[Leetcode Link](https://leetcode.com/problems/number-of-music-playlists)
$0
endsnippet

# ==> ./Dynamic_Programming/0920.Number-of-Music-Playlists/920.Number-of-Music-Playlists.cpp <==
snippet 0920.Number-of-Music-Playlists "0920.Number-of-Music-Playlists" b
class Solution {
public:
    int numMusicPlaylists(int N, int L, int K) 
    {
        auto dp = vector<vector<long>>(L+1,vector<long>(N+1,0));
        dp[1][1] = N;
        long MOD = 1e9+7;
        
        for (int i=2; i<=L; i++)
            for (int j=1; j<=min(N,i); j++)
            {
                if (j>K) dp[i][j] += dp[i-1][j]*(j-K);
                dp[i][j]%=MOD;
                if (N>j-1) dp[i][j] += dp[i-1][j-1]*(N-j+1);
                dp[i][j]%=MOD;                
            }
        
        return dp[L][N];
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/0931.Minimum-Falling-Path-Sum/Readme.md <==
snippet 0931.Minimum-Falling-Path-Sum "0931.Minimum-Falling-Path-Sum" b
### 931.Minimum-Falling-Path-Sum

最传统的走迷宫的DP题，是问从左上角走到右下角的最小权和路径，每次走只能向右或者向下。此题本质上一样，是问从第一行到最后一行的最小权和路径，每次只能朝是那个方向（左下，正下，右下）。

因此状态转移方程也很类似：
```
dp[i][j] = min (dp[i-1][j-1],dp[i-1][j],dp[i-1][j+1]) + A[i][j];
```
相比与传统的走迷宫的DP，此题不确定的是“最小权和路径”的结束点的具体位置。所以最后的答案是在最后一行的```dp[m-1][j]```中扫描一个，找最小的那个。注意，我们不关心第一行的出发点的位置，因为对于任何的dp[m-1][j]都隐含了一个确定的出发点。


[Leetcode Link](https://leetcode.com/problems/minimum-falling-path-sum)
$0
endsnippet

# ==> ./Dynamic_Programming/0931.Minimum-Falling-Path-Sum/931.Minimum-Falling-Path-Sum.cpp <==
snippet 0931.Minimum-Falling-Path-Sum "0931.Minimum-Falling-Path-Sum" b
class Solution {
public:
    int minFallingPathSum(vector<vector<int>>& A) 
    {
        auto dp = A;        // dp[i][j]: minimum sum of a falling path through A to (i,j)
        int m = A.size();
        int n = A[0].size();
        
        for (int j=0; j<n; j++)
            dp[0][j] = A[0][j];
        
        for (int i=1; i<m; i++)
            for (int j=0; j<n; j++)
            {
                dp[i][j] = INT_MAX;
                for (int k = j-1; k<=j+1; k++)
                {
                    if (k<0 || k>=n) continue;
                    dp[i][j] = min(dp[i][j],  dp[i-1][k]+A[i][j]);                    
                }                
            }
        int ret = INT_MAX;
        for (int j=0; j<n; j++)
            ret = min(ret, dp[m-1][j]);
        return ret;
        
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/0935.Knight-Dialer/Readme.md <==
snippet 0935.Knight-Dialer "0935.Knight-Dialer" b
### 935.Knight-Dialer

这是一道简单但是比较有趣的题目。DP的方法还是比较容易想到的。令dp[k]表示当前拨号数字为ｋ的方案数，显然它取决于在按ｋ之前的那个数字的拨号方案数之和。

举个例子，第i次拨号时的dp[4]就等于第i-1次拨号时的```dp[0]+dp[3]+dp[9]```，这是因为在盘面上骑士只能从０，３，９这三个位置跳跃到４．


[Leetcode Link](https://leetcode.com/problems/knight-dialer)
$0
endsnippet

# ==> ./Dynamic_Programming/0935.Knight-Dialer/935.Knight-Dialer.cpp <==
snippet 0935.Knight-Dialer "0935.Knight-Dialer" b
class Solution {
public:
    int knightDialer(int N) 
    {
        if (N==1) return 10;
        
        unordered_map<int,vector<int>>Map;
        Map[1]={6,8};
        Map[2]={7,9};
        Map[3]={4,8};
        Map[4]={3,9,0};
        Map[6]={1,7,0};
        Map[7]={6,2};
        Map[8]={1,3};
        Map[9]={4,2};
        Map[0]={6,4};
        
        vector<int>dp(10,1);
        vector<int>dp_temp(10);
        int M = 1e9 + 7;
        
        for (int i=1; i<N; i++)
        {            
            for (int k=0; k<=9; k++)
            {
                dp_temp[k] = 0;
                for (int j: Map[k])
                {
                    dp_temp[k]+=dp[j];
                    dp_temp[k] %= M;
                }
            }
            dp = dp_temp;
        }
        
        int result = 0;
        for (int i=0; i<=9; i++)
        {
            result += dp[i];
            result %= M;
        }
        return result;
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/0940.Distinct-Subsequences-II/Readme.md <==
snippet 0940.Distinct-Subsequences-II "0940.Distinct-Subsequences-II" b
### 940.Distinct-Subsequences-II

此题是字符串序列的一道经典题。如果第一次做的话，可能会觉得有难度。

尝试构造状态dp[i]，表示截止第i个字符为止，我们能够创建的distinct子序列有多少．对于这个dp[i]的定义，我们并不要求s[i]必须是子序列的一部分。

接下来，对于第i个字符ch，我们尝试思考它如何参与到已有子序列dp[i-1]的构建来．

情况I:如果它不参与到子序列的构建，那么dp[i-1]有多少子序列，dp[i]一定会保留全部的这些，所以```dp[i]+=dp[i-1]```。举个例子，如果对于dp[i-1]已经有了如下的不同子序列
```
XXXX   (1)
XXX    (2) 
XXX    (3)
XX     (4)
```
那么对于dp[i]而言，以上这些字符串仍然是其一部分。

情况II:如果它参与到子序列的构建，那么dp[i-1]有多少子序列（包括空序列），末位加上S[i]之后，就能生成同样数目的新子序列．所以继续有```dp[i]+=dp[i-1]```．假设s[i]=='a'，那么我们就可以构造出新的子序列（接上面的例子）
```
XXXXa (5)
XXXa  (6)
XXXa  (7)
XXa   (8)
```
所以综合一下，```dp[i]=dp[i-1]*2```  (*)

但是我们显然要处理一种重复的情况，比如说(1)和(6)会不会重复？出现重复的原因在于，如果(1)中的最后一个字符也是'a'，当(1)中的前三个字符和(6)中的前三个字符的来源相同时，这些序列的数目就在```(*)```式里面被重复计算了两遍。

如何去掉这个重复呢？对于(1)而言，我们需要定位第四个字符'a'的位置j。这个j是i之前最后一次出现字符'a'的index。我们可以验证，dp[j-1]所对应子序列xxx，加上s[j]，可以得到"xxxa"的形式；同时dp[j-1]所对应子序列xxx，加上s[i]，也可以得到"xxxa"的形式。这两部分的子序列是完全相同的，是被```(*)```式所重复计算的，所以我们需要减去。

所以综上，dp[i]的更新式子是:```dp[i] = dp[i-1]*2-dp[j-1]```其中```j```就是i前面最后一个满足```S[j]==S[i]```的index。

在实际操作中，我们将S改写成1-index的形式。那么初始状态dp[0]表示的是“空集”所对应的子序列，我们令dp[0]=1代表“空字串”，并参与到后续dp的更新中去。举个例子s="#aba"，当我们查看i=3时，j指向了0，故```dp[3] = dp[2]*2-dp[0]```，这个减法其实就是消去了“空集+a”这样的字符串，而这个字符串在dp[1]中就已经被计算了。

最终的输出是dp[n]。但是这个数字包含了“空字串”，所以答案需要再减去1.

#### 补充
有一个听众问我，为什么去重的操作里，只需要减去dp[j-1]（j是上一个满足S[j]==S[i]的字符的index），而不减去其他的dp[k-1]（k是在j更早之前的某些字符，也满足S[k]==S[i])。这个问题很深刻。

我举个例子：...XXX... (a1) ...YYY... (a2) ...ZZZ... (a3), 其中a1,a2,a3都代表相同的字符a，他们对应的index分别是k,j,i. XXX/YYY/ZZZ表示在各自区间内取的某个subsequence.

我们在计算dp[i]的时候，减去了dp[j-1]，这是因为这两部分是重复的：
```
XXXYYY(a2)
XXXYYY(a3)
```
而我们为什么没有考虑下面这两部分的重复呢？
```
XXX(a1)
XXX(a3)
```
这是因为```XXX(a1)```本质是和```XXXYYY(a2)```重合的！就最终的subsequence的样子而言，前者就是后者的一部分。我们计算dp[i]时，减去的dp[j-1]，去掉了形如```XXXYYY(a2)```的重复，其实也就已经去掉了形如```XXX(a1)```的重复。所以我们不需要考虑其他在j之前的任何S[k]==S[i]的case。


[Leetcode Link](https://leetcode.com/problems/distinct-subsequences-ii)

$0
endsnippet

# ==> ./Dynamic_Programming/0940.Distinct-Subsequences-II/940.Distinct-Subsequences-II.cpp <==
snippet 0940.Distinct-Subsequences-II "0940.Distinct-Subsequences-II" b
class Solution {
    long dp[2005];
    long M = 1e9+7;
public:
    int distinctSubseqII(string s) 
    {
        int n = s.size();
        s = "#"+s;
        vector<int>last(26,0);
        dp[0] = 1;

        for (int i=1; i<=n; i++)
        {
            int j = last[s[i]-'a'];
            dp[i] = dp[i-1] *2 %M - (j>=1 ? dp[j-1] : 0);
            dp[i] = (dp[i]+M) % M;
            last[s[i]-'a'] = i;
        }

        return dp[n] - 1;
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/0943.Find-the-Shortest-Superstring/Readme.md <==
snippet 0943.Find-the-Shortest-Superstring "0943.Find-the-Shortest-Superstring" b
### 943.Find-the-Shortest-Superstring

这是一道难度较高的题。首先注意题目中的substring是连续的，和subsequence的概念不一样。

其次，我们要能敏锐地将它看出，其本质是一道TSP的问题。举个例子，假如说有三个字符串A,B,C，那么最终答案只可能是类似ABC,ACB,BAC,BCA,CAB,CBA这几种可能性的一种（其中ABC表示将ABC三个字符串顺序相连，两两相接的部分有overlap的话就共享）。于是我们发现，这个题目就是让我们找一条最短路径，能包含所有的节点A,B,C。例如在上面的这个例子中，ABC,ACB,BAC,BCA,CAB,CBA的路径长度可能是互不相同的，我们要找出最短的。

慢着，路径ABC代表什么意思呢？它代表ABC三个字串连接起来（再利用公有部分）的长度。不难发现一个很好的性质，ABC的长度其实就是A的长度+（A到B的长度）+（B到C的长度）。其中A到B的长度，表示从字串A增加多少个字符能够变成以B为结尾的字串。例如A=abc,B=bcd,C=cde，那么ABC就代表了abcde，并且肯定是包含了A，B，C三个子串的superstring；其中A到B的长度是1，B到C的长度也是1.

所以，我们可以预处理得到题目中任意两个字串（节点）之间的距离graph[i][j]。现在已知任意节点之间的路径距离，我们要找出一条最短的路径，能包含所有的节点（起始点可以自由选择），这就是典型的旅行商（TSP）问题。

TSP问题最经典的解法是结合了DP的思想。我们设计状态方程dp[set][last],其中set表示已经访问过的节点的集合，last表示这些已经访问过的点集里面最后一个访问到的那个节点。我们认为{set,last}表示了一种“状态”，dp[set][last]就是到达这种状态时的最短路径长度。为什么要用两个指标来定义“状态”，这是因为仅仅根据set作为状态的话，不能往后续作为扩展。

举个例子，我们已经考察完了set4={1,2,3,4}，得到了当前最优解dp[set4]，那么我们想访问5号节点怎么办呢？显然我们不知道如何从已知的dp[set4]往待求的dp[set5]传递。但是如果我们额外知道最后一个节点的信息，那么转移方程就好办了：
```
dp[set5] = min{dp[set4][1]+graph[1][5], dp[set4][2]+graph[2][5], ... , dp[set4][4]+graph[4][5]}
```
可见dp[set][last]是一个很好的状态，便于我们做状态转移。

当然，如果用一个真正的“集合”作为dp的下表，显然实现上很不方便。TSP有个非常成熟的解决方案，就是用整形的32位bit值为来代表节点集合的状态。第k个bit位的数值是1，那么就说明了集合中包含第k个节点；反之就没有包含。例如3=binary(0011)表示包含了节点1和0的集合状态。对于大多数小规模的TSP问题而言，一个32位的整形就可以足够表示节点集合的状态了。

在程序中，我们用mask代表记载集合状态的整数，bit表示最后一个节点是哪个。于是有一个比较公式化的算法用来不断更新dp[mask][bit]：
```
for (int mask=0; mask<2^N; mask++)
  for (int bit=0; bit<N; bit++)
  {      
        pmask = mask删去bit节点;
        for (int i=0; i<N; i++)
        {
          dp[mask][bit] = min_{i}(dp[pmask][i]+graph[i][bit]);
          (where bit is contained in mask, and i is contained in pmask)
          update parent[mask][bit] if necessary;
        }
  }
```
其中比较精妙的point在于第一行的大循环：```for (int mask=0; mask<2^N; mask++)```，这样的循环顺序恰好保证了内循环中的```dp[pmask][i]```永远是已经在之前更新过了的（即已经赋值过的）。原因简而言之，是因为pmask永远是mask的一个子集，因此我们在更新dp[mask]时，dp[pmask]总是已经ready了。

以上的代码循环结束之后，最终的答案存在dp[2^N-1][bit]之中。其中2^N-1表示所有的点都已经被访问并装在集合里面了，而我们需要遍历bit（也就是考察以哪个点结尾），能够得到最短的总路径。

以上的dp存储的只是最短路径的长度。那么怎么回溯构建整个路径呢？我们只需要给每个状态[mask][bit]再添加一个parent的记录，即k=parent[mask][bit]表示的是：最优的dp[mask][bit]是通过dp[pmask][k]+graph[k][bit]得到的。于是我们就能够往上回溯一步了，下一步就递归来考察状态{pmask,k}。于是顺着parent的记录，我们最终能够到达全集合set0的状态.




[Leetcode Link](https://leetcode.com/problems/find-the-shortest-superstring)

$0
endsnippet

# ==> ./Dynamic_Programming/0943.Find-the-Shortest-Superstring/943.Find-the-Shortest-Superstring.cpp <==
snippet 0943.Find-the-Shortest-Superstring "0943.Find-the-Shortest-Superstring" b
class Solution {
public:
    string shortestSuperstring(vector<string>& A) 
    {
        int N = A.size();
        auto graph = vector<vector<int>>(N,vector<int>(N));
        for (int i=0; i<N; i++)
            for (int j=0; j<N; j++)
                if (i!=j) graph[i][j]=cal(A[i],A[j]);
        
        int M = 1<<N;
        auto dp = vector<vector<int>>(M,vector<int>(N,INT_MAX/2));
        auto parent = vector<vector<int>>(M,vector<int>(N,-1));
        for (int i=0; i<N; i++)
            dp[1<<i][i] = A[i].size();
                
        for (int mask=0; mask<M; mask++)
            for (int bit=0; bit<N; bit++)
            {
                if ((mask&(1<<bit))==0) continue;
                int pmask = mask^(1<<bit);      
                // we want to update dp[mask][bit] = min_{i}(dp[pmask][i]+graph[i][bit])
                // where bit must be in mask, and i must be within pmask
                
                for (int i=0; i<N; i++)
                {
                    if ((pmask&(1<<i))==0) continue;
                    if (dp[pmask][i]+graph[i][bit]<dp[mask][bit])
                    {
                        dp[mask][bit] = dp[pmask][i]+graph[i][bit];
                        parent[mask][bit] = i;
                    }
                }                    
            }
                
        int start;
        int count = INT_MAX;
        for (int i=0; i<N; i++)
            if (dp[M-1][i]<count)
            {
                count = dp[M-1][i];
                start = i;
            }
        
        int mask = M-1;
        vector<int>path({start});
        while (parent[mask][start]!=-1)
        {
            int next = parent[mask][start];
            path.push_back(next);
            mask = mask^(1<<start);
            start = next;
        }
        
        reverse(path.begin(),path.end());
        string result = A[path[0]];
        for (int i=1; i<path.size(); i++)
            result = combine(result,A[path[i]]);
        
        return result;
        
    }
    
    int cal(string S, string T)
    {
        for (int k=min(S.size(), T.size()); k>=0; k--)
        {
            if (S.substr(S.size()-k)==T.substr(0,k))
                return T.size()-k;
        }
        return 0;
    }
    
    string combine(string S, string T)
    {
        for (int k=min(S.size(), T.size()); k>=0; k--)
        {
            if (S.substr(S.size()-k)==T.substr(0,k))
                return S+T.substr(k);
        }
        return S+T;
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/0956.Tallest-Billboard/Readme.md <==
snippet 0956.Tallest-Billboard "0956.Tallest-Billboard" b
### 956.Tallest-Billboard

此题乍看很像背包问题，我们来想想如果是背包问题的话会怎么做。

经典的背包问题的思路是：我会设置布尔状态dp[left][right]，表示是否能得到左边高度是left,右边高度是right的状态。每次考虑一个rod[i]，考察把它放在左边，放在右边，以及不用三种情况下，对后续dp的影响。也就是说，如果```dp[left][right]==true```，那么```dp[left+rods[i]]```和```dp[right+rods[i]]```也都可以赋值为true。

以上解法的最大问题是空间和时间的开销都很大，因为left和right都是[0,5000]的区间。空间是o(5000^2)，时间则是o(N*5000^2)。

怎么优化呢？一个想法是反思状态dp设计得是否合理。在上述的设计中，我们最终要找的是一个最大的k，使得有dp[k][k]==true。但其实我们发现，大部分的dp存储的信息最终都浪费掉了，特别是dp代表一个布尔状态，只存储true或false是不是太可惜了。我们最终要求的只是一个左右相等的状态，但我们几乎求解了所有可能的left/right pair，有必要吗？于是这就激励我们，考察左右的差值diff，这是一个[-5000,5000]范围的变量。假设我们如果已经知道了一个固定的diff，我们最希望得到的是什么呢？当然是在此条件下最大的left/right了。因为我们最终答案希望是diff=0时最大的left/right，在后续的探索中，如果用到了这个diff，我们自然只会利用这个最大的left/right。

于是我们可以尝试写出状态
```
dp[diff] = max{ Left | s.t Left-Right = diff}
```
也就是说，我们在当前这一轮中，dp[diff]表示当前所有left-right==diff的配对中，最大的那个Left（相应Right其实也可以确定下来）

如何更新状态呢？假设我们已经有了dp[diff]=left，现在要考察rods[i]，这个棍子有三种选择：

1.我们不使用这根棍子，所有的diff都不受影响，故dp[diff]不变。

2.我们将这根棍子加在left上，那么diff就会变大，我们就可能需要更新diff+rods[i]对应的dp,而这个对应的dp值就是left+rods[i]。

3.我们将这根棍子加在right上，那么diff就会变小，我们就可能需要更新diff-rods[i]对应的dp,而这个对应的dp值依然是left（因为左棍的长度不变）。

需要注意的是，以上的更新只有在left存在的情况下进行。也就是说，需要保证dp[diff]=left有意义。初始化时，只有dp[0]=0,表示初始状态下高度差为0的方案就是left=0,right=0; 其他所有的dp[diff]都标记为-1，表示目前非法。

另外，需要注意，diff的范围是[-5000,5000]，但是dp[diff]数组的index不能是负数。我们在处理下标时需要一个偏移量5000。


[Leetcode Link](https://leetcode.com/problems/tallest-billboard)
$0
endsnippet

# ==> ./Dynamic_Programming/0956.Tallest-Billboard/956.Tallest-Billboard.cpp <==
snippet 0956.Tallest-Billboard "0956.Tallest-Billboard" b
class Solution {
public:
    int tallestBillboard(vector<int>& rods) 
    {
        int N = rods.size();
        int B = 5000;
        vector<int>dp(B*2+1,-1);
        dp[B] = 0;
        
        for (auto x: rods)
        {
            auto dp_temp = dp;
            for (int diff=-B; diff<B; diff++)
            {
                int j = diff+B;
                if (dp_temp[j]==-1) continue;
                                
                if (diff+x<B) dp[j+x] = max(dp[j+x],dp_temp[j]+x);
                if (diff-x>=-B) dp[j-x] = max(dp[j-x],dp_temp[j]);
            }            
        }
        return dp[B];
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/0960.Delete-Columns-to-Make-Sorted-III/Readme.md <==
snippet 0960.Delete-Columns-to-Make-Sorted-III "0960.Delete-Columns-to-Make-Sorted-III" b
### 960.Delete-Columns-to-Make-Sorted-III

我们将每一列看做一个整体的话，本题就是求LIS序列：要求序列的元素（一列字符串）满足递增关系。这里的递增关系具体的定义是每行字符都要是递增的。

这种LIS没有办法用贪心的I(NlogN)来实现，但是用O(N^2)的DP就可以很容易地解决。

$0
endsnippet

# ==> ./Dynamic_Programming/0960.Delete-Columns-to-Make-Sorted-III/960.Delete-Columns-to-Make-Sorted-III.cpp <==
snippet 0960.Delete-Columns-to-Make-Sorted-III "0960.Delete-Columns-to-Make-Sorted-III" b
class Solution {
public:
    int minDeletionSize(vector<string>& A) 
    {
        int N = A[0].size();
        
        vector<int>dp(N,1);
        for (int i=1; i<N; i++)
            for (int j=0; j<i; j++)
            {
                if (checkLarger(i,j,A))
                    dp[i]=max(dp[i],dp[j]+1);
            }
        int result = 0;
        for (int i=0; i<N; i++)
            result = max(result,dp[i]);
        return N-result;
    }
    
    bool checkLarger(int x, int y, vector<string>&A)
    {
        int M = A.size();
        for (int i=0; i<M; i++)
        {
            if (A[i][x]<A[i][y])
                return false;
        }
        return true;
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/0983.Minimum-Cost-For-Tickets/Readme.md <==
snippet 0983.Minimum-Cost-For-Tickets "0983.Minimum-Cost-For-Tickets" b
### 983.Minimum-Cost-For-Tickets

本题虽然看上去DP套路题，但本质还是需要一点贪心的思想。那就是当j小于i时，前j天能乘车的花费一定小于等于前i天能乘车的花费！否则前j天乘车的方案肯定不合算，我们直接采用后者代替就行了。有了这个公理，DP就方便了很多。

假设第i天当日我们不需要乘车，那么前i天乘车的花费dp[i]就完全等同于dp[i-1]。

假设第i天当日我们需要乘车，那么dp[i]只需要考虑三种前驱状态：1. 在第i-1天买张日票，2. 在第i-7天买张周票，3. 在第i-30天买张月票，所以dp[i]就是在dp[i-1]+cost[0], dp[i-7]+cost[1], dp[i-30]+cost[2]中取最小值就可。

有人会说，第i天不一定要是一张票的截止日期呀，dp[i]的最优状态会不会可能是在第i-2天买张周票得到的？根据之前的引理，dp[i-7]<=dp[i-2]。同样是保证第i天能乘车，同样是买张周票，在第i-2天买肯定不如在第i-7天的时候买合算。这样的反思保证了我们的状态转移方程是充分的。

其他的细节需要注意：比如考虑买周票，但i-7小于零的话，那么应该有```dp[i] = dp[0]+cost[1]```，其中dp[0]的值是零。


[Leetcode Link](https://leetcode.com/problems/minimum-cost-for-tickets)

$0
endsnippet

# ==> ./Dynamic_Programming/0983.Minimum-Cost-For-Tickets/983.Minimum-Cost-For-Tickets.cpp <==
snippet 0983.Minimum-Cost-For-Tickets "0983.Minimum-Cost-For-Tickets" b
class Solution {
public:
    int mincostTickets(vector<int>& days, vector<int>& costs) 
    {
        vector<int>dp(400,INT_MAX);
        unordered_set<int>Set(days.begin(), days.end());
        dp[0] = 0;
        for (int i=1; i<=365; i++)
        {
            if (Set.find(i)==Set.end())
            {
                dp[i] = dp[i-1];
                continue;
            }
            int a = dp[max(0,i-1)]+costs[0];
            int b = dp[max(0,i-7)]+costs[1];
            int c = dp[max(0,i-30)]+costs[2];
            dp[i] = min(a, min(b,c));
        }

        return dp[365];        
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/1000.Minimum-Cost-to-Merge-Stones/Readme.md <==
snippet 1000.Minimum-Cost-to-Merge-Stones "1000.Minimum-Cost-to-Merge-Stones" b
### 1000.Minimum-Cost-to-Merge-Stones

这道题的最后一步是将已经merge成K堆的石子做最后一步简单的合并。所以，问题的关键就是变成如何最优化地将原本N堆石子合并成K堆石子，换句话说，需要将[0,N-1]分成K个区间。对于分成K个区间的DP题而言，我们显然会考虑如何先把第一个区间确定，那么其余的就是在剩下的元素里分成K-1个区间。这是比较常见的思路。

所以本题的状态设计为dp[i][j][k]，表示我们将从第i个到第j个元素，归并成k个区间的最小cost是多少。根据上面的想法，我们需要遍历第一个区间可能的范围（即拆分位置m），寻找最优的拆分。也就是
```
dp[i][j][k] = min(dp[i][m][1]+dp[m+1][j][k-1]) for i<=m<j
```
注意，上面的式子里k==1时是没有意义的，因为会导致式子右边的第二项的index变成k-1=0.事实上当k==1的时候，我们单独有：
```
dp[i][j][1] = dp[i][j][K]+sum[i~j]
```
就是将初始状态时的第i个石头到第j个石头的重量加起来而已。注意，这个式子仅仅在j-i+1==K的时候有效，其他时候的dp[i][j][1]应该都初始设置为INF。

综上，我们设计基层循环架构：
```
for (int len = 2; len<=N; len++)
  for (int i=0; i<=N-len; i++)
  {
    int j = i+len-1;    // 这两层循环，我们遍历i,j
    for (int k=2; k<=K; k++)  // 这一层循环我们遍历k
    {
      for (int m=i; m<j; m++) // 这一层循环我们遍历拆分点m，使得分成第一个区间和剩下k-1个区间
      {
        dp[i][j][k] = min(dp[i][m][1]+dp[m+1][j][k-1]) ;
      }
    }
    dp[i][j][1] = dp[i][j][K]+sum[i~j];
  }
return dp[0][N-1][1];
```
初始值的设计是考虑len==1时的dp[i][j][k]，这种情况下显然k只能也是1，所以dp[i][i][1] = 0;

另外，在上面的更新dp[i][j][1]时，要考虑所有加项必须是有意义的，比如dp[i][m][1]和dp[m+1][j][k-1]不能是无意义的INF。


[Leetcode Link](https://leetcode.com/problems/minimum-cost-to-merge-stones)

$0
endsnippet

# ==> ./Dynamic_Programming/1000.Minimum-Cost-to-Merge-Stones/1000.Minimum-Cost-to-Merge-Stones.cpp <==
snippet 1000.Minimum-Cost-to-Merge-Stones "1000.Minimum-Cost-to-Merge-Stones" b
class Solution {
public:
    int mergeStones(vector<int>& stones, int K) 
    {
        int N = stones.size();
        if ((N-1) % (K-1)) return -1;
        
        auto dp = vector<vector<vector<int>>>(N,vector<vector<int>>(N,vector<int>(K+1,INT_MAX)));
        
        vector<int>sum(N+1,0);
        for (int i=0; i<N; i++)
            sum[i+1] = sum[i]+stones[i];
            
        for (int i=0; i<N; i++) dp[i][i][1] = 0;        
        
        for (int len=2; len<=N; len++)
            for (int i=0; i<=N-len; i++)
            {
                int j = i+len-1;
                for (int k=2; k<=K; k++)
                {
                    if (k>len) continue;
                    for (int m=i; m<j; m++)
                    {
                        if (dp[i][m][1]==INT_MAX || dp[m+1][j][k-1]==INT_MAX) continue;   
                        dp[i][j][k] = min(dp[i][j][k], dp[i][m][1] + dp[m+1][j][k-1]);
                    }
                }
                if (dp[i][j][K]!=INT_MAX)
                    dp[i][j][1] = dp[i][j][K] + sum[j+1]-sum[i];
            }
        
        if (dp[0][N-1][1]==INT_MAX) return -1;
        else return dp[0][N-1][1];
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/1027.Longest-Arithmetic-Sequence/Readme.md <==
snippet 1027.Longest-Arithmetic-Sequence "1027.Longest-Arithmetic-Sequence" b
### 1027.Longest-Arithmetic-Sequence

我们考虑对于任意的nums[i]，当它作为某个等差数列的某一项时，它的左边紧邻的一项会是谁？感觉任何j<i的nums[j]其实都可以是候选。因此我们可以遍历i和j，确定i和j之后就可以知道公差diff=nums[i]-nums[j]，于是我们就可以追问：当nums[j]作为公差为diff的等差出列的一员时，在它之前有多长？如果dp[j][diff]表示截止到nums[j]时，公差为diff的等差数列的长度，那么显然dp[i][diff] = dp[j][diff]+1. 于是我们就很容易地得到了状态转移方程。

因此，我们设计的数据结构是```vector<unordered_map<int,int>>dp```,diff作为dp[i]这个Hash表的key，dp[i][diff]就是这个Hash表的value表示长度。

特别注意，如果dp[j][diff]==0，说明nums[j]之前并没有任何元素与nums[j]构成公差为diff的数列，所以这种情况下dp[i][diff]就应该是2（即nums[i],nums[j]组成一个等差数列）而不是1.

此题的思想和```446.Arithmetic-Slices-II-Subsequence```解法1一致。

本题可以有一个follow up：如果给出的数组是一个集合而不是给定顺序的数组，那么答案会是多少？这样的解法就完全不同了。可以参见 https://github.com/wisdompeak/LintCode/tree/master/Two_Pointers/1488.Longest-Sequence


[Leetcode Link](https://leetcode.com/problems/longest-arithmetic-sequence)

$0
endsnippet

# ==> ./Dynamic_Programming/1027.Longest-Arithmetic-Sequence/1027.Longest-Arithmetic-Sequence.cpp <==
snippet 1027.Longest-Arithmetic-Sequence "1027.Longest-Arithmetic-Sequence" b
class Solution {
public:
    int longestArithSeqLength(vector<int>& A) 
    {
        int n = A.size();
        int offset = 500;
        vector<vector<int>>dp(n,vector<int>(1001));
        int result = 1;
        for (int i=0; i<A.size(); i++)
        {
            for (int j=0; j<i; j++)
            {
                int diff = A[i]-A[j];
                if (dp[j][diff+offset]==0)
                    dp[i][diff+offset] = 2;
                else
                    dp[i][diff+offset] = dp[j][diff+offset]+1;
                result = max(result, dp[i][diff+offset]);
            }
        }
        return result;
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/1035.Uncrossed-Lines/Readme.md <==
snippet 1035.Uncrossed-Lines "1035.Uncrossed-Lines" b
### 1035.Uncrossed-Lines

本题的本质就是求longest common subsequence，典型的双字符串类型的DP，不要换了层马甲你就不认识它了。


[Leetcode Link](https://leetcode.com/problems/uncrossed-lines)
$0
endsnippet

# ==> ./Dynamic_Programming/1035.Uncrossed-Lines/1035.Uncrossed-Lines.cpp <==
snippet 1035.Uncrossed-Lines "1035.Uncrossed-Lines" b
class Solution {
public:
    int maxUncrossedLines(vector<int>& A, vector<int>& B) 
    {
        int m = A.size();
        int n = B.size();
        auto dp = vector<vector<int>>(m+1,vector<int>(n+1,0));
        A.insert(A.begin(),0);
        B.insert(B.begin(),0);
        
        dp[0][0] = 0;
        for (int i=1; i<=m; i++)
            for (int j=1; j<=n; j++)
            {
                if (A[i]==B[j])
                    dp[i][j] = dp[i-1][j-1]+1;
                else
                    dp[i][j] = max(dp[i][j-1], dp[i-1][j]);                    
            }
        return dp[m][n];
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/1039.Minimum-Score-Triangulation-of-Polygon/Readme.md <==
snippet 1039.Minimum-Score-Triangulation-of-Polygon "1039.Minimum-Score-Triangulation-of-Polygon" b
### 1039.Minimum-Score-Triangulation-of-Polygon

此题是一个包装得很好的区间型DP题。

我们的突破口是，在初始状态下，两个相邻点(0,1)组成的一条边，必然有对应的一个顶点k跟它组成三角形。那么k如何选择呢？我们可以将除了(0,1)之外的点逐一尝试过来。比如对于六边形，k可以取3，那么我们将(0,3,1)组成一个三角形后，发现将原本多边形分割为了三个区域：左边的部分(1,2,3)，中间的三角形(0,3,1)，右边的部分(3,4,5,0)。于是显然有递归的方案：在k取3的时候，最终得到的总分就是 ```score(0,1,2,3,4,5) = score(1,2,3)+A[0]*A[3]*A[1]+socre(3,4,5,0)```。当然，对于其他的k的选择，我们也都需要考察一遍。答案取所有方案的最小值。

我们发现递归处理score(3,4,5,0)的时候，里面元素的index出现了wrap up，处理起来非常讨厌。这时候我们只要转换思路就可以巧妙地解决这个问题：我们将第一步考虑的对象转换成为(0,5)这条边。继续以六边形为例，k可以取3，那么我们将(0,3,5)组成一个三角形后，发现将原本多边形分割为了三个区域：左边的部分(0,1,2,3)，中间的三角形(0,3,5)，右边的部分(3,4,5)。我们可以发现左右两个需要递归处理的区域，里面的点的index都是连续的！

这个时候用区间型dp就可以很舒服了。dp[i][j]表示对于从i到j这些连续的点组成的多边形（即i => i+1 => i+2 =>...=> j-1 => j =>i），我们细分三角形能得到的最小的score。显然，我们最终求的是dp[0][5]，状态转移方程就是
```cpp
dp[i][j] = min{dp[i][k]+A[i][j][k]+dp[k][j]} for k=i+1,...,j-1
```
边界条件是区间长度为2时，dp值都是0.



[Leetcode Link](https://leetcode.com/problems/minimum-score-triangulation-of-polygon)

$0
endsnippet

# ==> ./Dynamic_Programming/1039.Minimum-Score-Triangulation-of-Polygon/1039.Minimum-Score-Triangulation-of-Polygon.cpp <==
snippet 1039.Minimum-Score-Triangulation-of-Polygon "1039.Minimum-Score-Triangulation-of-Polygon" b
class Solution {
public:
    int minScoreTriangulation(vector<int>& A) 
    {
        int N = A.size();
        auto dp = vector<vector<int>>(N,vector<int>(N,INT_MAX/3));
        
        for (int i=0; i<N-1; i++)
            dp[i][i+1] = 0;
        
        for (int len=3; len<=N; len++)
            for (int i=0; i+len-1<N; i++)
            {
                int j = i+len-1;
                for (int k=i+1; k<=j-1; k++)
                    dp[i][j] = min(dp[i][j], dp[i][k]+dp[k][j]+A[i]*A[j]*A[k]);
            }
        return dp[0][N-1];
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/1043.Partition-Array-for-Maximum-Sum/Readme.md <==
snippet 1043.Partition-Array-for-Maximum-Sum "1043.Partition-Array-for-Maximum-Sum" b
### 1043.Partition-Array-for-Maximum-Sum

这是一个基本款的DP。我们考虑当前正在处理的最后一个元素A[i]，必然会想到它归为哪个subarray？因为A[i]只可能归为最后一个subarray，我们自然会联想到这最后一个subarray的长度可能是1,2,...,直至K。于是我们显然会挨个尝试一遍。只要确定最后一个subarray的范围（比如说从j到i），那么最后一个subarray的sum就能轻易知道（就是这个subarray中的最大值乘以元素个数i-j+1），并且这个subarray前面的所有元素之和恰好就是dp[j-1].

所以状态转移方程就是：
```
dp[i] = max{ dp[j-1], Max_element over A[j,..i] * (i-j+1)},   for j=i, i-1, ... , i-K+1
```
另外需要注意一下，j不可能小于0。


[Leetcode Link](https://leetcode.com/problems/partition-array-for-maximum-sum)
$0
endsnippet

# ==> ./Dynamic_Programming/1043.Partition-Array-for-Maximum-Sum/1043.Partition-Array-for-Maximum-Sum.cpp <==
snippet 1043.Partition-Array-for-Maximum-Sum "1043.Partition-Array-for-Maximum-Sum" b
class Solution {
public:
    int maxSumAfterPartitioning(vector<int>& A, int K) 
    {
        int N = A.size();
        A.insert(A.begin(),0);
        vector<int>dp(N+1,0); //dp[1]~dp[N]:  dp[0]
        
        for (int i=1; i<=N; i++)
        {
            // update dp[i]
            int MAX = INT_MIN;
            for (int j=i; j>=max(i-K+1,1); j--)
            {
                MAX = max(MAX, A[j]);
                dp[i] = max(dp[i], dp[j-1] + MAX*(i-j+1));

            }
        }
        
        return dp[N];
        
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/1049.Last-Stone-Weight-II/Readme.md <==
snippet 1049.Last-Stone-Weight-II "1049.Last-Stone-Weight-II" b
### 1049.Last-Stone-Weight-II

任何对石块的操作，都可以表示成一系列包含绝对值的操作，比如``` ||||a-b|-c|-d| - |e-f||```，那么下一步就是根据每个绝对值符号内的正负情况，脱去绝对值改成括号，并在前面相应地添加正负号，比如```(((a-b)-c)-d)-(e-f)```或者```-(-(-(a-b)-c)-d)+(e-f)```等等。然后再下一步就是脱去括号，必然会在每个单项式的前面标记一个正号或者负号，比如```+a-b+c+d-e+f```之类的。

所以我们很容易想到，任何一种“对消石头”的操作，最终都会转换成一种给数组元素``` a b c d e f```前面添加正负号的策略。于是这就和494.Target-Sum非常相似了。我们可以用DP找出所有正负号策略所能达到的target sum，最终答案就是求那个最小的且比零大的target sum.

需要特别注意的是，并不是所有的“添加正负号”的策略，都会有对应的“对消石头”的操作。比如```+a+b+c+d+e+f```就没有意义。但是我们所求的是最小的target （同时是正数），这是可以证明一定存在对应的“对消石头”的操作的。

我们可以这么想：因为这样的target一定存在，假设是通过某一个序列```XaXbXcXdXeYf```得到的，其中X表示特定的正负号（我们不关心），而最后一步的符号Y（就是元素f之前的那个）会是什么呢？如果是减号，岂不是说明这个target是可以通过两个正整数A-B相减得到的吗？其中A=XaXbXcXdXe，B=f，这就意味着其实存在一种对消策略，可以通过最终的两块石头A和B再做一步对撞得到target。再看第二种情况，如果最后一步的符号Y是正号，那说明其实存在一种对消策略可以得到最终的两块石头A和B，然后A+B=target，但再转念一想，我们此时做|A-B|的话岂不是能得到更小的结果吗？这就和我们约定的那个target是最小的正数相矛盾了。所以结论是，对于我们所关注的最小的target，一定存在一系列操作```XaXbXcXdXe-f=target```，即最后的结果一定是两个石头对撞实现的。


[Leetcode Link](https://leetcode.com/problems/last-stone-weight-ii)
$0
endsnippet

# ==> ./Dynamic_Programming/1049.Last-Stone-Weight-II/1049.Last-Stone-Weight-II.cpp <==
snippet 1049.Last-Stone-Weight-II "1049.Last-Stone-Weight-II" b
class Solution {
public:
    int lastStoneWeightII(vector<int>& stones) 
    {
        unordered_set<int>Set({0});
        
        for (auto x:stones)
        {
            auto Set_temp = Set;
            Set.clear();
            for (auto s:Set_temp)
            {
                Set.insert(s+x);
                Set.insert(s-x);
            } 
        }
        
        int result = INT_MAX;
        for (auto x:Set)
        {
            if (x>=0 && result>x)
                result =x;
        }
        return result;        
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/1049.Last-Stone-Weight-II/1049.Last-Stone-Weight-II_v2.cpp <==
snippet 1049.Last-Stone-Weight-II "1049.Last-Stone-Weight-II" b
class Solution {
public:
    int lastStoneWeightII(vector<int>& stones) 
    {
        int sum = accumulate(stones.begin(), stones.end(), 0);
        vector<int>dp(2*sum+2, false);
        int offset = sum;
        
        dp[stones[0]+offset] = 1;
        dp[-stones[0]+offset] = 1;
        
        for (int i=1; i<stones.size(); i++)
        {
            vector<int>dp2(2*sum+2, false);
            for (int s = -sum; s<= sum; s++)
            {                
                if (s-stones[i] >= -sum && s-stones[i] <= sum)
                    dp2[s+offset] = dp2[s+offset] || dp[s-stones[i]+offset];
                if (s+stones[i] >= -sum && s+stones[i] <= sum)                
                    dp2[s+offset] = dp2[s+offset] || dp[s+stones[i]+offset];                
            }
            dp = std::move(dp2);
        }
                
        for (int s = 0; s<=sum; s++)
            if (dp[s+offset])
                return s;
        return 0;
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/1092.Shortest-Common-Supersequence/Readme.md <==
snippet 1092.Shortest-Common-Supersequence "1092.Shortest-Common-Supersequence" b
### 1092.Shortest-Common-Supersequence

#### 解法1：直接考虑“最短公共超串”
如果只是问Shortest-Common-Supersequence的长度,那么就是一道非常基本的dp题,典型的"two string conversion"的套路.

现在要求打印出这样的Shortest-Common-Supersequence,无非就是从dp[M][N]逆着往回走,每一步我们都需要判断dp[i][j]之前的状态是什么?其实就是重复一遍给dp赋值的逻辑:
1. 如果dp[i][j]是由dp[i-1][j-1]+1得来,也即是说str1[i]==str2[j]，那么就意味着当时在构建SCS的时候，最后一步是在dp[i-1][j-1]的基础上加上str1[i](或者str2[j])
2. 如果dp[i][j]是由dp[i-1][j]+1得来,那么说明当时是在dp[i-1][j]的基础上加上str1[i]，现在逆序重构的时候需要先加上str1[i].
3. 如果dp[i][j]是由dp[i][j-1]+1得来,那么说明当时是在dp[i][j-1]的基础上加上str2[j]，现在逆序重构的时候需要先加上str2[j].

这样一直回退到```i==0 && j==0```

#### 解法2：直接考虑“最长公共子串”
此题还可以先解决一个最长公共子串问题（LCS），求得二维数组dp[i][j]，然后根据这个dp的定义来重构超级串。

同样，我们逆序构造这个超级串：
1. 如果dp[i][j]是由dp[i-1][j-1]+1得来,也即是说str1[i]==str2[j]，那么就意味着当时在构建SCS的时候，是在dp[i-1][j-1]的基础上加上```str1[i]```(或者```str2[j]```).
2. 如果dp[i][j]是由dp[i-1][j]得来,也即是说str1[i]不是属于这个LCS的一部分，那么现在构造SCS的时候，先把它加上。
3. 如果dp[i][j]是由dp[i][j-1]得来,也即是说str2[j]不是属于这个LCS的一部分，那么现在构造SCS的时候，先把它加上。

[Leetcode Link](https://leetcode.com/problems/shortest-common-supersequence)

$0
endsnippet

# ==> ./Dynamic_Programming/1092.Shortest-Common-Supersequence/1092.Shortest-Common-Supersequence_v1.cpp <==
snippet 1092.Shortest-Common-Supersequence "1092.Shortest-Common-Supersequence" b
class Solution {
public:
    string shortestCommonSupersequence(string str1, string str2) 
    {
        int M = str1.size();
        int N = str2.size();
        str1 = "#"+str1;
        str2 = "#"+str2;

        auto dp = vector<vector<int>>(M+1,vector<int>(N+1));
        for (int i=0; i<=M; i++)
            dp[i][0] = i;
        for (int j=0; j<=N; j++)
            dp[0][j] = j;

        for (int i=1; i<=M; i++)
            for (int j=1; j<=N; j++)
            {
                if (str1[i]==str2[j])                
                    dp[i][j] = dp[i-1][j-1]+1;
                else
                    dp[i][j] = min(dp[i][j-1],dp[i-1][j])+1;
            }

        int i=M;
        int j=N;
        string result;
        while (i>0 && j>0)
        {            
            if (str1[i]==str2[j])
            {
                result.push_back(str1[i]);
                i--;
                j--;                
            }
            else if (dp[i][j]==dp[i-1][j]+1)
            {
                result.push_back(str1[i]);
                i--;                
            }            
            else {
                result.push_back(str2[j]);
                j--;
            }
        }
        while (i>0)
        {
            result.push_back(str1[i]);
            i--;
        }
        while (j>0)
        {
            result.push_back(str2[j]);
            j--;
        }
        reverse(result.begin(),result.end());
        return result;
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/1092.Shortest-Common-Supersequence/1092.Shortest-Common-Supersequence_v2.cpp <==
snippet 1092.Shortest-Common-Supersequence "1092.Shortest-Common-Supersequence" b
class Solution {
public:
    string shortestCommonSupersequence(string str1, string str2) 
    {
        int m = str1.size();
        int n = str2.size();
        str1 = "#"+str1;
        str2 = "#"+str2;
        auto dp = vector<vector<int>>(m+1,vector<int>(n+1,0));

        for (int i=1; i<=m; i++)
            for (int j=1; j<=n; j++)
            {
                if (str1[i]==str2[j])
                    dp[i][j] = dp[i-1][j-1]+1;
                else
                    dp[i][j] = max(dp[i][j-1], dp[i-1][j]);
            }
       
        int i=m, j=n;
        string ret;
        while (i>0 && j>0)
        {
            if (str1[i]==str2[j])
            {
                ret.push_back(str1[i]);
                i--;
                j--;
            }
            else if (dp[i][j] == dp[i-1][j])
            {
                ret.push_back(str1[i]);
                i--;
            }
            else
            {
                ret.push_back(str2[j]);
                j--;
            }
        }
        
        while (i>0)
        {
            ret.push_back(str1[i]);
            i--;
        }
        while (j>0)
        {
            ret.push_back(str2[j]);
            j--;
        }
        reverse(ret.begin(),ret.end());
        return ret;
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/1105.Filling-Bookcase-Shelves/Readme.md <==
snippet 1105.Filling-Bookcase-Shelves "1105.Filling-Bookcase-Shelves" b
### 1105.Filling-Bookcase-Shelves

这道题的突破点就在于你是否能想到用动态规划。贪心法啥的可能是个误区。

我们处理第i本书的时候，得考虑它之前的放在同一层的书可能有多少？我们可以往前一一遍历过来，直至同一层的书宽度超过了shelf_width的限制为止。注意，遍历的过程中，我们认为它们都是在同一层的，所以这一层的高度就是这些书高度的最大值maxCurHeight。假如我们认为books[i]到books[j]都是属于同一层的，那么截止到第i本书整体占据的绝对高度，就是截止到第j-1本书整体占据的绝对高度（也就是上一层的高度）加上这一层当前的maxCurHeight。

所以dp[i]的定义就是，将第i本书作为当层最后一本书时，此时整体的书架高度。状态转移方程就是：
```
dp[i] = min {dp[j-1] + max(books[j][1]，...,books[i][1]) }  for j = i, i-1, ...
```


[Leetcode Link](https://leetcode.com/problems/filling-bookcase-shelves)
$0
endsnippet

# ==> ./Dynamic_Programming/1105.Filling-Bookcase-Shelves/1105.Filling-Bookcase-Shelves.cpp <==
snippet 1105.Filling-Bookcase-Shelves "1105.Filling-Bookcase-Shelves" b
class Solution {
public:
    int minHeightShelves(vector<vector<int>>& books, int shelf_width) 
    {
        int N = books.size();
        books.insert(books.begin(),{0,0});        
        vector<int>dp(N+1,INT_MAX/2);
        dp[0] = 0;
        
        for (int i=1; i<=N; i++)
        {
            int width = books[i][0];
            int height = books[i][1];
            dp[i] = dp[i-1]+height;
            
            int j = i-1;
            while (j>=1 && books[j][0]+width<=shelf_width)
            {                
                width += books[j][0];
                height = max(height, books[j][1]);
                dp[i] = min(dp[i], dp[j-1]+height);
                j--;
            }
        }
        return dp[N];
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/1125.Smallest-Sufficient-Team/Readme.md <==
snippet 1125.Smallest-Sufficient-Team "1125.Smallest-Sufficient-Team" b
### 1125.Smallest-Sufficient-Team

这本质是一道背包问题，用到了状态压缩的技巧。我们将当前所收集的技巧编码成一个整形skillset，每个bit位表示该技巧是否被收集到。dp[skillset]表示截止当前为止，实现skillset至少需要多少人。

仿照背包问题的套路，第一层循环我们遍历每个人，第二层循环我们遍历所有可能的skillset。考虑这个人的技能skills[i]带来什么样的impact呢？通过bit or操作，它可以将skillset升级为newSkillSet，于是dp[newSkillSet]就有机会更新为更小的值dp[skillset]+1.

遍历完所有的人之后，我们只需要查看的结果就是dp[requiredSkillSet]。

$0
endsnippet

# ==> ./Dynamic_Programming/1125.Smallest-Sufficient-Team/1125.Smallest-Sufficient-Team.cpp <==
snippet 1125.Smallest-Sufficient-Team "1125.Smallest-Sufficient-Team" b
class Solution {
public:
    vector<int> smallestSufficientTeam(vector<string>& req_skills, vector<vector<string>>& people) 
    {
        unordered_map<string,int>skill2num;
        for (int i = 0; i< req_skills.size(); i++)
        {
            skill2num[req_skills[i]] = i;            
        }
        
        vector<int>p2s(people.size());
        for (int i=0; i<people.size(); i++)
        {
            int skillset = 0;
            for (auto skill: people[i])
            {
                if (skill2num.find(skill)==skill2num.end())
                    continue;
                int idx = skill2num[skill];
                skillset += (1<<idx);
            }
            p2s[i] = skillset;
        }
        
        int N = req_skills.size();
        vector<vector<int>>saves(1<<N);  // saves[skillset] : the member ids that fulfill skillset
        vector<int>dp((1<<N), INT_MAX/2);
        
        dp[0] = 0;
        
        for (int i=0; i<people.size(); i++)
        {
            auto dp2 = dp;
            for (int skillset = 0; skillset < (1<<N); skillset++)
            {
                int new_skillset = skillset | p2s[i];
                if (dp2[new_skillset] > dp[skillset]+1)
                {
                    dp2[new_skillset] = dp[skillset]+1;
                    saves[new_skillset] = saves[skillset];
                    saves[new_skillset].push_back(i);
                }
            }
            dp = dp2;
        }
        
        return saves[(1<<N)-1];        
    }
};


$0
endsnippet

# ==> ./Dynamic_Programming/1130.Minimum-Cost-Tree-From-Leaf-Values/Readme.md <==
snippet 1130.Minimum-Cost-Tree-From-Leaf-Values "1130.Minimum-Cost-Tree-From-Leaf-Values" b
### 1130.Minimum-Cost-Tree-From-Leaf-Values
#### 解法1：
比较容易想到的解法就是区间型的DP。令状态dp[i][j]表示将[i,j]之间的元素最终聚成一个元素所需要的cost。显然，突破点就是如何将这个区间划分为左右两个分支，这就需要遍历可能的内部分界点k。这样的话，就可以得到状态转移方程：
```
dp[i][j] = min(dp[i][k]+dp[k+1][j]+largest[i][k]*largest[k+1][j])
```
需要注意，largest[k+1][j]需要提前处理，这可能需要设计另外一个dp过程：
```
largest[i][j] = max(largest[i][i],largest[i+1][j])
```
这样的解法时间复杂度是o(N^3).

#### 解法2：
更优秀的解法需要对于题意做进一步的理解。

我们可以想象，每一次对两个节点做“归并”，就是消灭较小的数，保留较大的数。所以整个过程可以理解为：对于arr的数组，每次取当前相邻的两个元素进行归并，较小的元素被消失，较大的元素保留，其cost是两者的乘积。注意，消失的元素会使得原先不相邻的两个元素变得相邻。问经过N-1次归并之后的最小cost总和是多少。

所以对于任何一个元素，它只能是在与更大的元素相遇之后才能被消失，否则会一直存在。那么更大的元素是什么呢？就两种选择：左边第一个比它大的数，右边第一个比它大的数。显然，为了减小cost，我们必然选择让它和较小的那个候选数去碰撞。体会一下，对于每个元素，它所作的选择都是独立的，不会相互冲突。举个例子：ABCDEF，对于D而言，如果我们可以判定它和A碰撞最优（当然A>D)，那么对于B或者C的碰撞对象的选择没有任何影响。这是因为允许D选择A的隐含信息就是BC都比A小，B和C必定只能限制在A和D之间选择。

所以算法的大致思想就是：对于每个元素arr[i]，我们考察它被消去时候的cost，然后总cost相加就是答案。（显然，我们只有N-1次相消，因为最大的元素是不可能被消去的）。单个元素的cost，就是在其左边第一个比它大的数a，右边第一个比它大的数b，两者之间选择，即 ```arr[i]*min(a,b)```。求一个数组里每一个元素的左边（或者右边）第一个比它大的元素，就是典型的单调栈的应用。参考496.next greater element.

有两个细节需要注意。

首先，如果一个元素的左边没有比它更大的数，但它仍有可能被（右边更大的数）消去，那么我们就定义```a=INT_MAX```.对于右边的情况同样处理。

其次，以上的算法中严格要求了所有的元素都能比较（分出大小）。如果两个元素的数值相等，我们必须额外定义一个区分大小的原则。最简单的方法就是，数值相等的元素，右边的更大。如果我们不这样处理，会遇到这样的情况：```xxxx A1 A2 xxx```，当A1与A2相等时，如果我们考虑A1可以被A2消去，且考虑A2可以被A1消去，那么会有两次cost的相加。但事实上A1与A2的碰撞只应该计算一次cost。


[Leetcode Link](https://leetcode.com/problems/minimum-cost-tree-from-leaf-values)
$0
endsnippet

# ==> ./Dynamic_Programming/1130.Minimum-Cost-Tree-From-Leaf-Values/1130.Minimum-Cost-Tree-From-Leaf-Values_DP.cpp <==
snippet 1130.Minimum-Cost-Tree-From-Leaf-Values "1130.Minimum-Cost-Tree-From-Leaf-Values" b
class Solution {
public:
    int mctFromLeafValues(vector<int>& arr) 
    {
        int n = arr.size();
        auto dp = vector<vector<int>>(n,vector<int>(n,INT_MAX));
        auto large = vector<vector<int>>(n,vector<int>(n,INT_MIN));
        int sum  = 0;
        for (int i=0; i<n; i++)
        {
            dp[i][i] = arr[i];
            large[i][i] = arr[i];
            sum += arr[i];
        }            
        
        for (int len = 2; len<=n; len++)
            for (int i=0; i<=n-len; i++)
            {
                int j = i+len-1;
                for (int k=i; k<j; k++)                
                {
                    dp[i][j] = min(dp[i][j], dp[i][k]+dp[k+1][j]+large[i][k]*large[k+1][j]);
                    large[i][j] = max(large[i][k], large[k+1][j]);
                }                    
            }
        
        return dp[0][n-1] - sum;
        
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/1130.Minimum-Cost-Tree-From-Leaf-Values/1130.Minimum-Cost-Tree-From-Leaf-Values_stack.cpp <==
snippet 1130.Minimum-Cost-Tree-From-Leaf-Values "1130.Minimum-Cost-Tree-From-Leaf-Values" b
class Solution {
public:
    int mctFromLeafValues(vector<int>& arr) 
    {
        int n = arr.size();
        vector<int>nextGreater(n,INT_MAX);
        vector<int>prevGreater(n,INT_MAX);
        
        stack<int>Stack;
        for (int i=0; i<arr.size(); i++)
        {
            if (Stack.empty() || arr[i] <= arr[Stack.top()])
                Stack.push(i);
            else
            {
                while (!Stack.empty() && arr[Stack.top()] <= arr[i])
                {
                    int idx = Stack.top();
                    nextGreater[idx] = arr[i];
                    Stack.pop();
                }
                Stack.push(i);
            }                
        }
        
        while (!Stack.empty()) Stack.pop();
        for (int i=0; i<arr.size(); i++)
        {
            if (Stack.empty() || arr[i] <= arr[Stack.top()])
            {
                if (!Stack.empty()) prevGreater[i] = arr[Stack.top()];
                Stack.push(i);
            }
            else 
            {
                while (!Stack.empty() && arr[Stack.top()] <= arr[i])
                    Stack.pop();
                if (!Stack.empty())
                    prevGreater[i] = arr[Stack.top()];
                Stack.push(i);
            }
        }
        
        int result = 0;
        for (int i=0; i<arr.size(); i++)
        {
            int x = min(prevGreater[i], nextGreater[i]);
            if (x!=INT_MAX)
                result += arr[i]*x;   
        }
        return result;
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/1143.Longest-Common-Subsequence/Readme.md <==
snippet 1143.Longest-Common-Subsequence "1143.Longest-Common-Subsequence" b
### 1143.Longest-Common-Subsequence

这道经典的LCS是双序列dp的模板题。LCS有很多变体，大概归纳了一下：

- LC 583. Delete Operation for Two Strings

问：从字符串s和t中总共最少删除多少个字符能使得它们相等。

- LC 712. Minimum ASCII Delete Sum for Two Strings

问：从字符串s和t中总共最少删除多少ASCII码值的字符能使得它们相等。

- LC 1035. Uncrossed Lines

两个数组s和t之间相等的数字可以连线。连线不能交叉。问最多可以有几条连线。

- LC 1312. Minimum Insertion Steps to Make a String Palindrome

问一个字符串s最少需要添加多少个字符能变成回文串。

$0
endsnippet

# ==> ./Dynamic_Programming/1143.Longest-Common-Subsequence/1143.Longest-Common-Subsequence.cpp <==
snippet 1143.Longest-Common-Subsequence "1143.Longest-Common-Subsequence" b
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) 
    {
        int m = text1.size();
        int n = text2.size();
        text1 = "#"+text1;
        text2 = "#"+text2;
        
        auto dp = vector<vector<int>>(m+1,vector<int>(n+1,0));
        
        for (int i=1; i<=m; i++)
            for (int j=1; j<=n; j++)
            {
                if (text1[i]==text2[j])
                    dp[i][j] = dp[i-1][j-1]+1;
                else
                    dp[i][j] = max(dp[i-1][j],dp[i][j-1]);
            }
        
        return dp[m][n];
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/1186.Maximum-Subarray-Sum-with-One-Deletion/Readme.md <==
snippet 1186.Maximum-Subarray-Sum-with-One-Deletion "1186.Maximum-Subarray-Sum-with-One-Deletion" b
### 1186.Maximum-Subarray-Sum-with-One-Deletion

本题可以先从一个很经典的问题出发：如何求一个数组里和最大的subarray？答案是kadane算法，可以用dp的思想来说明。令dp[i]表示以元素i为结尾的subrray里能得到的最大和。因此计算dp[i]时必然会考虑充分利用以元素i-1为结尾的最大subarray。
```
dp[i] = max(dp[i-1]+arr[i], arr[i])
```
注意：也有可能dp[i-1]是个负数反而会带来“负担”，因此上面的状态转移方程里还需要考虑arr[i]本身这个单元素数组的可能性。

那么对于本题而言，我们多了一个"deletion"的权力。如何利用这个权力，处理方法其实和```487.Max Consecutive Ones II```很像。就是将原本的dp[i]再拆分为两个状态。dp[i][0]表示"maximum sum for a non-empty subarray ending at i, w/o any deletion"，而dp[i][1]表示"maximum sum for a non-empty subarray ending at i, with one deletion done".

可以分析出新的转移方程：
```
dp[i][0] = max(dp[i-1][0] + arr[i], arr[i]);
dp[i][1] = max(dp[i-1][0], dp[i-1][1] + arr[i]);
```
其中第一条和常规的kadane算法没有差别。第二条是分两种情况讨论，考虑这个被删除的数是否是arr[i]。如果被删的是arr[i]，那么问题就转化为求以元素i-1结尾的常规的最大subarray sum；如果被删的不是arr[i]，那么说明被删的数是存在于对应dp[i-1][1]（即必须删去某个元素）的最大subarray里。



[Leetcode Link](https://leetcode.com/problems/maximum-subarray-sum-with-one-deletion)
$0
endsnippet

# ==> ./Dynamic_Programming/1186.Maximum-Subarray-Sum-with-One-Deletion/1186.Maximum-Subarray-Sum-with-One-Deletion.cpp <==
snippet 1186.Maximum-Subarray-Sum-with-One-Deletion "1186.Maximum-Subarray-Sum-with-One-Deletion" b
class Solution {
public:
    int maximumSum(vector<int>& arr) 
    {
        int n = arr.size();
        auto dp = vector<vector<int>>(n, vector<int>(2));
        
        dp[0][0] = arr[0];
        dp[0][1] = 0;    
        
        int ret = arr[0];
        for (int i=1; i<n; i++)
        {
            dp[i][0] = max(dp[i-1][0] + arr[i], arr[i]);
            dp[i][1] = max(dp[i-1][0], dp[i-1][1] + arr[i]);
            ret = max(ret, max(dp[i][0], dp[i][1]));    
        }
        return ret;
    }
};


// Kadane
// dp[i][0] :  maximum sum for a non-empty subarray ending at i, w/o any deletion.
// dp[i][1] :  maximum sum for a non-empty subarray ending at i, w/ one deletion.    



    





$0
endsnippet

# ==> ./Dynamic_Programming/1187.Make-Array-Strictly-Increasing/Readme.md <==
snippet 1187.Make-Array-Strictly-Increasing "1187.Make-Array-Strictly-Increasing" b
### 1187.Make-Array-Strictly-Increasing

考虑到本题给予了一种替换操作的“权力”，从动态规划的套路经验可以尝试，以使用这种“权力”的次数作为状态。因此我们设计dp[i][k]表示：如果我们可以使用k次替换操作使得前i个元素严格递增，此时第i个元素可以选择的最小值。注意，这个dp状态变量的“值”的定义和我们以往套路不同的地方在于，并没有照搬题目的问题"minimum operations"，因为操作数已经用dp的下标k标示了。我们之所以选择“此时第i个元素可以选择的最小值”作为值，是有点贪心的思想。因为我们想要使得这个递增序列能够接的更长的话，必然会让第i个元素尽可能地小。

我们如何更新dp[i][k]呢，显然突破口就在于第i个元素是否使用替换操作的“权力”。

如果第i个元素我们不替换。那么显然要求前i-1个元素用k次操作已经保持递增，并且arr1[i]能够顺利地再接上去。即
```cpp
if (arr1[i] > dp[i-1][k])
  dp[i][k] = arr1[i]
```
如果第i个元素我们做了替换。那么显然要求前i-1个元素用k-1次操作已经保持递增，并且能把arr1[i]替换后的数再顺利地再接上去。那么我们想替换成什么数呢？显然应该是arr2里面恰好比dp[i-1][k-1]大一点点的那个数。注意下面的代码只在k>=1的时候有效。
```
auto iter = upper_bound(arr2.begin(), arr2.end(), dp[i-1][k-1]);
if (iter!=arr2.end()) 
  dp[i][k] = *iter; 
```
以上两种情况都需要考虑。因此我们是用两个值来试图更新dp[i][k]，取较小的那个。如果两种情况都无法满足，即都无法更新dp[i][k]，那么我们会默认dp[i][k]为无穷大，表示“我们无法使用k次替换操作使得前i个元素严格递增”。

$0
endsnippet

# ==> ./Dynamic_Programming/1187.Make-Array-Strictly-Increasing/1187.Make-Array-Strictly-Increasing.cpp <==
snippet 1187.Make-Array-Strictly-Increasing "1187.Make-Array-Strictly-Increasing" b
class Solution {
public:
    int makeArrayIncreasing(vector<int>& arr1, vector<int>& arr2) 
    {
        int n = arr1.size();
        arr1.insert(arr1.begin(),0);
        sort(arr2.begin(),arr2.end());
        auto dp = vector<vector<int>>(n+1, vector<int>(n+1,INT_MAX));
        dp[0][0] = INT_MIN;

        for (int i=1; i<=n; i++)
            for (int k=0; k<=i; k++)
            {
                if (arr1[i] > dp[i-1][k])
                    dp[i][k] = min(dp[i][k], arr1[i]);

                if (k>=1)
                {
                    auto iter = upper_bound(arr2.begin(), arr2.end(), dp[i-1][k-1]);
                    if (iter!=arr2.end()) dp[i][k] = min(dp[i][k], *iter);
                }                
            }

        int ret = INT_MAX;
        for (int k=0; k<=n; k++)
            if (dp[n][k]!=INT_MAX) ret = min(ret, k);

        return ret == INT_MAX ? -1: ret;
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/1216.Valid-Palindrome-III/Readme.md <==
snippet 1216.Valid-Palindrome-III "1216.Valid-Palindrome-III" b
### 1216.Valid-Palindrome-III

此题和1312题很相似的想法。想要将一个字符串s变成一个回文串（无论是通过增加还是删除），一个技巧就是构造另一个字符串t是s的逆序。于是，如果要求增加字符，那么s和t的shorted common supersequence就是需要增加的最少字符；如果要求删除字符，那么s和t的longest common subsequence就对应着需要删除的最少字符。

本题求出s和t的LCS后，只需要判断s的长度减去LCS的长度（即对于s而言最少需要删除的字符）是否小于等于k即可。

$0
endsnippet

# ==> ./Dynamic_Programming/1216.Valid-Palindrome-III/1216.Valid-Palindrome-III.cpp <==
snippet 1216.Valid-Palindrome-III "1216.Valid-Palindrome-III" b
class Solution {
public:
    bool isValidPalindrome(string s, int k) 
    {
        int m = s.size();
        string t = s;
        reverse(t.begin(),t.end());
        
        s = "#"+s;
        t = "#"+t;
                
        auto dp = vector<vector<int>>(m+1,vector<int>(m+1,0));
        
        for (int i = 1; i <= m; i++) 
            for (int j = 1; j <= m; j++) 
            {             
                if (s[i] == t[j]) 
                    dp[i][j] = dp[i - 1][j - 1]+1; 
                else
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]); 
            }         
  
        return m-dp[m][m]<=k; 
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/1223.Dice-Roll-Simulation/Readme.md <==
snippet 1223.Dice-Roll-Simulation "1223.Dice-Roll-Simulation" b
### 1223.Dice-Roll-Simulation

本题属于一类常规的DP题。这类题目的特征就是“不能出现联系多少个XXX”。

以前做过一类更简化的版本，就是“不能出现连续两个相同的XXX”。那种情况下，定义dp[i][j]表示第i轮选择状态j，则```dp[i][j] = sum(dp[i-1][j'])```其中j'是所有的状态选择但不能是j。

这个题目更general，不能连续出现的次数是个变量，而且与j有关。于是我们可以定义dp[i][j][k]表示“第i轮选择状态j、并且结尾已经出现了连续k个状态j的方案数目”。显然我们可以分两种情况讨论：
1. k==1，说明第i-1轮的时候可以选任何不同于j的状态j'，并且第三个下标没有限制（只要不超过rollMax[j']的限制即可）。
2. k>1，说明第i-1轮的时候必须任然是j的状态，且第三个下标只能是k-1（表示结尾连续出现了k-1次）

最终的结果就是dp[n][j][k]对于任意j和k的情况的总和。

$0
endsnippet

# ==> ./Dynamic_Programming/1223.Dice-Roll-Simulation/1223.Dice-Roll-Simulation.cpp <==
snippet 1223.Dice-Roll-Simulation "1223.Dice-Roll-Simulation" b
class Solution {
public:
    int dieSimulator(int n, vector<int>& rollMax) 
    {
        int M = 1e9+7;        
        auto dp = vector<vector<vector<int>>>(n+1,vector<vector<int>>(7,vector<int>(16,0)));
        rollMax.insert(rollMax.begin(),0);

        for (int j=1; j<=6; j++)
            dp[1][j][1] = 1;

        for (int i=2; i<=n; i++)
            for (int j=1; j<=6; j++)
                for (int k=1; k<=rollMax[j]; k++)
                {
                    if (k==1)
                    {
                        for (int jj=1; jj<=6; jj++)
                        {
                            if (jj==j) continue;
                            for (int kk=1; kk<=rollMax[jj]; kk++)
                                dp[i][j][k] = (dp[i][j][k] + dp[i-1][jj][kk])%M;
                        }
                    }
                    else
                    {
                        dp[i][j][k] = (dp[i][j][k] + dp[i-1][j][k-1])%M;
                    }
                }
    
        int sum = 0;
        for (int j=1; j<=6; j++)
            for (int k=1; k<=rollMax[j]; k++)
                sum = (sum + dp[n][j][k])%M;

        return sum;

    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/1246.Palindrome-Removal/Readme.md <==
snippet 1246.Palindrome-Removal "1246.Palindrome-Removal" b
### 1246.Palindrome-Removal

题意描述：给一个字符串s，每次删除其中的一个回文substring，问多少次删完？

本题并没有特别明显的套路特征。第二类区间型DP应该是穷尽其他想法之后的兜底方案。我们定义dp[i:j]表示对于s[i:j]最少需要删几次。接下来考虑，如何将这个大区间转化为小区间呢？如果没有其他明显的特征的话，一个常见的处理方法就是看最后一个元素s[j]。

因为无论怎么设计方案，s[j]都可以是最后一个被删除的。我们就想s[j]会和谁一起删除？必然是找相同的字符。因此我们在[i:j]中寻找一个s[k]==s[j]，那么原来的大区间就分化为了两部分：dp[i][k-1]+dp[k][j]。而对于后者，我们发现s[k]和s[j]并不占用操作，而是可以和删除dp[k+1][j-1]的时候一起消除（回文加了一层而已）。

因此状态转移方程是：
```cpp
        for (int len = 1; len <= N; len++)           
            for (int i = 1; i+len-1<=N; i++) 
            { 
                int j = i+len-1;
                dp[i][j] = dp[i][j-1]+1;                
                for (int k=i; k<j; k++)
                {
                    if (arr[k]==arr[j])
                        dp[i][j] = min(dp[i][j], dp[i][k-1]+max(1,dp[k+1][j-1]));
                } 
            }
```
特别注意，删除s[k]和s[j]并不是永远都不占用操作数，如果当dp[k+1][j-1]本身是0的时候，我们还是需要将s[k]和s[j]当作一对紧挨着的回文数删去的。

$0
endsnippet

# ==> ./Dynamic_Programming/1246.Palindrome-Removal/1246.Palindrome-Removal.cpp <==
snippet 1246.Palindrome-Removal "1246.Palindrome-Removal" b
class Solution {
public:
    int minimumMoves(vector<int>& arr) 
    {
        int N = arr.size(); 
        arr.insert(arr.begin(),0);
        
        auto dp = vector<vector<int>>(N+2,vector<int>(N+2,0));        
      
        for (int len = 1; len <= N; len++)           
            for (int i = 1; i+len-1<=N; i++) 
            { 
                int j = i+len-1;
                dp[i][j] = INT_MAX/2;                 
                for (int k=i; k<=j; k++)
                {
                    if (arr[k]==arr[j])
                        dp[i][j] = min(dp[i][j], dp[i][k-1]+max(1,dp[k+1][j-1]));
                } 
            }         
  
        return dp[1][N]; 
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/1259.Handshakes-That-Don't-Cross/Readme.md <==
snippet 1259.Handshakes-That-Don't-Cross "1259.Handshakes-That-Don't-Cross" b
### 1259.Handshakes-That-Don't-Cross

设计dp[i]表示i个人互相握手有多少种符合题意的方法。

我们考虑最后一个人（第i个人）的握手方案。注意i必须是偶数，否则整体就无解。第i个人的选择可以是他左手第1个、第3个、第5个...直至右手第1个。考虑到第i个人的配成功，会将整个圈划分成了独立的左右两部分，因此上面这些方案其实对应了将这个圈细分的每种可能：(0,i-2),(2,i-4),(4,i-6)...(i-2,0)，其中每个括号内表示左右两部分的人数。

因此我们可以得到递推关系式：```dp[i] = sum(dp[j]+dp[i-2-j])， j=0,2,...i-2```

$0
endsnippet

# ==> ./Dynamic_Programming/1259.Handshakes-That-Don't-Cross/1259.Handshakes-That-Don't-Cross.cpp <==
snippet 1259.Handshakes-That-Don't-Cross "1259.Handshakes-That-Don't-Cross" b
class Solution {
public:
    int numberOfWays(int num_people) 
    {
        int n = num_people;
        vector<long long>dp(n+1,0);        
        dp[0] = 1;
        dp[2] = 1;
        int M = 1e9+7;
        
        for (int i=4; i<=n; i+=2)
        {
            for (int j=0; j<=i-2; j++)
            {
                dp[i] += dp[j]*dp[i-2-j]%M;
                dp[i] %= M;
            }            
        }
        return dp[n];
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/1262.Greatest-Sum-Divisible-by-Three/Readme.md <==
snippet 1262.Greatest-Sum-Divisible-by-Three "1262.Greatest-Sum-Divisible-by-Three" b
### 1262.Greatest-Sum-Divisible-by-Three

#### 解法1：数学
我们将所有的数字分为三类，有a个被3整除的，有b个被3除余1的，有c个被3除余2的。显然所有的被3整除的数都可以用。剩下两类的数字我们分别取多少呢？我们可以枚举一下配对的可能：前者的数目m可以是b,b-1,b-2，后者的数目n可以是c,c-1,c-2.配对成功的要求是```(1*m+2*n)%3==0```. 如果配对成功，我们自然取的是被3除余1的最大的m个数、被3除余2的最大的n个数。

#### 解法2：动态规划
令dp[i][j]表示前i个元素里能取到的最大的sum，使得sum被3除的余数是j。

对于dp[i][j]而言，针对nums[i]有两种决策：
1. 不取nums[i]，那么dp[i][j] = dp[i-1][j]
2. 取nums[i]，那么dp[i][j] = dp[i-1][(j-nums[i]%3+3)%3]+nums[i]

最终的答案就是dp[n-1][0]

$0
endsnippet

# ==> ./Dynamic_Programming/1262.Greatest-Sum-Divisible-by-Three/1262.Greatest-Sum-Divisible-by-Three.cpp <==
snippet 1262.Greatest-Sum-Divisible-by-Three "1262.Greatest-Sum-Divisible-by-Three" b
class Solution {
public:
    int maxSumDivThree(vector<int>& nums) 
    {
        vector<int>dp(3);
        dp[1] = INT_MIN;
        dp[2] = INT_MIN;

        for (int i=0; i<nums.size(); i++)
        {
            auto dp_temp = dp;
            for (int j=0; j<3; j++)
            {
                dp[j] = max(dp_temp[j], dp_temp[(j-nums[i]%3+3)%3]+nums[i]);
            }
        }
        return dp[0];
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/1269.Number-of-Ways-to-Stay-in-the-Same-Place-After-Some-Steps/Readme.md <==
snippet 1269.Number-of-Ways-to-Stay-in-the-Same-Place-After-Some-Steps "1269.Number-of-Ways-to-Stay-in-the-Same-Place-After-Some-Steps" b
### 1269.Number-of-Ways-to-Stay-in-the-Same-Place-After-Some-Steps

本题的DP状态很容易定义：dp[k][i]就表示第k步能达到第i个位置的方案数。并且状态转移方程也很容易写出来：
```cpp
      for (int k=1; k<=steps; k++)             
            for (int i=0; i<arrLen; i++)
            {
                dp[k][i] = dp[k-1][i-1]+dp[k-1][i+1]+dp[k-1][i];
            }
        }
```
但是查看数据范围后发现，```steps*arrLen```达到了1e8数量级，这两个循环是会超时的。

本题优化的技巧在于，题目只问了steps之后到达index=0的方案数，而并没有问到达任意index=i的方案数。再看到steps只有500，于是就能得到启发：我们并不关心位置大于steps/2的那些地方的状态，它们只有在steps/2时间之后才会被更新，而反馈影响给index=0又需要多于steps/2的时间，因此它们永远不会影响到dp[steps][0].本题的极限就是前steps/2不停向右，后steps/2不停向左，所以我们只需要在第二层循环更新到steps/2即可。

事实上，对于任意steps/2之后的t步，我们甚至不用更新steps/2的最后t个位置的状态。因为那些时刻那些位置的状态，永远也不能赶在steps这个时刻影响到index=0.

[Leetcode Link](https://leetcode.com/problems/number-of-ways-to-stay-in-the-same-place-after-some-steps)

$0
endsnippet

# ==> ./Dynamic_Programming/1269.Number-of-Ways-to-Stay-in-the-Same-Place-After-Some-Steps/1269.Number-of-Ways-to-Stay-in-the-Same-Place-After-Some-Steps.cpp <==
snippet 1269.Number-of-Ways-to-Stay-in-the-Same-Place-After-Some-Steps "1269.Number-of-Ways-to-Stay-in-the-Same-Place-After-Some-Steps" b
class Solution {
public:
    int numWays(int steps, int arrLen) 
    {
        int n = min(steps/2+2, arrLen);
        vector<long>dp(n);
        long M = 1e9+7;
        dp[0] = 1;
        for (int k=0; k<steps; k++)
        {
            auto dp2 = dp;
            for (int i=0; i<n; i++)
            {
                dp[i] = dp2[i] + (i>=1 ? dp2[i-1]:0) + (i+1<n ? dp2[i+1] : 0);
                dp[i] %= M;
            }
        }
        return dp[0];
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/1277.Count-Square-Submatrices-with-All-Ones/Readme.md <==
snippet 1277.Count-Square-Submatrices-with-All-Ones "1277.Count-Square-Submatrices-with-All-Ones" b
### 1277.Count-Square-Submatrices-with-All-Ones

此题和```222.Maximal Square```几乎是同一道题，本质就是求01矩阵里面，以(i,j)为右下角的正方形最大边长是多少。边长多大，就意味着以(i,j)为右下角的正方形能有多少个。

解这类题目有一个非常有名的动态转移方程，就是```dp[i][j] = min(dp[i-1][j-1],dp[i][j-1],dp[i-1][j])+1```.也就是说，以(i,j)为右下角的正方形能有多大，取决于：以(i-1,j)为右下角的最大正方形，以(i,j-1)为右下角的最大正方形，以(i-1,j-1)为右下角的最大正方形，这三者最小的那一个。这是动态规划题目里最经典的“非典型应用”，希望能够记牢。

注意第一行和第一列需要单独处理dp值。并且(0,0)元素不要重复计算。


[Leetcode Link](https://leetcode.com/problems/count-square-submatrices-with-all-ones)
$0
endsnippet

# ==> ./Dynamic_Programming/1277.Count-Square-Submatrices-with-All-Ones/1277.Count-Square-Submatrices-with-All-Ones.cpp <==
snippet 1277.Count-Square-Submatrices-with-All-Ones "1277.Count-Square-Submatrices-with-All-Ones" b
class Solution {
public:
    int countSquares(vector<vector<int>>& matrix) 
    {
        int m = matrix.size();
        int n = matrix[0].size();
        auto dp = vector<vector<int>>(m,vector<int>(n,0));

        int count = 0;
        for (int i=0; i<m; i++)
        {
            dp[i][0] = (matrix[i][0]==1);
            count += (matrix[i][0]==1);
        }
            
        for (int j=1; j<n; j++)
        {
            dp[0][j] = (matrix[0][j]==1);
            count += (matrix[0][j]==1);
        }

        for (int i=1; i<m; i++)
            for (int j=1; j<n; j++)
            {
                if (matrix[i][j]==0) continue;
                int k = min(dp[i-1][j], dp[i][j-1]);
                k = min(k, dp[i-1][j-1]);
                k += 1;
                dp[i][j] = k;
                count += k;                
            }
        return count;

    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/1278.Palindrome-Partitioning-III/Readme.md <==
snippet 1278.Palindrome-Partitioning-III "1278.Palindrome-Partitioning-III" b
### 1278.Palindrome-Partitioning-III

这是DP中一类典型问题的代表。题目会明确提到要分割为若干个（或者最多K个）连续子区间（subarray)，然后让你求这些区间的一些性质。

针对这种类型的套路是：设计dp[i][k]表示将s[0:i]分割为k个连续子区间能过够得到的性质。结合这道题的题意，就是指 the minimal number of characters that you need to change to divide the strings[0:i] into k subarrays.

转移方程的最外两层循环分别是遍历末尾元素i和分割的子区间个数k。转移方程中的突破点就是遍历搜索“最后一个”区间的位置！因此内部需要多一个循环来遍历j，这个j一定是在i之前，使得s[i:j]是最后一个区间。这样我们可以把dp[i][k]的问题分割成dp[i-1][k-1]和s[i:j]这两部分来考虑，而前者应该是已经求解过的子问题。
```cpp
          for (int i=1; i<=n; i++)
            for (int k=1; k<=min(i,K); k++)
            {
                dp[i][k] = INT_MAX;
                for (int j=k; j<=i; j++)
                {
                    dp[i][k] = min(dp[i][k], dp[j-1][k-1] + count[j][i]); 
                }
            }
```
其中count[j][i]表示对于区间s[j:i]我们需要多少次替换能够使其变成回文串。这个数可以用一个函数来实时计算，也可以提前用另一个DP算法处理好存在count里。这里就不细说了。

关于DP的初始化和边界条件，可以看出dp[0][0]需要特别处理，不难想到应该赋值为0.

$0
endsnippet

# ==> ./Dynamic_Programming/1278.Palindrome-Partitioning-III/1278.Palindrome-Partitioning-III.cpp <==
snippet 1278.Palindrome-Partitioning-III "1278.Palindrome-Partitioning-III" b
class Solution {
public:
    int palindromePartition(string s, int k) 
    {
        int n = s.size();
        s = "#"+s;
        int K = k;

        auto count = vector<vector<int>>(n+1, vector<int>(n+1,0));
        for (int i=1; i<=n; i++)
            count[i][i] = 0;
        for (int len=2; len <=n; len++)
            for (int i=1; i+len-1<=n; i++)
            {
                int j = i+len-1;
                if (s[i]==s[j])
                    count[i][j] = count[i+1][j-1];
                else
                    count[i][j] = count[i+1][j-1]+1;
            }

        auto dp = vector<vector<int>>(n+1, vector<int>(K+1,INT_MAX/2));
        dp[0][0] = 0;
        for (int i=1; i<=n; i++)
            for (int k=1; k<=min(i,K); k++)
            {
                dp[i][k] = INT_MAX;
                for (int j=k; j<=i; j++)
                {
                    dp[i][k] = min(dp[i][k], dp[j-1][k-1] + count[j][i]); 
                }
            }

        return dp[n][K];
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/1289.Minimum-Falling-Path-Sum-II/Readme.md <==
snippet 1289.Minimum-Falling-Path-Sum-II "1289.Minimum-Falling-Path-Sum-II" b
### 1289.Minimum-Falling-Path-Sum-II

此题和```265.Paint-House-II```本质上一模一样：每一行表示给一座房子涂颜色，每一列表示颜色的种类，arr[i][j]就是给某座房子涂某种油漆的代价，要求相邻的两座房子不能颜色相同。

状态变量很好定义，```dp[i][j]```就表示从第一行走到```(i,j)```的最小权重路径。显然走到```(i,j)```的关键就是前一行在哪个位置停留。当然，我们希望是在```dp[i-1][k] (k=0,1,2,3...,n-1)```里面值最小的那个位置。唯一的顾虑就是如果这个最小值的位置恰好与第j列相同的话，我们只能取的是次小值。

因为我们在更新第i行的dp值时，可以预先将第i-1行的dp值从小到大排个序。其中的最小值```Min```在大多数的时候，都是可以在计算dp[i][j]时共享的，即
```
dp[i][j] = Min + arr[i][j]
```
只有一处的j会和```Min```的列相同，那个时候dp[i][j]就该取次小值。


[Leetcode Link](https://leetcode.com/problems/minimum-falling-path-sum-ii)
$0
endsnippet

# ==> ./Dynamic_Programming/1289.Minimum-Falling-Path-Sum-II/1289.Minimum-Falling-Path-Sum-II.cpp <==
snippet 1289.Minimum-Falling-Path-Sum-II "1289.Minimum-Falling-Path-Sum-II" b
class Solution {
public:
    int minFallingPathSum(vector<vector<int>>& arr) 
    {
        int m = arr.size();
        int n = arr[0].size();
        
        auto dp = vector<vector<int>>(m,vector<int>(n));
        for (int j=0; j<n; j++)
            dp[0][j] = arr[0][j];
        
        for (int i=1; i<m; i++)
        {
            vector<pair<int,int>>temp;
            for (int k=0; k<n; k++)
                temp.push_back({dp[i-1][k], k});
            sort(temp.begin(), temp.end());
            
            for (int j=0; j<n; j++)
            {
                if (j!=temp[0].second)
                    dp[i][j] = temp[0].first + arr[i][j];
                else
                    dp[i][j] = temp[1].first + arr[i][j];
            }
        }
        
        int ret = INT_MAX;
        for (int j=0; j<n; j++)
            ret = min(ret, dp[m-1][j]);
        return ret;
            
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/1301.Number-of-Paths-with-Max-Score/Readme.md <==
snippet 1301.Number-of-Paths-with-Max-Score "1301.Number-of-Paths-with-Max-Score" b
### 1301.Number-of-Paths-with-Max-Score

此题仍然是经典的走迷宫的DP套路。只不过嵌套了两个DP小问题。第一个问题比较简单，设计状态变量dp[i][j]表示从右下角走到(i,j)位置的最大权重路径的权值和。大致的状态转移方程是
```
dp[i][j] = max(dp[i+1][j], dp[i][j+1], dp[i+1][j+1]) + board[i][j]-'0'
```
当然coding的过程中要查验这三个前驱状态是否都存在，也就是处理好边界的情况。

第二个问题和第一个问题息息相关。我们知道dp[i][j]代表了从右下角走到(i,j)位置的最大权重路径，其本质是在三个前驱状态```dp[i+1],dp[i][j+1],dp[i+1][j+1]```中取最大的那一个。假设这三个前驱状态中dp[i+1][j]最大，说明```(i,j)```要取得最大权值路径，必须要先使得```(i+1,j)```取得最大权值路径。因此，从右下角到```(i+1,j)```的最大权重路径的条数paths[i+1][j]，就对应了有相同多数目的从右下角到```(i,j)```的最大权重路径，也就是paths[i][j]。

特别的，如果三个前驱状态中有若干个并列最大的，那么paths[i][j]就是这些前驱状态```paths[i+1],paths[i][j+1],paths[i+1][j+1]```的加和。


[Leetcode Link](https://leetcode.com/problems/number-of-paths-with-max-score)
$0
endsnippet

# ==> ./Dynamic_Programming/1301.Number-of-Paths-with-Max-Score/1301.Number-of-Paths-with-Max-Score.cpp <==
snippet 1301.Number-of-Paths-with-Max-Score "1301.Number-of-Paths-with-Max-Score" b
class Solution {
public:
    vector<int> pathsWithMaxScore(vector<string>& board) 
    {
        int m = board.size();
        int n = board[0].size();
        auto dp = vector<vector<int>>(m,vector<int>(n,-1));
        auto paths = vector<vector<int>>(m,vector<int>(n,0));
        int M = 1e9+7;

        board[0][0] = '0';

        for (int i=m-1; i>=0; i--)
            for (int j=n-1; j>=0; j--)
            {
                if (i==m-1 && j==n-1)
                {
                    dp[i][j] = 0;
                    paths[i][j] = 1;
                    continue;
                }
                if (board[i][j]=='X')
                    continue;

                int right = -1, down = -1, diag = -1;
                if (j+1<n) right = dp[i][j+1];
                if (i+1<m) down = dp[i+1][j];
                if (i+1<m && j+1<n) diag = dp[i+1][j+1];
                dp[i][j] = max(max(right,down),diag);

                if (dp[i][j]==-1) continue;

                if (i+1<m && dp[i+1][j]!=-1 && dp[i][j]==down)
                    paths[i][j] = (paths[i][j]+paths[i+1][j])%M;
                if (j+1<n && dp[i][j+1]!=-1 && dp[i][j]==right)
                    paths[i][j] = (paths[i][j]+paths[i][j+1])%M;
                if (i+1<m && j+1<n && dp[i+1][j+1]!=-1 && dp[i][j]==diag)
                    paths[i][j] = (paths[i][j]+paths[i+1][j+1])%M;
                
                dp[i][j] += board[i][j]-'0';
            }
        return {dp[0][0]==-1?0:dp[0][0], paths[0][0]};
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/1312.Minimum-Insertion-Steps-to-Make-a-String-Palindrome/Readme.md <==
snippet 1312.Minimum-Insertion-Steps-to-Make-a-String-Palindrome "1312.Minimum-Insertion-Steps-to-Make-a-String-Palindrome" b
### 1312.Minimum-Insertion-Steps-to-Make-a-String-Palindrome

#### 解法1：
第一种方法是：我们将原数列s逆序得到t。本题的答案等同于求这两个字符串的shortest common supersequence (SCS)。

这个转换其实并不容易理解。我们只能大概地有一种直观的感受：因为s和t是逆序关系，s最后一个字符等于t的第一个字符，应该让s放置于t的前面，尽可能地重合s的尾部和t的头部来提高字符重用的利用效率。所以最终s和t的SCS应该是个回文串。既然SCS的第一个S是shortest的意思，那么这个SCS就是通过s可以得到的最短的回文串。

这么转换之后，本题就是```1092.Shortest-Common-Supersequence```.

#### 解法2：
另一种更容易理解和想到的方法是区间型DP：定义dp[i][j]表示区间s[i:j]变成回文串最少需要多少添加多少字符。状态转移方程很容易理解：
```cpp
if (s[i]==s[j])  
  dp[i][j]=dp[i+1][j-1]; 
else 
  dp[i][j] = min(dp[i+1][j]+1,dp[i][j-1]+1) 
  // 前者表示让s[i+1:j]已经成为回文串，再在s[j]后添加一个与s[i]相同的字符使得s[i:j]变成回文串
  // 前者表示让s[i:j-1]已经成为回文串，再在s[i]前添加一个与s[j]相同的字符使得s[i:j]变成回文串
```

[Leetcode Link](https://leetcode.com/problems/minimum-insertion-steps-to-make-a-string-palindrome)

$0
endsnippet

# ==> ./Dynamic_Programming/1312.Minimum-Insertion-Steps-to-Make-a-String-Palindrome/1312.Minimum-Insertion-Steps-to-Make-a-String-Palindrome.cpp <==
snippet 1312.Minimum-Insertion-Steps-to-Make-a-String-Palindrome "1312.Minimum-Insertion-Steps-to-Make-a-String-Palindrome" b
class Solution {
public:
    int minInsertions(string s) 
    {
        int n = s.size();
        auto dp = vector<vector<int>>(1+n,vector<int>(1+n,0));
        string t = s;
        reverse(t.begin(),t.end());
        s = "#"+s;
        t = "#"+t;
        
        for (int i=1; i<=n; i++)
        {
            dp[i][0] = i;
            dp[0][i] = i;
        }
        
        for (int i=1; i<=n; i++)
            for (int j=1; j<=n; j++)
            {
                if (s[i]==t[j])
                    dp[i][j] = dp[i-1][j-1]+1;
                else
                    dp[i][j] = min(dp[i-1][j]+1, dp[i][j-1]+1);
            }
        return dp[n][n] - n;
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/1316.Distinct-Echo-Substrings/Readme.md <==
snippet 1316.Distinct-Echo-Substrings "1316.Distinct-Echo-Substrings" b
### 1316.Distinct-Echo-Substrings

本题其实很简单。定义dp[i][j]表示以i结尾的substring和以j结尾的substring最长有多少字符是相同的。这是一个非常基础的动态规划。

如果发现dp[i][j]>=j-i，那么就说明text[i+1:j]就是符合要求的echo substring的一半。统计个数的时候我们再用一个set来去重就行。

$0
endsnippet

# ==> ./Dynamic_Programming/1316.Distinct-Echo-Substrings/1316.Distinct-Echo-Substrings.cpp <==
snippet 1316.Distinct-Echo-Substrings "1316.Distinct-Echo-Substrings" b
class Solution {
public:
    int distinctEchoSubstrings(string text) 
    {
        int n = text.size();
        text = "#"+text;
        auto dp = vector<vector<int>>(n+1, vector<int>(n+1,0));
        dp[0][0] = 0;
        unordered_set<string>Set;
        int count = 0;
        
        for (int i=1; i<=n; i++)
            for (int j=i+1; j<=n; j++)
            {
                if (text[i]==text[j])
                {
                    dp[i][j] = dp[i-1][j-1]+1;
                }
                if (dp[i][j] >= j-i )
                {
                    string str = text.substr(i+1, j-i);
                    if (Set.find(str)==Set.end())
                    {
                        count++;
                        Set.insert(str);
                    }
                }                
            }
        return count;
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/1320.Minimum-Distance-to-Type-a-Word-Using-Two-Fingers/Readme.md <==
snippet 1320.Minimum-Distance-to-Type-a-Word-Using-Two-Fingers "1320.Minimum-Distance-to-Type-a-Word-Using-Two-Fingers" b
### 1320.Minimum-Distance-to-Type-a-Word-Using-Two-Fingers

#### 解法1：
一个比较容易想到的方法就是将两个手指所处的位置作为状态。定义dp[k][i][j]表示第k轮的时候，左手在i、右手在j的min distance。注意，左手和右手必须至少有一个是在ch=word[k]上，否则这个dp状态就是无意义。

对于从第k-1轮到第k轮的状态转移过程，我们可以分为两类途径：一个是移动左手使之到ch上，得到新状态dp[k][ch][i]；另一个是移动右手使之到ch上，，得到新状态dp[k][i][ch]。其中i表示另一个手指的位置，可以是任意的地方。综上，我们有：
```cpp
            for (int i=0; i<26; i++)
                for (int j=0; j<26; j++)
                {
                    dp[k][i][ch] = min( dp[k][i][ch], dp[k-1][i][j] + dist(j, ch)); 
                }
            
            for (int i=0; i<26; i++)
                for (int j=0; j<26; j++)
                {
                    dp[k][ch][i] = min( dp[k][ch][i], dp[k-1][j][i] + dist(j, ch)); 
                }
```
最终的结果是在所有的dp[n-1][ch][i]和dp[n-1][i][ch]找最小的值。

#### 解法2：
上面的解法最大的缺点是dp[k][i][j]的存储效率不高，当i和j都不为ch=word[k]时，都是无意义的状态变量。也就是说，每一轮时的ch都是可以确定且必须存在的，我们因此可以省下这一个维度的空间。重新定义dp[k][i]：表示第k轮，（除了处于ch的那根手指）另外一根手指落在位置i时，需要的minimum distance.

这个时候我们思考如何更新dp[k][i].第k-1轮时，一个手指在prev=word[k-1]，另一个手指在x；第k轮时，一个手指在cur=word[k]，另一个手指在i. 同样有两种状态转移的可能：

第一种，通过prev转移到cur，那么就要求x必须等于i。因此有 dp[k][i] = dp[k-1][i]+dis(prev,cur)。

第二种，通过prev转移到i，那么就要求x等于cur。因此有 dp[k][i] = dp[k-1][cur]+dis(prev,i)。

所以dp[k][i]就是上述两种方法中的较小值。

最终的结果是在所有的dp[n-1][i]中找最小的值。这是因为我们一定已经保证了有一个手指位于word.back()。








[Leetcode Link](https://leetcode.com/problems/minimum-distance-to-type-a-word-using-two-fingers)
$0
endsnippet

# ==> ./Dynamic_Programming/1320.Minimum-Distance-to-Type-a-Word-Using-Two-Fingers/1320.Minimum-Distance-to-Type-a-Word-Using-Two-Fingers_v1.cpp <==
snippet 1320.Minimum-Distance-to-Type-a-Word-Using-Two-Fingers "1320.Minimum-Distance-to-Type-a-Word-Using-Two-Fingers" b
class Solution {
public:
    int minimumDistance(string word) 
    {        
        auto dp = vector<vector<vector<int>>>(301, vector<vector<int>>(26,vector<int>(26,INT_MAX/2)));
        int n = word.size();
        
        for (int i=0; i<26; i++)
        {
            dp[0][i][word[0]-'A'] = 0;
            dp[0][word[0]-'A'][i] = 0;
        }
        
        for (int k=1; k<word.size(); k++)
        {
            int ch = word[k]-'A';            
            for (int i=0; i<26; i++)
                for (int j=0; j<26; j++)
                {
                    dp[k][i][ch] = min(dp[k][i][ch], dp[k-1][i][j]+dis(j,ch));
                    dp[k][ch][j] = min(dp[k][ch][j], dp[k-1][i][j]+dis(i,ch));                    
                }
        }
        
        int ret = INT_MAX;
        for (int i=0; i<26; i++)
        {
            ret = min(ret, dp[n-1][i][word.back()-'A']);
            ret = min(ret, dp[n-1][word.back()-'A'][i]);
        }
        return ret;            
    }
    
    int dis(int a, int b)
    {
        if (a==26) return 0;
        int x1 = a/6;
        int y1 = a%6;
        int x2 = b/6;
        int y2 = b%6;
        return abs(x1-x2)+abs(y1-y2);
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/1320.Minimum-Distance-to-Type-a-Word-Using-Two-Fingers/1320.Minimum-Distance-to-Type-a-Word-Using-Two-Fingers_v2.cpp <==
snippet 1320.Minimum-Distance-to-Type-a-Word-Using-Two-Fingers "1320.Minimum-Distance-to-Type-a-Word-Using-Two-Fingers" b
class Solution {
public:
    int minimumDistance(string word) 
    {            
        int n = word.size();
        auto dp = vector<vector<int>>(n,vector<int>(26,INT_MAX/2));
        
        for (int i=0; i<26; i++)        
            dp[0][i] = 0;
        
        for (int k=1; k<n; k++)
        {
            int cur = word[k]-'A';
            int prev = word[k-1]-'A';

            for (int i=0; i<26; i++)
            {
                dp[k][i] = min(dp[k][i], dp[k-1][i]+dis(prev,cur));                
                dp[k][i] = min(dp[k][i], dp[k-1][cur]+dis(prev,i));
            }
        }
                
        int ret = INT_MAX;
        for (int i=0; i<26; i++)
            ret = min(ret, dp[n-1][i]);
        return ret;
    }
    
    int dis(int a, int b)
    {
        if (a==26) return 0;
        int x1 = a/6;
        int y1 = a%6;
        int x2 = b/6;
        int y2 = b%6;
        return abs(x1-x2)+abs(y1-y2);
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/1335.Minimum-Difficulty-of-a-Job-Schedule/Readme.md <==
snippet 1335.Minimum-Difficulty-of-a-Job-Schedule "1335.Minimum-Difficulty-of-a-Job-Schedule" b
### 1335.Minimum-Difficulty-of-a-Job-Schedule

本题翻译成人话就是：将数组分成d个subarray，最小化“每个subarray最大值的和”。

因为题意明确要求分成若干个subarray，这非常强烈地暗示了这是我所归纳的第一类区间型DP解法。具体的状态定义就是dp[i][k]代表将前i个工作分配在k天内完成的最优
解（即最小化“每个subarray最大值的和”）。状态转移的核心就是判断最后一个subarray的起始点在哪里，找到最优的下标j，使得dp[i][k]分解为dp[j-1][k-1]和arr[j:i]两个子问题，然后相加。

本题中，处理arr[j:i]所需要做的就是找到其中的最大值。所以我们将j从后往前搜索比较方便，可以顺便将这个arr[j:i]区间内的最大值给一路更新了。

整体的时间复杂度就是o(NND).

$0
endsnippet

# ==> ./Dynamic_Programming/1335.Minimum-Difficulty-of-a-Job-Schedule/1335.Minimum-Difficulty-of-a-Job-Schedule.cpp <==
snippet 1335.Minimum-Difficulty-of-a-Job-Schedule "1335.Minimum-Difficulty-of-a-Job-Schedule" b
class Solution {
public:
    int minDifficulty(vector<int>& jobDifficulty, int d) 
    {
        int n = jobDifficulty.size();
        jobDifficulty.insert(jobDifficulty.begin(),0);
        auto dp = vector<vector<int>>(n+1, vector<int>(d+1, INT_MAX/2));
        
        dp[0][0] = 0;
          
        for (int i=1; i<=n; i++)
            for (int k=1; k<=min(d,i); k++)
            {
                int mx = jobDifficulty[i];
                for (int j=i; j>=k; j--)
                {
                    mx = max(mx, jobDifficulty[j]);
                    dp[i][k] = min(dp[i][k], dp[j-1][k-1]+mx);
                }
            }

        if (dp[n][d]>=INT_MAX/2) return -1;
        else return dp[n][d];            
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/1349.Maximum-Students-Taking-Exam/Readme.md <==
snippet 1349.Maximum-Students-Taking-Exam "1349.Maximum-Students-Taking-Exam" b
### 1349.Maximum-Students-Taking-Exam

本题如果用DFS来做的话会TLE。如果充分利用row的状态来做DP的话，可以节省很多不必要的重复搜索。举个例子来说，第四排如何安排，完全仅仅取决于第三排是怎么安排的，第一和第二排对其而言并没有直接的影响。如果你是搜索算法的话，可能发现有非常多第一和第二排的不同策略，但是对应的第三排的策略可以是相同的。这样的话，如果强制走遍每一种“row1-row2-row3-row4”的组合才能确定row4的计数的话，就很不经济。

所以我们设计dp[i][s]表示将第i行安排成状态s时，前i行最多能安排多少人。s是一个8bit的整型数字就足以代表每一个行的策略（每个bit表示该位置是否坐人），范围就是[0,255]。对于dp[i][s]，我们只需要遍历所有的dp[i-1][t]（表示第i-1行安排成状态t的策略），查看s本身是否合法，以及策略s能否接在策略t后面。都满足的话，那么dp[i][s]及可以更新为dp[i-1][t]+count(s)，其中count(s)表示第i行安排策略s所对应的该行的人数。

输出的答案是你在生成所有dp[i][s]过程中最大的那个。注意，不一定是dp[M-1][s]中最大的那个。


[Leetcode Link](https://leetcode.com/problems/maximum-students-taking-exam)
$0
endsnippet

# ==> ./Dynamic_Programming/1349.Maximum-Students-Taking-Exam/1349.Maximum-Students-Taking-Exam.cpp <==
snippet 1349.Maximum-Students-Taking-Exam "1349.Maximum-Students-Taking-Exam" b
class Solution {
    int M,N,T;
public:
    int maxStudents(vector<vector<char>>& seats) 
    {
        M = seats.size();
        N = seats[0].size();
        T = (1<<N);
        vector<int>dp(T,0); 
        // dp[i]: until the current row, how many students at most we can host 
        // given the current row follows pattern "i"
      
        for (int p=0; p<T; p++)
        {
            if (selfOK(p, seats, 0))
                dp[p] = count(p);
        }
  
        for (int row = 1; row < M; row++)
        {
            auto dp2 = dp;
            for (int cur = 0; cur < T; cur++)
            {
                dp[cur] = 0;
                if (!selfOK(cur, seats, row)) continue;
                for (int prev = 0; prev < T; prev++)
                {
                    if (row==2 && cur==18 && prev==0) cout<<crossOK(cur,prev)<<" "<<dp2[prev]<<endl;
                    if (!selfOK(prev, seats, row-1)) continue;
                    if (!crossOK(cur, prev)) continue;
                    dp[cur] = max(dp[cur], count(cur) + dp2[prev]);
                }
            }
        }
        
        int ret = 0;
        for (int p = 0; p < T; p++)
        {
            if (!selfOK(p, seats, M-1)) continue;
            ret = max(ret, dp[p]);
        }
        return ret;
    }
    
    bool selfOK(int p, vector<vector<char>>& seats, int row)
    {
        vector<int>temp;
        for (int i=0; i<N; i++)
        {
            temp.push_back(p%2);
            p/=2;
        }
        for (int i=0; i<N; i++)
        {
            if (seats[row][i]=='#' && temp[i]==1)
                return false;
            if (i>=1 && temp[i]==1 && temp[i-1]==1)
                return false;
        }
        return true;     
    }
    
    bool crossOK(int cur, int prev)
    {
        vector<int>p1, p2;
        for (int i=0; i<N; i++)
        {
            p1.push_back(cur%2);
            p2.push_back(prev%2);
            cur/=2;
            prev/=2;
        }
        for (int i=0; i<N; i++)
        {
            if (p1[i]==0) continue;
            if (i-1>=0 && p2[i-1]==1) return false;
            if (i+1<N && p2[i+1]==1) return false;  
        }
        return true;     
    }
    
    int count(int p)
    {        
        int ret=0;
        while (p>0)
        {
            ret+=(p%2);
            p=p/2;
        }
        return ret;
    }
    
};


$0
endsnippet

# ==> ./Dynamic_Programming/1363.Largest-Multiple-of-Three/Readme.md <==
snippet 1363.Largest-Multiple-of-Three "1363.Largest-Multiple-of-Three" b
### 1363.Largest-Multiple-of-Three

#### 解法1：数学
如果所有的数字和加起来能被3整除，那么我们必然会选择所有的数字。

如果所有的数字和加起来能被3除余1，那么我们必然会优先删除最小的一个被3除余1的数字。如果这个方法不存在，那么我们会删除最小的两个被3除余2的数字。

如果所有的数字和加起来能被3除余2，那么我们必然会优先删除最小的一个被3除余2的数字。如果这个方法不存在，那么我们会删除最小的两个被3除余1的数字。

#### 解法2：动态规划
此题和```1262.Greatest-Sum-Divisible-by-Three```非常相似，因此我们同样可以用动态规划来解决。在这里我们定义dp[i][j]表示前i个数字能组成的、被3除余j的最大字符串。此外我们还需要将digits按照从大到小的顺序排序。这样对于相同长度、余数相同的字符串，所选字符在digits里越靠前（即用了更大的字符），组成的字符串就越大。

状态转移返程的入手点依然是第i个元素是否采用。如果不采用，那么```dp[i][j]=dp[i-1][j]```. 如果采用，那么```dp[i][j] = dp[i-1][j-digits[i]%3+3)%3] + to_string(digits[i])```.那么这两种方案哪个更优呢？显然长度更长的字符串更优。但是如果长度相同呢？答案是前者更优。因为相同长度的两个字符串，前者用了更大的字符，而后者因为用了digits[i]必然会更小。

最后的答案是dp[n][0]。

#### 解法3：改进
解法2中的dp[i][j]会存储大量的字符串，效率很低。事实上我们不需要把每个状态(i,j)对应的字符串都存下来。我们只需要知道两个信息就能重构整个字符串：
1. 考察(i,j)的最优解时，我们是否采用digits[i]?
2. 考察(i,j)的最优解时，我们是从哪个状态跳转过来的？也就是它的前驱状态是(i-1,?)

如果记录下这两个信息（分别定义为pick[i][j]和prev[i][j]），所以我们只要从i=n, j=0开始，按i的递减顺序一步一步往前逆推我们的决策。对于(i,j)，pick[i][j]告诉我们是否选择了digits[i]；prev[i][j]则告诉我们(i,j)是从(i-1, prev[i][j])跳转过来的，所以我们下一回要更新i=i-1, j=prev[i][j]。直至回推到i=1为止。

$0
endsnippet

# ==> ./Dynamic_Programming/1363.Largest-Multiple-of-Three/1363.Largest-Multiple-of-Three_v1.cpp <==
snippet 1363.Largest-Multiple-of-Three "1363.Largest-Multiple-of-Three" b
class Solution {    
public:
    string largestMultipleOfThree(vector<int>& digits) 
    {
        sort(digits.begin(), digits.end());
        reverse(digits.begin(), digits.end());

        int n = digits.size();
        digits.insert(digits.begin(), 0);
        
        string dp[n+1][3];
        dp[0][0] = "", dp[0][1] = "#", dp[0][2] = "#";
        
        for (int i=1; i<=n; i++)        
            for (int j=0; j<3; j++)
            {                
                if (dp[i-1][j]=="#" && dp[i-1][(j-digits[i]%3+3)%3]=="#")
                {
                    dp[i][j] = "#";
                }
                else if (dp[i-1][j]=="#")
                {
                    dp[i][j] = dp[i-1][(j-digits[i]%3+3)%3] + to_string(digits[i]);
                }
                else if (dp[i-1][(j-digits[i]%3+3)%3]=="#")
                {
                    dp[i][j] = dp[i-1][j];
                }
                else if (dp[i-1][j].size() >= dp[i-1][(j-digits[i]%3+3)%3].size()+1)
                {
                    dp[i][j] = dp[i-1][j];
                }
                else
                {
                    dp[i][j] = dp[i-1][(j-digits[i]%3+3)%3] + to_string(digits[i]);
                }
            }

        string ret = dp[n][0];
        if (ret[0]=='0')
            return "0";
        else
            return ret;
    }

};


$0
endsnippet

# ==> ./Dynamic_Programming/1363.Largest-Multiple-of-Three/1363.Largest-Multiple-of-Three_v2.cpp <==
snippet 1363.Largest-Multiple-of-Three "1363.Largest-Multiple-of-Three" b
class Solution {    
public:
    string largestMultipleOfThree(vector<int>& digits) 
    {
        sort(digits.begin(), digits.end());
        reverse(digits.begin(), digits.end());

        int n = digits.size();
        digits.insert(digits.begin(), 0);
        
        int dp[n+1][3];
        int prev[n+1][3];
        int pick[n+1][3];
        dp[0][0] = 0, dp[0][1] = INT_MIN, dp[0][2] = INT_MIN;
        
        for (int i=1; i<=n; i++)        
            for (int j=0; j<3; j++)
            {                
                if (dp[i-1][j] >= dp[i-1][(j-digits[i]%3+3)%3]+1)
                {
                    dp[i][j] = dp[i-1][j];
                    prev[i][j] = j;
                    pick[i][j] = 0;
                }
                else
                {
                    dp[i][j] = dp[i-1][(j-digits[i]%3+3)%3]+1;
                    prev[i][j] = (j-digits[i]%3+3)%3;
                    pick[i][j] = 1;
                }
            }

        int j = 0;
        string ret;
        for (int i=n; i>=1; i--)
        {
            if (pick[i][j])
                ret += '0'+digits[i];
            j = prev[i][j];
        }

        reverse(ret.begin(), ret.end());
        if (ret[0]=='0')
            return "0";
        else
            return ret;
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/1388.Pizza-With-3n-Slices/Readme.md <==
snippet 1388.Pizza-With-3n-Slices "1388.Pizza-With-3n-Slices" b
### 1388.Pizza-With-3n-Slices

此题的条件和```213.House-Robber-II```非常相似：永远不能取相邻的两个元素；首尾元素认为是相邻的。此外，本题隐含着领一个条件：最多只能取n/3个元素。

当然，我们需要验证一下，是不是任意的n/3个互不相邻的元素集合，都可以按照题目中的取数规则来实现。事实上是可以的。例如```1000101010000```，有13个元素。其中1代表我们打算取的数。我们永远先取较为外层的数（随之删去左右相邻的两个零）：原序列可以得到```0010101000```，接下来```0101000```，接下来```1000```，最后```0```.虽然严格的证明不太容易，但是这个规律还是容易发现的。

因此，本题就是House-Robber-II再加上取n/3个元素的条件。

对于处理首尾相接不能共存的问题，有着比较固定的解题套路：因为首尾不能共存，要么首元素不能取，要么尾元素不能取。前者就等效于考虑nums[1]~nums[n-1]的House Robber I，后者就是考虑nums[0]~nums[n-2]的House Robber I. 所以我们要做两道题，然后取较大的结果，即：
```
max( helper(0, n-2, n/3), helper(1,n-1,n/3) )
```

那么如何在helper函数里处理“取n/3个元素”的条件呢？那就是在dp状态上再加上一维。定义
```
f[t][i]: the maximum gain by the t-th round if we take i slices, AND for the t-th slice we do take it.
g[t][i]: the maximum gain by the t-th round if we take i slices, AND for the t-th slice we do NOT take it.
```
显然我们容易对照House Robber系列写出状态转移方程：
```
f[t][i] = g[t-1][i-1]+slices[t];
g[t][i] = max(f[t-1][i], g[t-1][i]);
```
和House Robber II对比一下，那道题不关心之前到底抢过几家，只关心总收益。而这里则需要加上“已经取的个数”的信息，因为这轮取了i个，说明之前一轮只能取i-1个，我们关心这个是因为最终总数不能超过n/3。

$0
endsnippet

# ==> ./Dynamic_Programming/1388.Pizza-With-3n-Slices/1388.Pizza-With-3n-Slices.cpp <==
snippet 1388.Pizza-With-3n-Slices "1388.Pizza-With-3n-Slices" b
class Solution {
public:
    int maxSizeSlices(vector<int>& slices) 
    {
        int n = slices.size();
        return max(helper(0, n-2, n/3, slices), helper(1,n-1, n/3, slices));
    }
    
    int helper(int st, int en, int k, vector<int>& slices)
    {
        vector<int>f(k+1,0); // f[i]: the maximum gain by the current round if we take i slices, and we do take the current slice.
        vector<int>g(k+1,0); // g[i]: the maximum gain by the current round if we take i slices, and we do NOT take the current slice.
        
        for (int i=st; i<=en; i++)
            for (int j=min(k,i-st+1); j>=1; j--)
            {
                g[j] = max(g[j], f[j]);
                f[j] = g[j-1] + slices[i];                                
            }
        
        return max(f[k], g[k]);        
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/1411.Number-of-Ways-to-Paint-N×3-Grid/Readme.md <==
snippet 1411.Number-of-Ways-to-Paint-N×3-Grid "1411.Number-of-Ways-to-Paint-N×3-Grid" b
### 1411.Number-of-Ways-to-Paint-N×3-Grid

#### 解法1：
此题和```1349.Maximum Students Taking Exam```很相似。第i行的喷涂方法只受第i-1行喷涂方法的约束。所以是第I类基本型的DP问题。

考虑到每一行的喷涂方法就只有3^3=27种，是可以枚举过来的。我们可以利用状态压缩的思想，用一个小于27的整数来代表一种喷涂方法。

我们定义dp[i][p]表示当第i行喷涂p方案时，前i行整体的喷涂方案总数。于是
```
dp[i][p] = sum(dp[i-1][q])
```
其中q就是第i-1行的喷涂方案，要求q与p不冲突，且q和p都是合法的。

最终的答案是最后一行所有合法喷涂方案p对应的dp值的总和。

#### 解法2：
另外一种解法就要费神一些。设计状态color2表示第i行喷涂两种颜色时（整体）的方案总数；color3表示第i行喷涂三种颜色时（整体）的方案总数。

假设某一行喷涂两种颜色，可以用ABA表示。那么如果下一行也是喷涂两种颜色，只可能是如下模式：BAB, BCB, CAC. 如果下一行喷涂三种颜色，只可能是如下模式：BAC, CAB.

假设某一行喷涂三种颜色，可以用ABC表示。那么如果下一行也是喷涂两种颜色，只可能是如下模式：BAB, BAB. 如果下一行喷涂三种颜色，只可能是如下模式：BCA, CAB.

于是我们可以得到行与行之间的状态转移方程：
```
color2 = 3*color2' + 2*color3'
color3 = 2*color2' + 2*color3'
```

$0
endsnippet

# ==> ./Dynamic_Programming/1411.Number-of-Ways-to-Paint-N×3-Grid/1411.Number-of-Ways-to-Paint-N×3-Grid_v1.cpp <==
snippet 1411.Number-of-Ways-to-Paint-N×3-Grid "1411.Number-of-Ways-to-Paint-N×3-Grid" b
class Solution {
public:
    int numOfWays(int n) 
    {
        long colors2 = 6, colors3 = 6;
        long M = 1e9+7;
        
        for (int i=1; i<n; i++)
        {
            long temp2 = colors2, temp3 = colors3;
            colors2 = ((3*temp2)%M + (2*temp3)%M)%M;
            colors3 = ((2*temp2)%M + (2*temp3)%M)%M;
        }
        
        return (colors2+colors3)%M;
        
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/1411.Number-of-Ways-to-Paint-N×3-Grid/1411.Number-of-Ways-to-Paint-N×3-Grid_v2.cpp <==
snippet 1411.Number-of-Ways-to-Paint-N×3-Grid "1411.Number-of-Ways-to-Paint-N×3-Grid" b
class Solution {
    vector<int>temp1, temp2;
public:
    int numOfWays(int n) 
    {
        vector<int>dp(27,0);
        int M = 1e9+7;
        temp1.resize(3);
        temp2.resize(3);
        
        for (int p=0; p<27; p++)
        {
            if (selfOK(p))
                dp[p] = 1;
        }

        for (int i=1; i<n; i++)
        {
            auto dp_prev = dp;
            for (int p=0; p<27; p++)
            {
                dp[p] = 0;
                if (!selfOK(p)) continue;
                for (int q=0; q<27; q++)
                {
                    if (!selfOK(q)) continue;
                    if (crossOK(p,q))
                        dp[p] = (dp[p]+dp_prev[q])%M;
                }
            }
        }
        
        int sum = 0;
        for (int p=0; p<27; p++)
        {
            if (selfOK(p))
                sum = (sum+dp[p])%M;
        }
        return sum;
        
    }
    
    bool selfOK(int p)
    {
        for (int i=0; i<3; i++)
        {
            temp1[i] = (p%3);
            p/=3;
        }
        return (temp1[0]!=temp1[1] && temp1[1]!=temp1[2]);
    }
    
    bool crossOK(int p, int q)
    {
        
        for (int i=0; i<3; i++)
        {
            temp1[i] = (p%3);
            temp2[i] = (q%3);
            p/=3;
            q/=3;
        }
        return (temp1[0]!=temp2[0] && temp1[1]!=temp2[1] && temp1[2]!=temp2[2]);
    }
    
};

$0
endsnippet

# ==> ./Dynamic_Programming/1416.Restore-The-Array/Readme.md <==
snippet 1416.Restore-The-Array "1416.Restore-The-Array" b
### 1416.Restore-The-Array

令dp[i]表示以第i个数字结尾的array有多少种。我们考察最后一个number是什么？显然只需要遍历最后一个number的范围s[j:i]（最多不超过10个digit）。只要s[j:i]符合题目的要求（没有leading zero、在[1,k]之间），那么就可以更新```dp[i]+=dp[j-1]```.

$0
endsnippet

# ==> ./Dynamic_Programming/1416.Restore-The-Array/1416.Restore-The-Array.cpp <==
snippet 1416.Restore-The-Array "1416.Restore-The-Array" b
class Solution {
    int dp[100001];
    long long M = 1e9+7;
public:
    int numberOfArrays(string s, int k) 
    {
        int n = s.size();
        s = "#"+s;        
        dp[0] = 1;
        
        for (int i=1; i<=n; i++)
        {
            long long x = 0;
            for (int j=0; j<10; j++)
            {
                if (i-j<=0) break;
                x = x + pow(10,j)*(s[i-j]-'0');
                if (x>k) break;
                if (x==0) continue;
                if (j>0 && s[i-j]=='0') continue;                
                dp[i] = (dp[i]+dp[i-j-1]) % M;                
            }
        }
        return dp[n];        
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/1419.Minimum-Number-of-Frogs-Croaking/Readme.md <==
snippet 1419.Minimum-Number-of-Frogs-Croaking "1419.Minimum-Number-of-Frogs-Croaking" b
### 1419.Minimum-Number-of-Frogs-Croaking

本题是说最多有多少个青蛙在并行地叫。

我们定义状态c表示当前有多少只青蛙刚喊完'c'，状态r表示当前有多少只青蛙刚喊完'r'，状态o表示当前有多少只青蛙刚喊完'o'，状态a表示当前有多少只青蛙刚喊完'a'. 每一轮，如果我们遇到的是字母r，就意味着状态c的青蛙数减一，而状态r的青蛙数就加一。同理遇到其他字母时类似地处理。任何一轮时，c+r+o+a的总和就表示着有多少只青蛙没有喊完，他们必然都是并行存在的。

另外，此题要求结束时c+r+o+a必须等于零，否则说明这个序列不是完整的青蛙叫，需要返回-1.

$0
endsnippet

# ==> ./Dynamic_Programming/1419.Minimum-Number-of-Frogs-Croaking/1419.Minimum-Number-of-Frogs-Croaking.cpp <==
snippet 1419.Minimum-Number-of-Frogs-Croaking "1419.Minimum-Number-of-Frogs-Croaking" b
class Solution {
public:
    int minNumberOfFrogs(string croakOfFrogs) 
    {
        int c=0, r=0, o=0, a=0;
        int ret = 0;
        for (auto ch: croakOfFrogs)
        {
            if (ch=='c')
                c++;
            else if (ch=='r')
            {
                c--;
                r++;
                if (c<0) return -1;
            }
            else if (ch=='o')
            {
                r--;
                o++;
                if (r<0) return -1;
            }
            else if (ch=='a')
            {
                o--;
                a++;
                if (o<0) return -1;
            }
            else if (ch=='k')
            {
                a--;
                if (a<0) return -1;
            }
            ret = max(ret, c+r+o+a);
        }
        
        if (c+r+o+a>0) return -1;
        
        return ret;
    }
};

// c-- r++

$0
endsnippet

# ==> ./Dynamic_Programming/1420.Build-Array-Where-You-Can-Find-The-Maximum-Exactly-K-Comparisons/Readme.md <==
snippet 1420.Build-Array-Where-You-Can-Find-The-Maximum-Exactly-K-Comparisons "1420.Build-Array-Where-You-Can-Find-The-Maximum-Exactly-K-Comparisons" b
### 1420.Build-Array-Where-You-Can-Find-The-Maximum-Exactly-K-Comparisons

乍看没有头绪，不妨将题目中的三个变量都作为dp状态变量的下标试一下。第一版本是：dp[i][j][k]表示对于前i个元素、当nums[i]等于j、总共用了k次cost时，总共有多少种方案。

我们试图来转移dp[i][j][k]到前一个状态dp[i-1][?][?]。考虑假设我们在处理第i个元素的时候动用了一次cost，那么意味着前i-1个元素必须都小于j。但是我们的dp设计里并没有这样的信息。dp[i-1][j'][k-1]中的j'表示的仅仅是nums[i]==j'，没有合适的状态来表示前i-1个元素的最大值。

所以我们容易想到并改进得到第二个版本：dp[i][j][k]表示对于前i个元素、最大值等于j、总共用了k次cost时，总共有多少种方案。

同样，考虑假设我们在处理第i个元素的时候新增一次cost，那么意味着nums[i]就是前i个元素的最大值，即是j。于是我们需要前i-1个元素的最大值小于j就可以了。因此有dp[i][j][k] = dp[i-1][j'][k-1]，其中j'=1,2,...,j-1.

考虑假设我们在处理第i个元素的时候没有新增一次cost，那么意味着nums[i]并不是前i个元素的最大值，因此nums[i]的取值可以是1,2,..j. 而对于前i-1个元素的最大值则必须是j。因此有dp[i][j][k] = dp[i-1][j][k]*j.

这里根据加法原理，dp[i][j][k]应该是上面两种情况之和。

最后的答案是dp[n-1][j][k], j=1,2,..m 的总和。

$0
endsnippet

# ==> ./Dynamic_Programming/1420.Build-Array-Where-You-Can-Find-The-Maximum-Exactly-K-Comparisons/1420.Build-Array-Where-You-Can-Find-The-Maximum-Exactly-K-Comparisons.cpp <==
snippet 1420.Build-Array-Where-You-Can-Find-The-Maximum-Exactly-K-Comparisons "1420.Build-Array-Where-You-Can-Find-The-Maximum-Exactly-K-Comparisons" b
class Solution {
public:
    int numOfArrays(int n, int m, int k) 
    {
        int K = k;
        long dp[n][K+1][m+1];
        long M = 1e9+7;
        
        for (int i=0; i<n; i++)
            for (int k=0; k<=K; k++)
                for (int j=1; j<=m; j++)
                    dp[i][k][j] = 0;
        
        for (int j=1; j<=m; j++)
        dp[0][1][j] = 1;
        
        for (int i=1; i<n; i++)
            for (int k=1; k<=K; k++)
                for (int j=1; j<=m; j++)
                {   
                    dp[i][k][j] = 0;
                    for (int t=1; t<j; t++)
                        dp[i][k][j] = (dp[i][k][j] + dp[i-1][k-1][t])%M;
                    
                    dp[i][k][j] = (dp[i][k][j] + dp[i-1][k][j] * j)%M;                                        
                }
        
        
        long ret = 0;
        for (int j=1; j<=m; j++)
            ret = (ret + dp[n-1][k][j])%M;
        
        return ret;
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/1434.Number-of-Ways-to-Wear-Different-Hats-to-Each-Other/Readme.md <==
snippet 1434.Number-of-Ways-to-Wear-Different-Hats-to-Each-Other "1434.Number-of-Ways-to-Wear-Different-Hats-to-Each-Other" b
### 1434.Number-of-Ways-to-Wear-Different-Hats-to-Each-Other

这道题是一道典型的背包+状态压缩的DP问题。

最初的想法是将帽子作为状态。也就是用一串01向量来表示第i顶帽子是否被人taken了。大致的算法是:
```cpp
for (int p=0; person < n; person++)
  for (int state = 000...000; state <= 111..111; state++)
  {
      for (int hat : HatsForThisPerson[p])
      {
          if (hat has been taken in state)
            continue;
          dp_new[state + hat] += dp[state]
      }
  }
```
最终的答案是在所有的state里面找出那些恰好有10个1的那些，取这些dp[state]的和。

但是这个方法有两大问题。首先state太大，有2^40种，第二层循环太复杂。其次，最终的答案要取C(40,10)种可能，也不实际。

比较巧妙的思路是看到人的数量最多只有10，用它来做状态非常合适。我们改定义为：用一串01向量来表示第i个人是否已经take苗子了。大致的算法是：
```cpp
for (int h = 0; h < 40; h ++)
  for (int state = 000...000; state <= 111..111; state++)
  {
      for (int person : PersonsForThisHat[h])
      {
          if (person has taken hat in state)
            continue;
          dp_new[state + person] += dp[state]
      }
  }
```
最终的答案就是dp[111...111]

$0
endsnippet

# ==> ./Dynamic_Programming/1434.Number-of-Ways-to-Wear-Different-Hats-to-Each-Other/1434.Number-of-Ways-to-Wear-Different-Hats-to-Each-Other.cpp <==
snippet 1434.Number-of-Ways-to-Wear-Different-Hats-to-Each-Other "1434.Number-of-Ways-to-Wear-Different-Hats-to-Each-Other" b
class Solution {
public:
    int numberWays(vector<vector<int>>& hats) 
    {
        int n = hats.size();
        vector<long>dp(1<<n, 0);
        long M = 1e9+7;
        
        unordered_map<int, vector<int>>PersonsForThisHat;
        for (int i=0; i<hats.size(); i++)
            for (int j=0; j<hats[i].size(); j++)
                PersonsForThisHat[hats[i][j]].push_back(i);
        
        dp[0] = 1;
                
        for (int hat =1; hat <=40; hat++)
        {
            auto dp_new = dp; // dp_new = 000000000
            for (int state = 0; state<(1<<n); state++)
            {
                for (int person: PersonsForThisHat[hat])
                {
                    if (((state>>person)&1)==1)
                        continue;
                    dp_new[state+(1<<person)] += dp[state];
                    dp_new[state+(1<<person)] %= M;
                } 
            }   
            
            dp = dp_new;
        }
        
        return dp[(1<<n)-1];
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/1449.Form-Largest-Integer-With-Digits-That-Add-up-to-Target/Readme.md <==
snippet 1449.Form-Largest-Integer-With-Digits-That-Add-up-to-Target "1449.Form-Largest-Integer-With-Digits-That-Add-up-to-Target" b
### 1449.Form-Largest-Integer-With-Digits-That-Add-up-to-Target

这是一道有点类似完全背包的DP问题。

令dp[cap]表示使用总分为cap所能得到的最优解（即最大的数字的字符串形式）。突破口是考察最后一个数字i是什么。我们遍历i的可能性：只要cap>=cost[i]，那么dp[cap]就可以由dp[cap-cost[i]]追加数字i转化而来。我们在所有的i中，找一个能使dp[cap]最大的解。注意，这里的“最大解”，在字符串意义而言，首先是越长越好，其次是相同长度下字典序越大越好。

注意体会这和01背包问题解法的不同。01背包问题的外循环是遍历物品，内循坏是遍历容量。每考虑一件物品，更新所有的dp[cap]。

相反，完全背包问题的外循环是遍历容量，内循环是遍历（最后一次使用的）物品。每考虑一个容量cap，搜索最优的dp[cap].

$0
endsnippet

# ==> ./Dynamic_Programming/1449.Form-Largest-Integer-With-Digits-That-Add-up-to-Target/1449.Form-Largest-Integer-With-Digits-That-Add-up-to-Target.cpp <==
snippet 1449.Form-Largest-Integer-With-Digits-That-Add-up-to-Target "1449.Form-Largest-Integer-With-Digits-That-Add-up-to-Target" b
class Solution {
    string dp[5001];
public:
    string largestNumber(vector<int>& cost, int target) 
    {
        cost.insert(cost.begin(),0);
        for (int cap=1; cap<=target; cap++)
            dp[cap] = "#";
        for (int cap = 1; cap <= target; cap++)        
        {
            for (int i=1; i<=9; i++)
            {
                if (cap < cost[i]) continue;
                if (dp[cap-cost[i]]=="#") continue;
                string temp = dp[cap-cost[i]] + to_string(i);
                if (temp.size() > dp[cap].size() || temp.size()==dp[cap].size() && temp > dp[cap])
                    dp[cap] = temp;
            }
            // cout<<cap<<":"<<dp[cap]<<endl;
        }
        if (dp[target]=="#")
            return "0";
        else
            return dp[target];
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/1458.Max-Dot-Product-of-Two-Subsequences/Readme.md <==
snippet 1458.Max-Dot-Product-of-Two-Subsequences "1458.Max-Dot-Product-of-Two-Subsequences" b
### 1458.Max-Dot-Product-of-Two-Subsequences

这是一道典型的双序列型的DP。令dp[i][j]表示A序列的前i个元素、B序列的前j个元素，可以得到的最大点乘结果。突破口就是看A[i]和B[j]。

1. A[i]和B[j]组成一对，那么dp[i][j] = dp[i-1][j-1]+A[i]*B[j]。注意，当dp[i-1][j-1]<0时，该项其实应该略去，即dp[i][j] = A[i]*B[j].
2. A[i]和B[j]不组成一对，那么这两个元素必然至少有一个不会被用来参与点乘。所以dp[i][j] = min{dp[i-1][j], dp[i][j-1]}.

最终的答案是dp[m][n].

$0
endsnippet

# ==> ./Dynamic_Programming/1458.Max-Dot-Product-of-Two-Subsequences/1458.Max-Dot-Product-of-Two-Subsequences.cpp <==
snippet 1458.Max-Dot-Product-of-Two-Subsequences "1458.Max-Dot-Product-of-Two-Subsequences" b
class Solution {
public:
    int maxDotProduct(vector<int>& nums1, vector<int>& nums2) 
    {
        int m = nums1.size();
        int n = nums2.size();
        nums1.insert(nums1.begin(),0);
        nums2.insert(nums2.begin(),0);
        auto dp = vector<vector<int>>(m+1,vector<int>(n+1,INT_MIN/2));
                
        int ret = INT_MIN;
        
        for (int i=1; i<=m; i++)
            for (int j=1; j<=n; j++)
            {
                dp[i][j] = max(dp[i][j], max(0, dp[i-1][j-1])+nums1[i]*nums2[j]);
                dp[i][j] = max(dp[i][j], dp[i-1][j]);
                dp[i][j] = max(dp[i][j], dp[i][j-1]);
               
                ret = max(ret, dp[i][j]);
            }
        
        return ret;        
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/1463.Cherry-Pickup-II/Readme.md <==
snippet 1463.Cherry-Pickup-II "1463.Cherry-Pickup-II" b
### 1463.Cherry-Pickup-II

相比于```741.Cherry-Pickup```，这题的解法对于DP的倾向性更加明显，因为这题有非常显著的“轮次”的特点：每走一步就下降一行。这一行（两个机器人）的选择，取决于上一行（两个机器人）的选择。因此我们设计dp[i][j]表示在当前行、两个机器人分别在横坐标位置i和j时，此时的最大收益。我们接下来只需要考虑上一行里，哪些dp[a][b]可以转移到这一行的dp[i][j]。因为每次横向移动的氛围只有-1到1，所以枚举一下就行啦。

$0
endsnippet

# ==> ./Dynamic_Programming/1463.Cherry-Pickup-II/1463.Cherry-Pickup-II.cpp <==
snippet 1463.Cherry-Pickup-II "1463.Cherry-Pickup-II" b
class Solution {
public:
    int cherryPickup(vector<vector<int>>& grid) 
    {
        int m = grid.size();
        int n = grid[0].size();
        
        auto dp = vector<vector<int>>(n, vector<int>(n,INT_MIN/2));        
        dp[0][n-1] = grid[0][0]+grid[0][n-1];
        
        int ret = 0;        
        for (int t=1; t<m; t++)
        {
            auto dp_temp = dp;
            for (int i=0; i<n; i++)
                for (int j=i; j<n; j++)
                {
                    dp[i][j] = INT_MIN/2;
                    for (int a=i-1; a<=i+1; a++)
                        for (int b=j-1; b<=j+1; b++)
                        {
                            if (a<0||a>=n||b<0||b>=n) continue;
                            if (i==j)
                                dp[i][j] = max(dp[i][j], dp_temp[a][b]+grid[t][i]);
                            else
                                dp[i][j] = max(dp[i][j], dp_temp[a][b]+grid[t][i]+grid[t][j]);                            
                        }                    
                }                              
        }
        
        for (int i=0; i<n; i++)
            for (int j=0; j<n; j++)
                ret = max(ret, dp[i][j]);
                
        return ret;
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/1473.Paint-House-III/Readme.md <==
snippet 1473.Paint-House-III "1473.Paint-House-III" b
### 1473.Paint-House-III

#### 解法1：
令dp[i][j][k]表示前i个房子构成了j个block，并且第i个房子喷涂的颜色是k的最小代价。分两种情况讨论：

1. 当```house[i]!=0```，说明第i个房子无法更改颜色，此时dp[i][j][k]取决于前面一个房子的颜色kk。遍历kk的可能。如果kk与k相同，那么第i个房子和前面的房子可以合并为一个block，即```dp[i][j][k] = min{self, dp[i-1][j][kk]}```。如果kk与k不同，那么第i个房子就是第j个block的第一个，即```dp[i][j][k] = min{self, dp[i-1][j-1][kk]}```。

2. 当```house[i]==0```，说明第i个房子可以任意喷涂k=1,2,..,n，记得加上喷涂成本. 同理，遍历前一个房子的颜色kk。如果kk与k相同，那么第i个房子和前面的房子可以合并为一个block，即```dp[i][j][k] = min{self, dp[i-1][j][kk]+cost[i][k]}```。如果kk与k不同，那么第i个房子就是第j个block的第一个，即```dp[i][j][k] = min{self, dp[i-1][j-1][kk]+cost[i][k]}```。

初始状态是```dp[0][0][j] = 0```，其余的状态都是无穷大。

最终的答案是在所有房子喷涂完、构造了target个block、最后一个房子颜色任意的前提下，取最小值。即```min{dp[m][target][k]，for k=1,2,..,n```

#### 解法2：
上述的解法中，第二情况下会有四层循环，分别遍历i,j,k,kk，时间复杂度达到了```o(m*m*n*n)```. 事实上可以优化到```o(m*m*n)```。

我们考察解法1的写法：
```cpp
for (int j=1; j<=target; j++)
    for (int k=1; k<=n; k++)
    {
        for (int kk=1; kk<=n; kk++)
        {
            if (kk==k)
                dp[i][j][k] = min(dp[i][j][k], dp[i-1][j][kk] + cost[i][k-1]);
            else
                dp[i][j][k] = min(dp[i][j][k], dp[i-1][j-1][kk] + cost[i][k-1]);
        }
    }    
```
我们看到对于每个k，我们都要把kk都遍历一遍找dp[i-1][j-1][kk]的最小值。事实上这个最小值可以对大部分的k共享。我们可以提前把dp[i-1][j-1][kk]的最小值计算出来，假设对应的是minCost和kk1。对于大部分的dp[i][j][k]，可以通过这个minCost（即第i-1个房子、构造j-1个block、用第kk1种颜色）转移过来。但是注意，如果最小值对应的kk1恰好就是k，那么dp[i][j][k]只能从dp[i-1][j-1][kk]里的第二小的值转移。
```cpp
for (int j=1; j<=target; j++)
{
    vector<pair<int,int>>temp;
    for (int kk=1; kk<=n; kk++)
    {
        temp.push_back({dp[i-1][j-1][kk], kk});
    }
    sort(temp.begin(), temp.end()); // save the min dp[i][j-1][kk] and the second min

    for (int k=1; k<=n; k++)
    {
        dp[i][j][k] = dp[i-1][j][k] + cost[i][k-1];
        if (k!=temp[0].second)
            dp[i][j][k] = min(dp[i][j][k], temp[0].first + cost[i][k-1]);
        else
            dp[i][j][k] = min(dp[i][j][k], temp[1].first + cost[i][k-1]);
    }                    
}
```                
这样的写法的循环只有三层，分别是i,j, kk（与k并列）.

$0
endsnippet

# ==> ./Dynamic_Programming/1473.Paint-House-III/1473.Paint-House-III_v1.cpp <==
snippet 1473.Paint-House-III "1473.Paint-House-III" b
class Solution {
    int dp[105][105][25];
public:
    int minCost(vector<int>& houses, vector<vector<int>>& cost, int m, int n, int target) 
    {
        houses.insert(houses.begin(), 0);
        cost.insert(cost.begin(), {0});

        for (int i=0; i<=m; i++)
            for (int j=0; j<=target; j++)
                for (int k=0; k<=n; k++)
                    dp[i][j][k] = INT_MAX/2;

        for (int k=0; k<=n; k++)
            dp[0][0][k] = 0;

        for (int i=1; i<=m; i++)
        {
            if (houses[i]!=0)
            {       
                for (int j=1; j<=target; j++)
                {
                    int k = houses[i];                    
                    for (int kk=1; kk<=n; kk++)
                    {
                        if (kk==k)
                            dp[i][j][k] = min(dp[i][j][k], dp[i-1][j][kk]);
                        else
                            dp[i][j][k] = min(dp[i][j][k], dp[i-1][j-1][kk]);
                    }
                }
            }
            else
            {
                for (int j=1; j<=target; j++)
                    for (int k=1; k<=n; k++)
                    {
                        for (int kk=1; kk<=n; kk++)
                        {
                            if (kk==k)
                                dp[i][j][k] = min(dp[i][j][k], dp[i-1][j][kk] + cost[i][k-1]);
                            else
                                dp[i][j][k] = min(dp[i][j][k], dp[i-1][j-1][kk] + cost[i][k-1]);
                        }
                    }                
            }    
        }

        int ret = INT_MAX/2;
        for (int k=1; k<=n; k++)
            ret = min(ret, dp[m][target][k]);
        if (ret==INT_MAX/2)
            return -1;
        else
            return ret;
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/1473.Paint-House-III/1473.Paint-House-III_v2.cpp <==
snippet 1473.Paint-House-III "1473.Paint-House-III" b
class Solution {
    int dp[105][105][25];
public:
    int minCost(vector<int>& houses, vector<vector<int>>& cost, int m, int n, int target) 
    {
        houses.insert(houses.begin(), 0);
        cost.insert(cost.begin(), {0});

        for (int i=0; i<=m; i++)
            for (int j=0; j<=target; j++)
                for (int k=0; k<=n; k++)
                    dp[i][j][k] = INT_MAX/2;

        for (int k=0; k<=n; k++)
            dp[0][0][k] = 0;

        for (int i=1; i<=m; i++)
        {
            if (houses[i]!=0)
            {       
                for (int j=1; j<=target; j++)
                {
                    int k = houses[i];                    
                    for (int kk=1; kk<=n; kk++)
                    {
                        if (kk==k)
                            dp[i][j][k] = min(dp[i][j][k], dp[i-1][j][k]);
                        else
                            dp[i][j][k] = min(dp[i][j][k], dp[i-1][j-1][kk]);
                    }
                }
            }
            else
            {
                for (int j=1; j<=target; j++)
                {
                    vector<pair<int,int>>temp;
                    for (int kk=1; kk<=n; kk++)
                    {
                        temp.push_back({dp[i-1][j-1][kk], kk});
                    }
                    sort(temp.begin(), temp.end());
                    
                    for (int k=1; k<=n; k++)
                    {
                        dp[i][j][k] = dp[i-1][j][k] + cost[i][k-1];
                        if (k!=temp[0].second)
                            dp[i][j][k] = min(dp[i][j][k], temp[0].first + cost[i][k-1]);
                        else
                            dp[i][j][k] = min(dp[i][j][k], temp[1].first + cost[i][k-1]);
                    }                    
                }
            }    
        }

        int ret = INT_MAX/2;
        for (int k=1; k<=n; k++)
            ret = min(ret, dp[m][target][k]);
        if (ret==INT_MAX/2)
            return -1;
        else
            return ret;
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/1478.Allocate-Mailboxes/Readme.md <==
snippet 1478.Allocate-Mailboxes "1478.Allocate-Mailboxes" b
### 1478.Allocate-Mailboxes

首先回顾一个引理。一条直线上有若干个点p0,p1,...pn，其median位置处的点是pm，那么该点满足最小化```sum{abs(pi-p)}, for i=0,1,...,n```

在本题中，我们定义dp[i][k]表示前i个房子的范围内设置k个邮局（或者说设置k个邮局覆盖前i个房子），所得到的最小的objective。我们考虑，那么k-1个邮局可以覆盖多少房子？假设是j个房子。于是我们有一种可能，只要j取得合适，前j个房子被前k-1个邮局覆盖是最优的，并且第j+1到第i个房子被第k个邮局覆盖是最优的。于是就有
```dp[i][k] = dp[j][k-1] + range[j+1][i]```。其中range[j+1][i]表示区间[j+1,i]内的房子被1个邮局覆盖的objective.显然这1个邮局是位于[j+1,i]的中位数位置，并且range[j+1][i]是可以提前计算出来的。

怎么找到这个合适的j呢？我们可以把所有的j的可能都遍历一遍，最小的```dp[j][k-1] + range[j+1][i]```就对应着最合适的j。也就是说，不合适的j计算出来的```dp[j][k-1] + range[j+1][i]```都会偏大，从而不会被dp[i][k]采纳。为什么呢？

举个例子，我们查看某个j。dp[j][k-1]给出了一个k-1个邮局覆盖前j个房子的最优解。range[j+1][i]给出了后面几个房子被1个邮局覆盖的最优解。但是统一来看所有的k个邮局，可能第j个房子更适合被第k个邮局覆盖（距离更近）。如果是这样的话，第j个房子的距离被高估了。同时，前j-1个房子的到邮局距离之和也必然被高估，这是因为如果把第j个划归给第k个邮局的话，前k-1个邮局的规划肯定可以更紧密一些。综上所述，对于不合适的j，整个```dp[j][k-1] + range[j+1][i]```都会偏大。只有遍历到最合适的j，就能得到```dp[j][k-1] + range[j+1][i]```的最小值，即最小化dp[i][k]。


$0
endsnippet

# ==> ./Dynamic_Programming/1478.Allocate-Mailboxes/1478.Allocate-Mailboxes.cpp <==
snippet 1478.Allocate-Mailboxes "1478.Allocate-Mailboxes" b
class Solution {
public:
    int minDistance(vector<int>& houses, int K) 
    {
        int n = houses.size();
        sort(houses.begin(), houses.end());
        houses.insert(houses.begin(), INT_MIN);
        vector<vector<int>>dp(n+1, vector<int>(K+1, INT_MAX/2));

        int range[n+1][n+1];
        for (int i=1; i<=n; i++)
            for (int j=i; j<=n; j++)
            {
                int sum = 0;
                for (int k=i; k<=j; k++)
                    sum += abs(houses[k] - houses[(i+j)/2]);
                range[i][j] = sum;
            }

        for (int i=1; i<=n; i++)
            dp[i][1] = range[1][i];

        for (int i=1; i<=n; i++)
            for (int k=2; k<=K; k++)
            {
                for (int j=1; j+1<=i; j++)
                    dp[i][k] = min(dp[i][k],  dp[j][k-1]+range[j+1][i]);
            }

        return dp[n][K];

    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/1494.Parallel-Courses-II/Readme.md <==
snippet 1494.Parallel-Courses-II "1494.Parallel-Courses-II" b
### 1494.Parallel-Courses-II

此题乍看贪心法可解。如果想要得到一个合法的课程顺序，必然利用拓扑排序的手段，首先完成那些入度为0的课程。但是本题特别之处在于，如果入度为0的课程多于k个，那么第一轮该优先选取哪k个，才能保证最终用最少的轮数完成所有课程？事实上，并没有任何有效的贪心策略能够帮助挑选这k个课程。优先有序节点总数多的课程，或者优先后续节点深度多的课程，都是没有道理的。

事实上这是一道NP问题，并没有多项式时间的解法。所以只好用暴力的方法去解决。状态压缩DP就是比较“高效”的暴力方法。事实上，题目给出n<=15的条件，就暗示了应该用这种方法。

我们用整形变量state的各个bit位来代表是否完成了某门课程，比如说第i个bit位是1就表示完成了第i门课程。dp[state]表示完成对应的这些课程需要最少多少轮。显然，我们需要考虑前一轮的状态prevState是什么？显然我们找一个最小的dp[prevState]然后加1，就可以得到最优的dp[state]。

我们知道prevState必然是state的子集。我们可以用暴力搜索所有它的子集，这里有一个比较高效的循环语句值得收藏：
```cpp
for (int subset=state; subset>0; subset=(subset-1)&state)
```
这样得到的subset是比较高效的。

那么接下来我们就要判断这个subset对应的状态，是否能够通过新一轮的课程学习，达到state对应的状态。这里需要几个条件：
1. state的课程数目不能比subset的课程数目多余k。这可以用C++的内置函数来实现：
```cpp
__builtin_popcount(state) - __builtin_popcount(subset) <= k
```
2. state的课程的先修课程，必须全部囊括在subset里面。也就是说，subset必须是state先修课程的超集。我们需要提前计算出state的先修课程集合prevState[state]，然后判断是否
```cpp
prevState[state] & subset == prevState[state]
```
满足这两个条件的话，那么就说明subset是可以转移到state的。故有```dp[state]=dp[subset]+1```

此外，我们可以提前处理数据，计算所有状态的prevState。这个不难做到，只要将state的每一门课程的先修课程取并集即可。

$0
endsnippet

# ==> ./Dynamic_Programming/1494.Parallel-Courses-II/1494.Parallel-Courses-II.cpp <==
snippet 1494.Parallel-Courses-II "1494.Parallel-Courses-II" b
class Solution {
public:
    int minNumberOfSemesters(int n, vector<vector<int>>& dependencies, int k) 
    {
        vector<int>dp(1<<n, INT_MAX/2);
        vector<int>prevState(1<<n, 0);
        vector<int>prevCourse(n,0);

        for (auto x: dependencies)        
            prevCourse[x[1]-1] |= 1<<(x[0]-1);        
                    
        for (int state = 0; state < (1<<n); state++)
        {
            prevState[state] = 0;
            for (int i=0; i<n; i++)
            {
                if ((state>>i) & 1)
                    prevState[state] |= prevCourse[i];
            }
        }

        dp[0] = 0;
        for (int state = 1; state < (1<<n); state++)        
        {
            for (int subset = state; subset >= 0; subset = (subset-1)&state)
            {
                if (__builtin_popcount(state) - __builtin_popcount(subset) <= k && (prevState[state] & subset) == prevState[state])
                {
                    dp[state] = min(dp[state], dp[subset]+1);
                }
                if (subset==0) break;
            }
        }
        return dp[(1<<n)-1];
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/1494.Parallel-Courses-II/1494.Parallel-Courses-II_v2.cpp <==
snippet 1494.Parallel-Courses-II "1494.Parallel-Courses-II" b
class Solution {
public:
    int minNumberOfSemesters(int n, vector<vector<int>>& dependencies, int k) 
    {
        vector<int>dp(1<<n, INT_MAX/2);
        vector<int>prevState(1<<n, 0);
        vector<int>prevCourse(n,0);

        for (auto x: dependencies)        
            prevCourse[x[1]-1] |= 1<<(x[0]-1);        
                    
        for (int state = 0; state < (1<<n); state++)
        {
            prevState[state] = 0;
            for (int i=0; i<n; i++)
            {
                if ((state>>i) & 1)
                    prevState[state] |= prevCourse[i];
            }
            if (prevState[state]==0 && __builtin_popcount(state)<=k)
                dp[state] = 1;
        }

        dp[0] = 0;
        for (int state = 1; state < (1<<n); state++)        
        {
            for (int subset = state; subset > 0; subset = (subset-1)&state)
            {
                if (__builtin_popcount(state) - __builtin_popcount(subset) <= k && (prevState[state] & subset) == prevState[state])
                {
                    dp[state] = min(dp[state], dp[subset]+1);
                }
            }
        }
        return dp[(1<<n)-1];
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/1531.String-Compression-II/Readme.md <==
snippet 1531.String-Compression-II "1531.String-Compression-II" b
### 1531.String-Compression-II

第一印象时我会这样设计DP方案：dp[i][k]表示前i个字母里删除k个所能得到的最优解（即最短的行程长度编码）。突破口应该是考虑第k个删除的字母的位置j在哪里，所以状态转移方程大致是：
```
dp[i][k] = max{dp[j-1][k-1] + s[j+1:i]的行程长度编码} for j=1,2,...i
```
但是我们在跑第二个例子 s = "aabbaa", k = 2 的时候会发现问题：我们删除了中间的bb，则第一段aa和最后一段的aa会拼接起来。而上述的表达式中完全没有考虑到拼接的处理。

换句话说，dp[j-1][k-1]对应的原码，和s[j+1:i]这段原码，其run-length encode不是简单的长度相加关系，而是有可能拼接在一起，形成更短的run-length encode. 为了便于处理这种“拼接关系”，我们需要提供更多的信息接口。所以会有以下的想法：令dp[i][k][ch][num]表示前i个字母、删除k个字母、最后的字母是ch、最后的字母连续出现的次数是num，所对应的最优解（即最短的行程长度编码）。

那么求解dp[i][k][ch][num]的关键是找到哪合法的前驱状态dp[?][?][?][?]可以转移到它。实际写代码的过程中，发现这样实现比较复杂。我们可以用另外一种DP的写法，就是看dp[i][k][ch][num]能够影响哪些后继节点。事实上，它直接影响的就是dp[i+1][?][?][?]的状态，我们只要讨论dp[i+1][?][?][?]的取值可能性即可。

1. 如果第i+1个元素我们是要删除的。那么dp[i][k][ch][num]的结果原封不动地传递给了dp[i+1][k+1][ch][num].也就是前i+1个元素里、我们删除k+1个字母、最后的字母是ch、最后的字母连续出现的次数是num，有一种解就是与dp[i][k][ch][num]的状态完全相同。
2. 如果第i+1个元素我们要保留，说明我们有机会更新dp[i+1][k][s[i]-'a'][?]的值。注意，既然保留了第i+1个字母，显然最后的字母就是s[i+1]，所以我们只需要确定最后一个问号即可。这个“连续”数目显然取决于s[i+1]是否和ch是否相同。如果不同，那么说明无法拼接上，所以我们直接可以更新的是 dp[i+1][k][s[i]-'a'][1]。怎么更新？就是```dp[i][k][ch][num]+1```，即run-length encode单纯地加上1.
3. 如果第i+1个元素我们要保留，并且s[i+1]和ch相同，那么说明dp[i][k][ch][num]的最后字母ch可以再拼接一个，也就是说我们可以更新的是dp[i][k][ch][num+1]。怎么更新，是简单地在dp[i][k][ch][num]基础上加1吗？并不一定。其实需要根据num分情况讨论（附上了例子）来确定增加的run-length encode的长度：
```
                            if (num==1) add = 1;  // e.g: a -> a2
                            else if (num>=2 && num<=8) add = 0; // e.g: a3->a4
                            else if (num==9) add = 1; // e.g: a9->a10;
                            else if (num>=10) add = 0; // e.g: a10->a11;
```
最终的结果是要求在所有n个字母中删去K个字母，所以需要再dp[n][K][?][?]中挑选一个最小值。

另外需要注意的一个技巧是，我们不需要把第四个维度开到100，事实上num>=10之后，即使再拼接相同的字母，run-length encode也都不会再改变。所以我们可以把所有num>=10的状态都归为同一个状态，来节省空间的开辟。

$0
endsnippet

# ==> ./Dynamic_Programming/1531.String-Compression-II/1531.String-Compression-II.cpp <==
snippet 1531.String-Compression-II "1531.String-Compression-II" b
class Solution {
    int dp[101][101][27][11];
public:
    int getLengthOfOptimalCompression(string s, int K) 
    {
        // Handling the special case of "a...a" where there are 100 as
        if (s.size()==100 && K==0)
        {
            int flag = 1;
            for (int i=1; i<s.size(); i++)
            {
                if (s[i]!=s[0])
                {
                    flag = 0;                
                    break;
                }                    
            }
            if (flag==1) return 4;
        }
        
        int n = s.size();
        s = "#"+s;

        for (int i=0; i<=n; i++)
            for (int k=0; k<=K; k++)
                for (int ch=0; ch<=26; ch++)
                    for (int num=0; num<=10; num++)
                        dp[i][k][ch][num] = INT_MAX;
        // dp[i][k][ch][num]: the optimal solution for s[1:i]
        // with k digits removed, last letter as ch, the consecitive number of ch as num

        dp[0][0][26][0] = 0;

        for (int i=0; i<n; i++)
            for (int k=0; k<=min(K, i); k++)
                for (int ch = 0; ch <= 26; ch++)
                    for (int num = 0; num <=10; num++)
                    {
                        int cur = dp[i][k][ch][num];
                        if (cur==INT_MAX) continue;

                        // delete s[i+1]
                        dp[i+1][k+1][ch][num] = min(dp[i+1][k+1][ch][num], cur);

                        // keep s[i+1]
                        if (s[i+1]-'a' == ch)
                        {
                            int add;
                            if (num==1) add = 1;  // a -> a2
                            else if (num>=2 && num<=8) add = 0; // a3->a4
                            else if (num==9) add = 1; // a9->a10;
                            else if (num==10) add = 0; // a10->a11;
                            dp[i+1][k][ch][min(num+1, 10)] = min(dp[i+1][k][ch][min(num+1, 10)], cur+add);
                        }
                        else
                        {
                            dp[i+1][k][s[i+1]-'a'][1] = min(dp[i+1][k][s[i+1]-'a'][1], cur+1);
                        }
                    }
        
        int ret = INT_MAX;
        for (int ch = 0; ch <= 26; ch++)
            for (int num = 0; num <=10; num++)                    
                ret = min(ret, dp[n][K][ch][num]);
        
        return ret;
    }
};


$0
endsnippet

# ==> ./Dynamic_Programming/1546.Maximum-Number-of-Non-Overlapping-Subarrays-With-Sum-Equals-Target/Readme.md <==
snippet 1546.Maximum-Number-of-Non-Overlapping-Subarrays-With-Sum-Equals-Target "1546.Maximum-Number-of-Non-Overlapping-Subarrays-With-Sum-Equals-Target" b
### 1546.Maximum-Number-of-Non-Overlapping-Subarrays-With-Sum-Equals-Target

本题很容易看出动态规划的暗示。根据套路，我们尝试定义dp[i]表示前i个元素最多能有多少个符合条件的subarray，然后尝试考虑如何对第i个元素进行处理：要么nums[i]不参与任何subarray，那么就是参与某个subarray。

但我们发现，如果第i个元素是某个subarray中间的任意一员，我们其实很难确定最后一个subarray的范围，没有任何头绪。于是突破点是：如果我们考虑第i个元素是某个subarray的最后一个元素，那么我们其实就唯一确定了这个subarray的范围。方法就是找到一个位置j，使得前缀和presum[j] = presum[i]-target. 如果这个条件满足，那么[j+1,i]就是一个符合条件的subarray。接下来就迎刃而解。我们可以用hash表来存下每个presum对应的所有idx，那么
```
dp[i] = max{dp[j]+1} for all j st. sum[j+1,i] = presum[i]-presum[j] = target
```
注意，还有一种情况是元素i不参与任何subarray，那么它也有一个default value就是dp[i-1].

以上的方法是o(N^2)，但还可以改进。事实上我们并不需要在hash表中存下每个presum对应的所有idx，其实只需要存下最靠后的一个idx就可以了。这是因为数字越多，我们可能得到的最优答案肯定只增不减。即如果presum[j1]==presum[j2]且j1<j2，那么一定有贪心的结论```dp[j1]<=dp[j2]```。

$0
endsnippet

# ==> ./Dynamic_Programming/1546.Maximum-Number-of-Non-Overlapping-Subarrays-With-Sum-Equals-Target/1546.Maximum-Number-of-Non-Overlapping-Subarrays-With-Sum-Equals-Target_v1.cpp <==
snippet 1546.Maximum-Number-of-Non-Overlapping-Subarrays-With-Sum-Equals-Target "1546.Maximum-Number-of-Non-Overlapping-Subarrays-With-Sum-Equals-Target" b
class Solution {
public:
    int maxNonOverlapping(vector<int>& nums, int target) 
    {
        unordered_map<int,vector<int>>Map;
        int n = nums.size();
        vector<int>dp(n+1,0);
        vector<int>presum(n+1,0);
        nums.insert(nums.begin(),0);

        for (int i=1; i<=n; i++)
            presum[i] = presum[i-1]+nums[i];
        Map[0].push_back(0);
        
        int ret = 0;
        for (int i=1; i<=n; i++)
        {
            dp[i] = dp[i-1];
            for (auto j: Map[presum[i] - target])
                dp[i] = max(dp[i], dp[j]+1);
            ret = max(ret, dp[i]);

            Map[presum[i]].push_back(i);
        }
        return ret;
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/1546.Maximum-Number-of-Non-Overlapping-Subarrays-With-Sum-Equals-Target/1546.Maximum-Number-of-Non-Overlapping-Subarrays-With-Sum-Equals-Target_v2.cpp <==
snippet 1546.Maximum-Number-of-Non-Overlapping-Subarrays-With-Sum-Equals-Target "1546.Maximum-Number-of-Non-Overlapping-Subarrays-With-Sum-Equals-Target" b
class Solution {
public:
    int maxNonOverlapping(vector<int>& nums, int target) 
    {
        unordered_map<int,int>Map;
        int n = nums.size();
        vector<int>dp(n+1,0);
        vector<int>presum(n+1,0);
        nums.insert(nums.begin(),0);

        for (int i=1; i<=n; i++)
            presum[i] = presum[i-1]+nums[i];
        Map[0] = 0;
        
        int ret = 0;
        for (int i=1; i<=n; i++)
        {
            dp[i] = dp[i-1];
            if (Map.find(presum[i] - target)!=Map.end())
            {
                int j = Map[presum[i] - target];
                dp[i] = max(dp[i], dp[j]+1);
            }            
            ret = max(ret, dp[i]);
            Map[presum[i]]=i;
        }
        return ret;
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/1547.Minimum-Cost-to-Cut-a-Stick/Readme.md <==
snippet 1547.Minimum-Cost-to-Cut-a-Stick "1547.Minimum-Cost-to-Cut-a-Stick" b
### 1547.Minimum-Cost-to-Cut-a-Stick

这是一道典型的区间型的DP。对于[i,j]这段区间，我们考虑如何砍下第一刀？显然下刀的位置可以是cuts[i+1],cuts[i+2],...,cuts[j-1]。我们假设在位置k下刀，那么这一刀的代价就是[i,j]的程度，接下来问题就转为了两个小区间[i,k]和[k,j]的问题。所以状态转移方程是：
```
dp[i][j] = min{dp[i][k]+dp[k][j]+cuts[j]-cuts[i]} for k=i+1,i+2,...,j-1
```
边界条件是对于任何长度为1的区间[i,i+1]，不需要下刀，代价就是0.

$0
endsnippet

# ==> ./Dynamic_Programming/1547.Minimum-Cost-to-Cut-a-Stick/1547.Minimum-Cost-to-Cut-a-Stick.cpp <==
snippet 1547.Minimum-Cost-to-Cut-a-Stick "1547.Minimum-Cost-to-Cut-a-Stick" b
class Solution {
public:
    int minCost(int n, vector<int>& cuts) 
    {
        sort(cuts.begin(), cuts.end());
        cuts.insert(cuts.begin(), 0);
        cuts.push_back(n);
        
        int m = cuts.size();
        auto dp = vector<vector<int>>(m, vector<int>(m,INT_MAX));
        
        for (int i=0; i+1<m; i++)
            dp[i][i+1] = 0;
        
        for (int len = 3; len <= m; len++)
            for (int i=0; i+len-1<m; i++)
            {
                int j = i+len-1;
                for (int k=i+1; k<j; k++)
                    dp[i][j] = min(dp[i][j], cuts[j]-cuts[i]+dp[i][k]+dp[k][j]);
            }
        
        return dp[0][m-1];
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/1548.The-Most-Similar-Path-in-a-Graph/Readme.md <==
snippet 1548.The-Most-Similar-Path-in-a-Graph "1548.The-Most-Similar-Path-in-a-Graph" b
### 1548.The-Most-Similar-Path-in-a-Graph

令dp[t][i]表示路径的第t个位置设置为第i个城市，所能得到的最小edit distance。显然，它的前驱状态就是dp[t-1][j]，其中j和i之间有通路。因此
```
dp[t][i] = min{dp[t-1][j] + (city[i]!=targetPath[t])} for all j->i
```
答案就是选择dp[T-1][?]中最小值。

本题还需要打印出路径，因此需要额外记录prev[t][i]表示dp[t][i]的前驱状态对应的城市编号。然后从dp[T-1][?]最小值所对应的那个城市作为终点，根据Prev的信息往前倒推出整条path。

$0
endsnippet

# ==> ./Dynamic_Programming/1548.The-Most-Similar-Path-in-a-Graph/1548.The-Most-Similar-Path-in-a-Graph.cpp <==
snippet 1548.The-Most-Similar-Path-in-a-Graph "1548.The-Most-Similar-Path-in-a-Graph" b
class Solution {
public:
    vector<int> mostSimilar(int n, vector<vector<int>>& roads, vector<string>& names, vector<string>& targetPath) 
    {
        int T= targetPath.size();
        vector<int>dp(n,0);
        auto prev = vector<vector<int>>(T, vector<int>(n,-1));
        
        vector<vector<int>>next(n);
        for (auto road : roads)
        {
            next[road[0]].push_back(road[1]);
            next[road[1]].push_back(road[0]);
        }
        
        for (int t=0; t<T; t++)
        {
            auto dp_temp = dp;            
            for (int i=0; i<n; i++)
            {
                dp[i] = INT_MAX/2;
                for (int j: next[i])                    
                {
                    if (dp[i] > dp_temp[j] + (names[i]!=targetPath[t]))
                    {
                        dp[i] = dp_temp[j] + (names[i]!=targetPath[t]);
                        prev[t][i] = j;
                    }                    
                }                
            }
        }
        
        int dist = INT_MAX/2;
        int start;
        for (int i=0; i<n; i++)
        {
            if (dist > dp[i])
            {
                dist = dp[i];
                start = i;
            }
        }
            
        vector<int>rets;
        for (int t=T-1; t>=0; t--)
        {
            rets.push_back(start);
            start = prev[t][start];
        }
        reverse(rets.begin(), rets.end());
        
        return rets;
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/1563.Stone-Game-V/Readme.md <==
snippet 1563.Stone-Game-V "1563.Stone-Game-V" b
### 1563.Stone-Game-V

本题是典型的区间型的DP。令dp[i][j]表示对于区间[i,j]，如果让对手先行，我方能够得到的最大得分。注意，对手做的决策是由我方提出的，所以我方会做尽量有利于自己的决策。当然，为了知道哪个是最有利的决策，我们需要遍历所有的决策。每一种决策就是将[i,j]划分为两个区间[i,k],[k+1,j]，然后我们就知道左子区间与右子区间的和，根据规则，我们对我方的得分有如下的递归定义：
```cpp
if (leftSum<rightSum)
    dp[i][j] = max(dp[i][j], dp[i][k]+leftSum);
else if (leftSum==rightSum)
    dp[i][j] = max(dp[i][j], max(dp[i][k],dp[k+1][j])+rightSum);
else if (leftSum>rightSum)                    
    dp[i][j] = max(dp[i][j], dp[k+1][j]+rightSum);     
```
dp[i][j]的最终值，就是所有划分区间的可能决策里（即遍历k的位置）的最大值。

dp的边界值是当区间长度为2的时候，我方的得分只能是较小的那个元素。

因为LC平台对CPP的编译优化设置很低，本题的DP解法用cpp实现会超时。一个绕行的方法是改写成递归+记忆化的形式：
```cpp
if (leftSum<rightSum)
    dp[i][j] = max(dp[i][j], solve(i,k)+leftSum);
else if (leftSum==rightSum)
    dp[i][j] = max(dp[i][j], max(solve(i,k),solve(k+1,j))+rightSum);
else if (leftSum>rightSum)                    
    dp[i][j] = max(dp[i][j], solve(k+1,j)+rightSum);            
```
这种方法能AC的原因在于，当```leftSum<rightSum```的时候，只需要向下递归solve(i,k)而不需要向下递归solve(k+1,j)，可以省略一些分支。而bottom-up的DP写法，则需要计算出任意两点区间的dp值。

$0
endsnippet

# ==> ./Dynamic_Programming/1563.Stone-Game-V/1563.Stone-Game-V_dp.cpp <==
snippet 1563.Stone-Game-V "1563.Stone-Game-V" b
class Solution {
    int presum[501];
    int dp[501][501];
public:
    int stoneGameV(vector<int>& stoneValue) 
    {
        int n = stoneValue.size();
        stoneValue.insert(stoneValue.begin(),0);        
        
        presum[0] = 0;
        for (int i=1; i<=n; i++)
            presum[i] = presum[i-1]+stoneValue[i];                
        
        for (int i=1; i<=n; i++)
            for (int j=1; j<=n; j++)
                dp[i][j] = 0;
        
        for (int i=1; i<=n-1; i++)
            dp[i][i+1] = min(stoneValue[i], stoneValue[i+1]);        
        
        for (int len = 3; len <= n; len++)
        {
            for (int i=1; i+len-1<=n; i++)
            {
                int j = i+len-1;
                
                for (int k=i; k<j; k++)
                {
                    int leftSum = presum[k]-presum[i-1];
                    int rightSum = presum[j]-presum[k];

                    if (leftSum<rightSum)
                        dp[i][j] = max(dp[i][j], dp[i][k]+leftSum);
                    else if (leftSum==rightSum)
                        dp[i][j] = max(dp[i][j], max(dp[i][k],dp[k+1][j])+rightSum);
                    else if (leftSum>rightSum)                    
                        dp[i][j] = max(dp[i][j], dp[k+1][j]+rightSum);                                            
                }
            }
        }
        
        return dp[1][n];
        
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/1563.Stone-Game-V/1563.Stone-Game-V_recursion.cpp <==
snippet 1563.Stone-Game-V "1563.Stone-Game-V" b
class Solution {
    int dp[501][501];
    int presum[501];
public:
    int stoneGameV(vector<int>& stoneValue) 
    {
        int n = stoneValue.size();
        stoneValue.insert(stoneValue.begin(),0);
        presum[0] = 0;
        for (int i=1; i<=n; i++)
            presum[i] = presum[i-1]+stoneValue[i];
        
        for (int i=0; i<501; i++)
            for (int j=0; j<501; j++)
                dp[i][j] = 0;
        
        for (int i=1; i<=n-1; i++)
            dp[i][i+1] = min(stoneValue[i], stoneValue[i+1]);
        
        return solve(1,n);
    }
    
    int solve (int i, int j)
    {   
        if (dp[i][j]!=0)
            return dp[i][j];
        if (i>=j)
            return 0;
        
        for (int k=i; k<j; k++)
        {
            int leftsum = presum[k] - presum[i-1];
            int rightsum = presum[j] - presum[k];
            if (leftsum > rightsum)
                dp[i][j] = max(dp[i][j], rightsum + solve(k+1,j));
            else if (leftsum < rightsum)
                dp[i][j] = max(dp[i][j], leftsum + solve(i,k));
            else
                dp[i][j] = max(dp[i][j], leftsum + max(solve(i,k), solve(k+1,j)));
        }
        
        return dp[i][j];
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/1575.Count-All-Possible-Routes/Readme.md <==
snippet 1575.Count-All-Possible-Routes "1575.Count-All-Possible-Routes" b
### 1575.Count-All-Possible-Routes

#### 解法1：```o(f*n*n)```
当我们考虑到达城市c有多少种方案的时候，势必会考虑之前可能在哪个城市？如果之前的城市是d，那么问题就转化为了“达到城市d多少种方案”，另外加上一个约束：有足够的剩余油量能够从d来到c。所以每到一个城市的剩余油量亦是一个关键因素。

本题最大的提示就是fuel的数据范围只有200，因此我们暴力遍历这个变量空间的所有值都是可行的。什么意思？就是我们可以定义状态dp[f][c]表示（从初始状态）到达城市c、剩余油料是f时，有多少种行程方案。因此我们可以根据上面的思路，遍历c之前的一站d。令d和c之间的油料消耗是g，那么说明前一站的状态就是dp[f+g][d]。如果知道有多少方案能够达到dp[f+g][d]，那么就说明有相同数量的方案可以达到dp[f][c]。所以状态转移方程是：
```cpp
for (int d=0; d<n; d++)
  g = dis(c,d);
  dp[f][c] += dp[f+g][d];
```
此外要注意d不能与c重复，此外f+g不能超过初始油量fuel.

最终的答案是```sum {dp[f][finish]}```，其中油量f可以是任意值。因为不同的方案，达到终点的油量都不一样。我们需要把每种方案都累加起来。

#### 解法2：```o(f*n)```
上面的解法中，我们考虑dp[f][c]之前的状态，会遍历其他的任意一个城市d。但是不管是哪一个城市d，想要到达城市c的时候，都会经过c的左邻城市和c的右邻城市。我们其实只需要观察到达（或者经过）c的左邻/右邻城市有多少走法就行。

举个例子：令城市编号0,1,2,3代表着实际位置。start在城市0，finish在城市3.初始油料就是3.那么我们有三种方案：
```
0-1-2-3
0-1-3
0-2-3
0-3
```
所以我们考虑从左边抵达dp[f][3]的那些方法，需要考察dp[f+3][0],dp[f+2][1],dp[f+1][2].但是这三种情况，其实有一个共性：即当油量为f+1的时候位于城市2.那么我们是否可以把这三种状态都归纳为一种，这样dp[f][3]的状态只需要从dp[f+1][2]转移过去呢？当然是不可以的。因为我们要区分“停留”和“路过”。根据我们的dp定义，dp[f][c]表示的是当存留油量为f时，停留在c的方法。任何仅是路过c的方案，都不能统计在最终到达c的方案里。

这就提示我们设计这样的dp[f][c][k]，第三维k=0表示停留，k=1表示向左路过，k=2表示向右路过。状态转移方程是：
```cpp
        for (int f=fuel; f>=0; f--)
            for (int c=0; c<n; c++)
            {
                if (c>0 && f+locations[c]-locations[c-1] <= fuel)
                {
                    int gas = locations[c]-locations[c-1];                    
                    dp[f][c][0] += dp[f+gas][c-1][0] + dp[f+gas][c-1][2];
                    dp[f][c][2] += dp[f+gas][c-1][0] + dp[f+gas][c-1][2];
                }
                if (c<n-1 && f+locations[c+1]-locations[c] <= fuel)
                {
                    int gas = locations[c+1]-locations[c]; 
                    dp[f][c][0] += dp[f+gas][c+1][0] + dp[f+gas][c+1][1];
                    dp[f][c][1] += dp[f+gas][c+1][0] + dp[f+gas][c+1][1];
                }
                dp[f][c][0]%=M;
                dp[f][c][1]%=M;
                dp[f][c][2]%=M;
            }
```
从```dp[f][c][0] += dp[f+gas][c-1][0] + dp[f+gas][c-1][2]```这一行可以看出，对于所有从左边城市达到c的方案，不必列举前一站的城市，因为他们都会“路过”第c-1个城市。我们只需要再额外考虑“停留”在c-1这座城市的方案。

最终的答案是```sum{dp[f][finish][0]} for all f```，但是注意因为locations需要排序，此时的finish的编号和之前的并不一致，需要额外处理一下。



$0
endsnippet

# ==> ./Dynamic_Programming/1575.Count-All-Possible-Routes/1575.Count-All-Possible-Routes_v1.cpp <==
snippet 1575.Count-All-Possible-Routes "1575.Count-All-Possible-Routes" b
class Solution {
    long dp[201][100];
public:    
    int countRoutes(vector<int>& locations, int start, int finish, int fuel) 
    {
        int n = locations.size();
        dp[fuel][start] = 1;
        long M = 1e9+7;
        long ret = 0;
        
        for (int f=fuel; f>=0; f--)
            for (int c = 0; c<n; c++)
            {
                if (c==finish) ret = (ret+dp[f][c])%M;
                for (int d = 0; d<n; d++)
                {
                    if (d==c) continue;                  
                    int gas = abs(locations[d]-locations[c]);
                    if (f-gas >= 0)
                        dp[f-gas][d] = (dp[f-gas][d]+dp[f][c])%M;
                }
            }
        
        return ret;
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/1575.Count-All-Possible-Routes/1575.Count-All-Possible-Routes_v2.cpp <==
snippet 1575.Count-All-Possible-Routes "1575.Count-All-Possible-Routes" b
class Solution {
    long dp[201][100];
public:    
    int countRoutes(vector<int>& locations, int start, int finish, int fuel) 
    {
        int n = locations.size();
        dp[fuel][start] = 1;
        long M = 1e9+7;
        long ret = 0;
        
        for (int f=fuel; f>=0; f--)
            for (int c = 0; c < n; c++)
            {
                for (int d = 0; d < n; d++)
                {
                    if (d==c) continue;
                    int gas = abs(locations[d]-locations[c]);
                    if (f + gas <= fuel)
                        dp[f][c] = (dp[f][c] + dp[f+gas][d])%M;
                }
                if (c==finish) ret = (ret+dp[f][c])%M;
            }
        
        return ret;
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/1575.Count-All-Possible-Routes/1575.Count-All-Possible-Routes_v3.cpp <==
snippet 1575.Count-All-Possible-Routes "1575.Count-All-Possible-Routes" b
class Solution {
    long dp[201][101][3];
public:
    int countRoutes(vector<int>& locations, int start, int finish, int fuel) 
    {
        int n = locations.size();        
        int startPos = locations[start], finishPos = locations[finish];
        sort(locations.begin(),locations.end());
        
        int startIdx, finishIdx;
        for (int i=0; i<n; i++)
        {
            if (locations[i]==startPos) startIdx = i;
            if (locations[i]==finishPos) finishIdx = i;
        }
        dp[fuel][startIdx][0] = 1;
        long M = 1e9+7;
        
        for (int f=fuel; f>=0; f--)
            for (int c=0; c<n; c++)
            {
                if (c>0 && f+locations[c]-locations[c-1] <= fuel)
                {
                    int gas = locations[c]-locations[c-1];                    
                    dp[f][c][0] += dp[f+gas][c-1][0] + dp[f+gas][c-1][2];
                    dp[f][c][2] += dp[f+gas][c-1][0] + dp[f+gas][c-1][2];
                }
                if (c<n-1 && f+locations[c+1]-locations[c] <= fuel)
                {
                    int gas = locations[c+1]-locations[c]; 
                    dp[f][c][0] += dp[f+gas][c+1][0] + dp[f+gas][c+1][1];
                    dp[f][c][1] += dp[f+gas][c+1][0] + dp[f+gas][c+1][1];
                }
                dp[f][c][0]%=M;
                dp[f][c][1]%=M;
                dp[f][c][2]%=M;
            }
        long ret = 0;
        for (int f=0; f<=fuel; f++)
            ret = (ret+dp[f][finishIdx][0])%M;
        return ret;
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/1594.Maximum-Non-Negative-Product-in-a-Matrix/Readme.md <==
snippet 1594.Maximum-Non-Negative-Product-in-a-Matrix "1594.Maximum-Non-Negative-Product-in-a-Matrix" b
### 1594.Maximum-Non-Negative-Product-in-a-Matrix

本题的思想与 152.Maximum-Product-Subarray 相同。

和传统的最优路径题一样，令dp[i][j]表示从左上角走到(i,j)的最优代价（即路径乘积最大）。根据规则，dp[i][j]仅由dp[i-1][j]和dp[i][j-1]转移而来。但是不同于以往的套路：
```cpp
dp[i][j] = max(dp[i][j-1]*nums[i][j], dp[i-1][j]*nums[i][j])
```
在这里，如果nums[i][j]为负数的话，我们希望已知的反而是走到(i-1,j)和(i,j-1)的最小乘积路径，这样与nums[i][j]相乘之后才能得到的是最大乘积路径。这就提醒我们要维护两个状态变量，dp1[i][j]和dp2[i][j]来分别记录到当前的最大乘积路径和最小乘积路径。
```cpp
dp1[i][j] = max(max(dp1[i][j-1]*nums[i][j], dp1[i-1][j]*nums[i][j]), max(dp2[i][j-1]*nums[i][j], dp2[i-1][j]*nums[i][j]));
dp2[i][j] = min(min(dp1[i][j-1]*nums[i][j], dp1[i-1][j]*nums[i][j]), min(dp2[i][j-1]*nums[i][j], dp2[i-1][j]*nums[i][j]))'
```

$0
endsnippet

# ==> ./Dynamic_Programming/1594.Maximum-Non-Negative-Product-in-a-Matrix/1594.Maximum-Non-Negative-Product-in-a-Matrix.cpp <==
snippet 1594.Maximum-Non-Negative-Product-in-a-Matrix "1594.Maximum-Non-Negative-Product-in-a-Matrix" b
typedef long long ll;
class Solution {
    ll dp1[16][16];
    ll dp2[16][16];
    ll M = 1e9+7;
public:
    int maxProductPath(vector<vector<int>>& grid) 
    {
        int m = grid.size();
        int n = grid[0].size();
        
        dp1[0][0] = grid[0][0];
        dp2[0][0] = grid[0][0];
        
        for(int i=1; i<m; i++)
        {
            dp1[i][0] = dp1[i-1][0]*grid[i][0];
            dp2[i][0] = dp2[i-1][0]*grid[i][0];
        }
        
        for(int j=1; j<n; j++)
        {
            dp1[0][j] = dp1[0][j-1]*grid[0][j];
            dp2[0][j] = dp2[0][j-1]*grid[0][j];
        }
        
        for (int i=1; i<m; i++)
            for (int j=1; j<n; j++)
            {
                dp1[i][j] = max(max(dp1[i-1][j]*grid[i][j], dp2[i-1][j]*grid[i][j]), max(dp1[i][j-1]*grid[i][j], dp2[i][j-1]*grid[i][j]));
                dp2[i][j] = min(min(dp1[i-1][j]*grid[i][j], dp2[i-1][j]*grid[i][j]), min(dp1[i][j-1]*grid[i][j], dp2[i][j-1]*grid[i][j]));
            }
        if (dp1[m-1][n-1] < 0)
            return -1;
        else
            return dp1[m-1][n-1]%M;
        
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/1595.Minimum-Cost-to-Connect-Two-Groups-of-Points/Readme.md <==
snippet 1595.Minimum-Cost-to-Connect-Two-Groups-of-Points "1595.Minimum-Cost-to-Connect-Two-Groups-of-Points" b
### 1595.Minimum-Cost-to-Connect-Two-Groups-of-Points

我们要分析出几个概念。左边的第i个节点，可以与右边某个未被链接的节点j相连，这样i,j两个点都算被连接，一箭双雕。但是，i也可以与右边某个已经被链接的节点j相连，这种情况下j虽然看上去被链接了两次有点浪费，但是如果i-j这条边的权重很小，那么用很小的代价仅仅把i也拉进去也可能是实惠的。

如此看来，选择将i和右边的哪些点相连，并没有什么可以贪心的策略。所以这就让我们尝试用状态压缩的技巧来尝试所有i的链接方法。

令dp[i][state]表示左边前i个节点连接了右边的点集state时，所需要的最小代价。点集state就是“压缩的状态”，本质是一个二进制bit组，每一位bit表示所代表的节点是否已经被连接。

在解dp[i][state]这个问题时，我们的突破口就是第i个节点的决策。之前讨论过，它可以连接右边任意个未被连接的点，目的是最高效的使用这些边将两边都未被访问的节点都连起来。但是有时候，并没有足够小的边能满足这个要求，那么这个时候只能退而求其次，随便找条最小的边能把i连上就可以了。注意，这两种分支是不可能重合的，即不可能i既与右边还没连接的点相连，也与右边已经连接的点相连；这种情况下，后者的操作是每必要的。

对于前者的操作，那么i的决策对应的就是连接了state里面的某个非零子集，我们称之为subset。那么它的前驱状态就是dp[i-1][state-subset]，在本轮需要加上i与subset连接的代价。我们需要遍历所有可能的subset，找到dp[i-1][state-subset]+cost[i][subset]的最小值。

对于后者的操作，那么i连接的就是右边的某个已经被连接过的节点（必然是对i而言代价最小的边）。此策略的前驱状态就是dp[i-1][state]，因为i所连接的点并不是一个未曾方位过的点。

所以大致的框架就是：
```cpp
for (int i=0; i<m; i++)
  for (int state=0; state<(1<<n); state++)    
  {
    for (int subset : state)
      dp[i][state] = min{dp[i-1][state-subset] + cost[i][subset]};
    dp[i][state] = min(dp[i][state], dp[i-1][state] + minCost[i]);
  }
```
注意对于state的遍历嵌套subset的遍历，时间复杂度并不是``` 2^N * 2^N```，而是```3^N```。你可以想象，对于每一个bit，在外、里两层的状态只可能是```10,11,00```。

所以总的时间复杂度是: ```M*3^N```、注意，在新的test case中，我们需要提前计算并存储cost[i][subset]，表示第一个集合中的元素i与第二个集合中的subset配对需要的总cost。

对于遍历state的子集，有高效的循环方法需要掌握：
```cpp
for (int subset=state; subset>0; subset=(subset-1)&state)
```
PS：有同学问，第二种情况的代码是不是应该加一层条件：只找state里面存在的点。这么写确实是更严谨的。不过也可以认为不必要。第二种情况只有在第一种情况的最优解仍不够优秀的情况下才有意义。如果第二种得到的更优解对应的是一个未被访问的右边的点，那么这个点必然也会在第一种情况内被覆盖到。

$0
endsnippet

# ==> ./Dynamic_Programming/1595.Minimum-Cost-to-Connect-Two-Groups-of-Points/1595.Minimum-Cost-to-Connect-Two-Groups-of-Points.cpp <==
snippet 1595.Minimum-Cost-to-Connect-Two-Groups-of-Points "1595.Minimum-Cost-to-Connect-Two-Groups-of-Points" b
class Solution {
public:
    int connectTwoGroups(vector<vector<int>>& cost) 
    {
        int m = cost.size();
        int n = cost[0].size();
        cost.insert(cost.begin(), {0});
        
        vector<vector<int>>dp(m+1, vector<int>(1<<n, INT_MAX/2));
        dp[0][0] = 0;                
        
        vector<vector<int>>cost2(m+1, vector<int>(1<<n));
        for (int i=1; i<=m; i++)
            for (int state = 0; state<(1<<n); state++)
            {
                int sum = 0;
                for (int j=0; j<n; j++)
                {
                    if (((state>>j)&1)==1)
                        sum += cost[i][j];
                }
                cost2[i][state] = sum;
            }
                        
        for (int i=1; i<=m; i++)
        {
            dp[i][0] = INT_MAX/2;
            for (int state = 1; state < (1<<n); state++)
            {
                dp[i][state] = INT_MAX/2;
                for (int subset=state; subset>0; subset=(subset-1)&state)
                {
                    dp[i][state] = min(dp[i][state], dp[i-1][state-subset] + cost2[i][subset]);
                }
                
                int minPath = INT_MAX;
                for (int j=0; j<n; j++)
                    minPath = min(minPath, cost[i][j]);
                dp[i][state] = min(dp[i][state], dp[i-1][state] + minPath);                
            }
            
        }
        
        return dp[m][(1<<n)-1];
        
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/1621.Number-of-Sets-of-K-Non-Overlapping-Line-Segments/Readme.md <==
snippet 1621.Number-of-Sets-of-K-Non-Overlapping-Line-Segments "1621.Number-of-Sets-of-K-Non-Overlapping-Line-Segments" b
### 1621.Number-of-Sets-of-K-Non-Overlapping-Line-Segments

#### 解法1：

依据习惯，我们会定义dp[i][k]表示前i个点如果构造k条线段，总共有多少种方法。

我们考虑我们能如何处理第i个点。我们先考虑如果使用第i个点构造线段，那么以i为右端点的线段长度可以是1,2,...,i。如果这条线段的长度为1，那么dp[i][k]就取决于dp[i-1][k-1]，即前i-1个点构造k-1条线段有多少种方法。同理，如果这条线段的长度为2，那么dp[i][k]就取决于dp[i-2][k-1]... 综上，```dp[i][k] = sum {dp[j][k-1]} j=0,1,2...,i-1```

但是我们还需要考虑另一种情况：我们不使用第i个点构造线段，那么相当于以i为右端点往左看起，有一段空置的长度，这个长度同样可以是1,2,...,i-1。如果这条空置长度为1，那么dp[i][k]是否就取决于dp[i-1][k]呢？注意，答案是否定的。因为根据dp[i-1][k]的定义，它的计数包括了第i-1个点没有被用来构造线段的情况。如果第i-1个点没有被用来构造线段，那么之前假定的“以i为右端点的、空置长度为1”就不再成立。这样的计数是有问题的。

所以解决方法是什么呢？那就是对于dp[i][k]的计数要分成两种情况来：用dp0[i][k]表示第i个点没有被用来构造线段时、前i个点构造出k条线段的方案数；用dp1[i][k]表示第i个点被用来构造线段时、前i个点构造出k条线段的方案数。同时作为两者的总和，```dp[i][k] = dp0[i][k] + dp1[i][k]```。

对于dp1[i][k]而言，我们分类的依据就是第i个点被用来构造线段时的长度。根据长度的范围1,2,...i，我们依然有```dp1[i][k] = sum {dp[j][k-1]} j=0,1,2...,i-1```。注意等式后面的是dp。

对于dp0[i][k]而言，我们分类的依据就是第i个点没有被用来构造线段，那么它之前的空置长度。根据空置长度的范围1,2,...i，分别对应的是第i-1个点、第i-2个点...需要被用来构造线段。所以我们有```d0[i][k] = sum {dp1[j][k-1]} j=0,1,2...,i-1```。

所以大致的状态转移框架就是：
```cpp
for (int i=0; i<n; i++)
  for (int k=0; k<=i; k++)
  {
    for (int j=0; j<i; j++)
    {
      dp1[i][k] += dp0[j][k-1] + dp1[j][k-1];
      dp0[i][k] += dp1[j][k];
    }
  }
```
最终的答案是```dp0[n-1][k]+dp1[n-1][k]```.

上述的时间复杂度是O(N^3)，会超时。如何改进呢？其实内循环所累加的就是dp0[...][k]和dp1[...][k]关于第一个下标的前缀和（从0到i-1）.所以我们可以维护一个前缀和数组sum0[i][k]，表示从dp[0][k]累加到dp[i][k]，类似的也可以定义sum1[i][k]. 于是我们改进一下：

```cpp
for (int i=0; i<n; i++)
  for (int k=0; k<=i; k++)
  {
    dp1[i][k] = sum0[i-1][k-1] + sum1[i-1][k-1];
    dp0[i][k] = sum1[i-1][k]
  
    sum0[i][k-1] = sum0[i-1][k-1] + dp0[i][k-1];
    sum1[i][k] = sum1[i-1][k] + dp1[i][k];
  }
```
在每次循环中，处理完dp[i][k]后记得更新一下sum0[i][k-1]和sum1[i][k]。这样的时间复杂度就降为了o(N^2).

对于初始条件，我们需要注意的是dp0[i][0]，前i个点构造0条线段，方法数就是1；相应地，sum0[i][0] = i+1;

#### 解法2：
我们仍然可以定义dp[i][k]表示前i个点如果构造k条线段，总共有多少种方法。

当我们考察第i个点用来构造线段时，dp[i][k]依然可以写作```dp[i][k] = sum {dp[j][k-1]} j=0,1,2...,i-1```

当我们考察第i个点不用来构造线段时，可以不必想解法1那样想得复杂。事实上，这种情况下就有```dp[i][k] = dp[i-1][k]```.我们不需要根据空置长度来分类。

因此，总的状态转移方程是：```dp[i][k] = dp[i-1][k] + sum {dp[j][k-1]} j=0,1,2...,i-1```. 我们只需要定义一个前缀和数组 sum[i][k]表示dp[0..i][k]的和。
```cpp
        for (int i=1; i<n; i++)
            for (int k=1; k<=min(i,K); k++)
            {
                dp[i][k] += dp[i-1][k] + sum[i-1][k-1];            
                sum[i][k] = sum[i-1][k] + dp[i][k];
            }
```

$0
endsnippet

# ==> ./Dynamic_Programming/1621.Number-of-Sets-of-K-Non-Overlapping-Line-Segments/1621.Number-of-Sets-of-K-Non-Overlapping-Line-Segments.cpp <==
snippet 1621.Number-of-Sets-of-K-Non-Overlapping-Line-Segments "1621.Number-of-Sets-of-K-Non-Overlapping-Line-Segments" b
class Solution {
    long dp0[1001][1001];    
    long dp1[1001][1001];    
    long sum0[1001][1001];
    long sum1[1001][1001];
    long M = 1e9+7; 

public:
    int numberOfSets(int n, int K) 
    {
        for (int i=0; i<n; i++)
        {
            dp0[i][0] = 1;
            sum0[i][0] = i+1;
        }

        for (int i=1; i<n; i++)
            for (int k=1; k<=min(i,K); k++)
            {
                dp1[i][k] = sum0[i-1][k-1] + sum1[i-1][k-1];
                dp0[i][k] = sum1[i-1][k];
            
                sum0[i][k-1] = sum0[i-1][k-1] + dp0[i][k-1];
                sum1[i][k] = sum1[i-1][k] + dp1[i][k];

                sum0[i][k-1] %= M;
                sum1[i][k] %= M;
            }
        return (dp0[n-1][K]+dp1[n-1][K])%M;       
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/1621.Number-of-Sets-of-K-Non-Overlapping-Line-Segments/1621.Number-of-Sets-of-K-Non-Overlapping-Line-Segments_v2.cpp <==
snippet 1621.Number-of-Sets-of-K-Non-Overlapping-Line-Segments "1621.Number-of-Sets-of-K-Non-Overlapping-Line-Segments" b
class Solution {
    long dp[1001][1001];    
    long sum[1001][1001];
    long M = 1e9+7; 

public:
    int numberOfSets(int n, int K) 
    {
        for (int i=0; i<n; i++)
        {
            dp[i][0] = 1;
            sum[i][0] = i+1;
        }

        for (int i=1; i<n; i++)
            for (int k=1; k<=min(i,K); k++)
            {
                dp[i][k] += sum[i-1][k-1];
                dp[i][k] += dp[i-1][k];
                dp[i][k] %= M;
            
                sum[i][k] = sum[i-1][k] + dp[i][k];
                sum[i][k] %= M;
            }
        return dp[n-1][K]%M;       
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/1626.Best-Team-With-No-Conflicts/Readme.md <==
snippet 1626.Best-Team-With-No-Conflicts "1626.Best-Team-With-No-Conflicts" b
### 1626. Best Team With No Conflicts

将所有的队员按照年纪排序之后，我们很容易发现，所选的队员需要按照能力值呈现一个递增的序列。这就和longest increasing subsequence非常相似。只不过我们的objective不是长度，而是sum。

状态转移方程如下：
```
dp[i] = max{dp[j]+score[i]} for all j s.t. age[j]<=age[i]
```

$0
endsnippet

# ==> ./Dynamic_Programming/1626.Best-Team-With-No-Conflicts/1626.Best-Team-With-No-Conflicts.cpp <==
snippet 1626.Best-Team-With-No-Conflicts "1626.Best-Team-With-No-Conflicts" b
class Solution {
    int dp[1000];
public:
    int bestTeamScore(vector<int>& scores, vector<int>& ages) 
    {
        int n = scores.size();
        vector<pair<int,int>>players(n);
        for (int i=0; i<n; i++)
            players[i] = {ages[i], scores[i]};
        sort(players.begin(), players.end());
        
        
        dp[0] = players[0].second;
        for (int i=1; i<n; i++)
        {          
            dp[i] = players[i].second;
            for (int j=0; j<i; j++)
            {
                if ((players[j].first < players[i].first && players[j].second <= players[i].second) || players[j].first == players[i].first)
                    dp[i] = max(dp[i], dp[j]+players[i].second);
            }                
        }
        
        int ret = 0;
        for (int i=0; i<n; i++)
            ret = max(ret, dp[i]);
        
        return ret;
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/1638.Count-Substrings-That-Differ-by-One-Character/Readme.md <==
snippet 1638.Count-Substrings-That-Differ-by-One-Character "1638.Count-Substrings-That-Differ-by-One-Character" b
### 1638.Count-Substrings-That-Differ-by-One-Character

最初的感觉可能是一道双序列型的DP。所以我首先写出的是状态变量dp[i][j]，表示字符串s的前i个、字符串t的前j个能有多少种答案。接下来我就会考虑如何从s[i]和t[j]下手：怎么样能使得s[i]和t[j]是符合要求的substring的一部分？

我发现，当s[i]!=t[j]的时候，我们不得不计算s[i]和t[j]之前有多少个连续的、相等的字符的个数a。这个时候灵光一现，如果我们也计算出s[i]和t[j]之后有多少个连续的、相等的字符的个数b，那么我们其实就解决了一类符合题意的substring的pattern：那就是以s[i]和t[j]做为“Differ by One Character”的位置，那么这样的字符串其实就是有```(a+1)*(b+1)```个。事实上，所有的符合条件的substring都可以归为若干类，每一类都有着相同的“Differ by One Character”的位置(i,j).

所以至此，本题的思路就有了。我们遍历所有的配对(i,j)，如何s[i]!=t[j]，那么我们就计算相应的a和b（定义见前），然后```ret+=(a+1)*(b+1)```.至于a和b，显然我们提前计算出来。令dp1[i][j]表示s[i]和t[j]之前的最长的相同substring（包括s[i]和t[j]本身）；令dp2[i][j]表示s[i]和t[j]之后的最长的相同substring（包括s[i]和t[j]本身）。这两个量都很容易用动态规划来解决。

$0
endsnippet

# ==> ./Dynamic_Programming/1638.Count-Substrings-That-Differ-by-One-Character/1638.Count-Substrings-That-Differ-by-One-Character.cpp <==
snippet 1638.Count-Substrings-That-Differ-by-One-Character "1638.Count-Substrings-That-Differ-by-One-Character" b
class Solution {
    int dp1[102][102];
    int dp2[102][102];
public:
    int countSubstrings(string s, string t) 
    {
        int m = s.size(); 
        int n = t.size();
        s = "#"+s+"#";
        t = "#"+t+"#";
        
        for (int i=1; i<=m; i++)
            for (int j=1; j<=n; j++)
            {
                if (s[i]==t[j])
                    dp1[i][j] = dp1[i-1][j-1]+1;
                else
                    dp1[i][j] = 0;                
            }
        
        cout<<"OK"<<endl;
        for (int i=m; i>=1; i--)
            for (int j=n; j>=1; j--)
            {
                if (s[i]==t[j])
                    dp2[i][j] = dp2[i+1][j+1]+1;
                else
                    dp2[i][j] = 0;
            }
        
        int ret = 0;
        for (int i=1; i<=m; i++)
            for (int j=1; j<=n; j++)
            {
                if (s[i]!=t[j])
                    ret += (dp1[i-1][j-1]+1)*(dp2[i+1][j+1]+1);
            }
        return ret;
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/1639.Number-of-Ways-to-Form-a-Target-String-Given-a-Dictionary/Readme.md <==
snippet 1639.Number-of-Ways-to-Form-a-Target-String-Given-a-Dictionary "1639.Number-of-Ways-to-Form-a-Target-String-Given-a-Dictionary" b
### 1639.Number-of-Ways-to-Form-a-Target-String-Given-a-Dictionary

此题有点类似1621的感觉。令dp[i][k]表示我们只构建构建target[0:i]，并且最多用到dictionary里面（所有词）的第k个字母，有多少种方案。根据套路，突破口依然是target的第i个字母、词库里的第k个字母。

首先，第一种情况是，target[0:i]的选择根本不考虑词库里的第k个字母，完全靠第0~k-1个字母来构造，那么就有```dp[i][k] = dp[i][k-1]```。

第二种情况是，如果词库里有一些单词的第k个字母与target[i]相同，那么我们可以考虑target[i]用它们来构造，因此有额外的方案```dp[i][k] += dp[i-1][k-1]*count[k]```，其中count[k]表示词库里有多少单词的第k个字母与target[i]相同。

最终的答案就是dp[n][m]. 其中n是target的长度，m是词库里最长的单词长度。

$0
endsnippet

# ==> ./Dynamic_Programming/1639.Number-of-Ways-to-Form-a-Target-String-Given-a-Dictionary/1639.Number-of-Ways-to-Form-a-Target-String-Given-a-Dictionary.cpp <==
snippet 1639.Number-of-Ways-to-Form-a-Target-String-Given-a-Dictionary "1639.Number-of-Ways-to-Form-a-Target-String-Given-a-Dictionary" b
class Solution {
    long long p[1005][27];
    long long dp[1005][1005];
    long long M = 1e9+7;
public:
    int numWays(vector<string>& words, string target) 
    {
        int m = 0;
        for (auto word: words)
        {
            m = max(m, (int)word.size());
            for (int i=0; i<word.size(); i++)                
                p[i+1][word[i]-'a']+=1;
        }
                    
        int n = target.size();
        target = "#"+target;
        for (int k=0; k<=m; k++)
            dp[0][k] = 1;
        
        for (int i=1; i<=n; i++)
            for (int k=1; k<=m; k++)
            {
                dp[i][k] = dp[i][k-1];
                if (p[k][target[i]-'a']!=0)
                {
                    dp[i][k] += dp[i-1][k-1]*p[k][target[i]-'a']%M;
                    dp[i][k]%=M;
                }
                
            }
        return dp[n][m];        
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/1655.Distribute-Repeating-Integers/Readme.md <==
snippet 1655.Distribute-Repeating-Integers "1655.Distribute-Repeating-Integers" b
### 1655.Distribute-Repeating-Integers

本题的翻译是：由原始的数组nums可以搞出一个新数组count，其中count[i]表示第i件物品的个数。我们要满足一系列客户quantity，每个客户需要quantity[i]个一样的物品。问是否能够合理分配物品给客户，使得所有客户都得到满足。

我们注意到m<10，这样小的条件几乎就是暗示我们会有算法复杂度关于2^m，那么明显可以想到bitmask，利用m位的二进制数就可以表示穷举出所有客户满意的状态（数值为1的bit表示对应的客户得到了满足）。另外题目中there are at most 50 unique values in the array的意思就是，count数组的长度不超过50，即物品的个数不超过50. 由此我们联想到了状态压缩的动态规划：令dp[i][state]表示前i件物品是否可以满足state状态的客户需求。

如何设计状态转移方程来计算dp[i][state]呢？依然是动态规划的套路，从第i件物品入手。我们考虑第i件物品的数量能够满足state里面的哪些客户？显然这些客户必然是state里面的一个子集。所以dp[i][state]为true的两个条件是：
1. 我们能找到state里面的一个子集subset，其对应的客户需求的物品总数都能被第i件物品所满足，
2. 并且对应的前驱状态dp[i-1][state-subset]也为true，即前i-1件物品能满足state-subset所对应的客户（即除去第i件物品满足的subset客户）。
以上两个条件都满足的话，那么就说明前i件物品能满足state对应的所有客户需求。

特别需要注意的是，dp[i][state]为true其实还有另外一种方式：就是如果dp[i-1][state]已经为true的话，我们甚至可以跳过subset的搜索。

关于时间复杂度：对于state的遍历里面再嵌套subset的遍历，时间复杂度并不是 2^m * 2^m，而是3^m。你可以想象，对于每一个bit，在外、里两层的状态只可能是10,11,00，而不可能出现01。所以总的时间复杂度是```o(N*m*3^m)```

$0
endsnippet

# ==> ./Dynamic_Programming/1655.Distribute-Repeating-Integers/1655.Distribute-Repeating-Integers.cpp <==
snippet 1655.Distribute-Repeating-Integers "1655.Distribute-Repeating-Integers" b
class Solution {
    bool dp[51][1024];
public:
    bool canDistribute(vector<int>& nums, vector<int>& quantity) 
    {
        unordered_map<int,int>Map;
        for (auto x: nums)
            Map[x]++;
        vector<int>count;
        for (auto x: Map)
            count.push_back(x.second);
        
        int n = count.size();
        int m = quantity.size();        
        
        count.insert(count.begin(), 0);
                
        for (int i=0; i<=n; i++)
            dp[i][0] = true;
        
        for (int i=1; i<=n; i++)
            for (int state=1; state<(1<<m); state++)
            {
                if (dp[i-1][state]==true) 
                {
                    dp[i][state] = true;
                    continue;
                }                    
                
                for (int subset=state; subset>0; subset=(subset-1)&state)
                {
                    if (dp[i-1][state-subset]==false) continue;
                    if (canSatisfySubset(count[i], quantity, subset))
                    {
                        dp[i][state] = true;
                        break;
                    }
                }
            }
        return dp[n][(1<<m)-1];
        
    }
    
    bool canSatisfySubset(int count, vector<int>& quantity, int subset)
    {
        int m = quantity.size();
        int sum = 0;
        for (int i=0; i<m; i++)
        {
            if ((subset>>i)&1)
                sum += quantity[i];
        }
        return count>=sum;
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/1659.Maximize-Grid-Happiness/Readme.md <==
snippet 1659.Maximize-Grid-Happiness "1659.Maximize-Grid-Happiness" b
### 1659.Maximize-Grid-Happiness

我们看到这题里的维度m和n出奇地小，竟然不超过5，就有预感算法可能和暴力枚举有关，必然不用考虑去人工设计最优解。

分析矩阵的每个位置有三种可能：不放人、内向人、外向人，因此25个格子的话就会有3^25种可能，这个数据量仍然太大。这个时候我发现3^5=243很小，立刻想到了类似1349. Maximum Students Taking Exam的做法，就是以整行为状态进行枚举，似乎是个可行的思路：因为当前行某种状态对应的最优值，只与上一行状态有关（也就是内向人、外向人的各种相邻关系），而与再前一行就无关了。

于是首先就能想到设计dp[i][state]，表示第i行的安排为state时能够得到的最优值，其中state是一个三进制的整数，每个bit上为0时表示不放人，为1时表示放外向人，为2时表示放内向人。状态转移方程就是考察当前行状态state与上一行状态prevState之间的制约关系。即
```
for (int i=1; i<=m; i++)
  for (int state = 0; state < (1<<m); state++)
  {
      for (int prevState = 0; prevState < (1<<m); prevState++)
        dp[i][state] = max(dp[i][state] + addVal(prevState, state);
  }
```
其中```addVal(prevState, state)```表示在前一行是prevState的方案的基础上，当前行安排为state的话，可以增加多少价值。这些价值的来源产生自这些：
1. 当前行的外向人基本分，如果左、上、右有人相邻的话，额外加分
2. 当前行的内向人基本分，如果左、上、右有人相邻的话，额外减分
3. 上一行的外向人如果下邻居有人，那么要额外加分
4. 上一行的内向人如果下邻居有人，那么要额外减分

但是以上的算法有一个漏洞，那就是我们有外向人、内向人总人数的制约。dp[i][state]并不能看出外向人、内向人的总人数是否已经爆了。所以我们要额外增加两个维度x,y，用dp[i][x][y][state]表示当前第i行采用state的方案，并且截止目前外向人总数是x、内向人总数是y时，能够收获的最大值。因此更新dp[i][x][y][state]时，要先计算出当前行的外向人和内向人的人数a与b，仅枚举合法的dp[i-1][x-a][y-b][prevState]来更新dp[i][x][y][state]。其中要求x>=a，y>=b。

最终的答案是遍历到最后一行时dp[m][x][x][x]的最大值，其中x都可以任意。


$0
endsnippet

# ==> ./Dynamic_Programming/1659.Maximize-Grid-Happiness/1659.Maximize-Grid-Happiness.cpp <==
snippet 1659.Maximize-Grid-Happiness "1659.Maximize-Grid-Happiness" b
class Solution {
    int dp[6][7][7][243];
    int N;
    int a[6];
    int b[6];
public:
    int getMaxGridHappiness(int m, int n, int introvertsCount, int extrovertsCount) 
    {
        this->N = n;
        int MAX_State = pow(3,n);
        for (int row = 0; row <= m; row++)
            for (int x = 0; x<=introvertsCount; x++)
                for (int y = 0; y<=extrovertsCount; y++)
                    for (int state = 0; state < MAX_State; state++)
                        dp[row][x][y][state] = INT_MIN/2;
        
        dp[0][0][0][0] = 0;
        int ret = 0;
        
        for (int row = 1; row <= m; row++)
            for (int x = 0; x<=introvertsCount; x++)
                for (int y = 0; y<=extrovertsCount; y++)
                    for (int state = 0; state < MAX_State; state++)
                    {
                        auto [count1, count2] = countPeople(state);
                        if (x<count1 || y<count2) continue;
                        int xx = x - count1;
                        int yy = y - count2;

                        for (int preState = 0; preState < MAX_State; preState++)
                        {
                            if (dp[row-1][xx][yy][preState]==INT_MIN/2) continue;
                            int val = computeScore(preState, state);
                            dp[row][x][y][state] = max(dp[row][x][y][state], dp[row-1][xx][yy][preState] + val);
                        }
                        
                        if (row==m) ret = max(ret, dp[row][x][y][state]);                            
                    }
        
        return ret;
    }

    pair<int,int> countPeople(int state)
    {
        int count1 = 0, count2 = 0;
        for (int i=0; i<N; i++)
        {
            if (state%3==1)
                count1++;
            else if (state%3==2)                
                count2++;
            state /= 3;
        }
        return {count1, count2};
    }
    
    int computeScore(int pre, int cur)
    {
        int ret = 0;        
        for (int i=0; i<N; i++)
        {
            a[i] = pre%3;
            pre/=3;
            b[i] = cur%3;
            cur/=3;
        }
        for (int i=0; i<N; i++)
        {
            if (b[i]==1)
            {
                ret += 120;
                if (i>=1 && b[i-1]>0) ret-=30;
                if (i<N-1 && b[i+1]>0) ret-=30;
                if (a[i]>0) ret-=30;
                if (a[i]==1) ret-=30;
                else if (a[i]==2) ret+=20;
            }
            else if (b[i]==2)
            {
                ret += 40;
                if (i>=1 && b[i-1]>0) ret+=20;
                if (i<N-1 && b[i+1]>0) ret+=20;
                if (a[i]>0) ret+=20;
                if (a[i]==1) ret-=30;
                else if (a[i]==2) ret+=20;
            }
        }
        return ret;
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/1681.Minimum-Incompatibility/Readme.md <==
snippet 1681.Minimum-Incompatibility "1681.Minimum-Incompatibility" b
### 1681.Minimum-Incompatibility

#### 解法1：DFS
本题初看有一种错觉，以为小的数字应该尽量和小的数字分在一组，大的数字应该尽量和大的数字分在一组。但是这个贪心策略不成立。比如：```[1,1,2,2,3,3,6,8]，4```, 贪心策略得到```[1,2],[1,2],[3,6],[3,8]```，但是最优的答案是```[1,2],[1,3],[2,3],[6,8]```.

结合本题的提示nums.size()<16，说明这题只能用暴力探索。

首先我们判定一下无解的情况：当任何一个元素出现的次数大于k的话，说明至少有一组会重复出现两次该元素。于是可以提前返回false。

在排除无解的情况后，我们就可以放心地用DFS暴力搜索：在数组里连续搜索到n/k个不同的元素后，再从头开始搜索找n/k个不同的元素，直至所有的数组元素都搜到。

dfs搜索算法中有一个常见而且非常重要的剪枝技巧。比如nums = [1,2,2,3,4,6], k=2, 当你搜索完[1,2,x]之后，不会为第二个数再次搜索2。所以需要在搜索第二个数的时候，用一个last来避免重复搜到相同的数。

#### 解法2：状态压缩
对于每一组，我们要选取n个元素中的n/k个，我们将每种选择方法看做是用01bit表示的state。可知，这样的state总共有C(n, n/k)种。然后我们会删掉其中含有重复元素的state，剩下的state可以放入一个states数组，记它的大小是m。

于是此时我们等于需要解一个背包问题。我们要在states的m种状态中选择k种，使得拼接起来的总状态恰好是```111..111```，同时希望incompatibility的总和最小。大致的算法是：
```cpp
for (int i=0; i<m; i++)
  for (int dpstate=(1<<n)-1; dpstate>0; dpstate--)
    {
      if (states[i]不是dpstate的子集) continue;
      dp[dpstate] = min(dp[dpstate], dp[dpstate - states[i]] + incompatibility[i]);
    }
```
上面的算法会超时，原因是dpstate会遍历到大量显然不合法的状态：因为dpstate是选择若干个互斥的state的拼接得到，故dpstate里面的1bit的数目必须是n/k的整数倍。所以我们可以提前仅把合法的dpstate放入一个dpstates的数组，来替换第二层循环。


$0
endsnippet

# ==> ./Dynamic_Programming/1681.Minimum-Incompatibility/1681.Minimum-Incompatibility_v1.cpp <==
snippet 1681.Minimum-Incompatibility "1681.Minimum-Incompatibility" b
class Solution {
    int n;
    int k;
    vector<int>visited;
    int ret = INT_MAX;
public:
    int minimumIncompatibility(vector<int>& nums, int k) 
    {
        unordered_map<int,int>count;
        for (auto x: nums)
            count[x]++;
        for (auto x: count)
            if (x.second > k)
                return -1;

        sort(nums.begin(), nums.end());
        this->k = k;
        this->n = nums.size();               
        visited.resize(n);
        
        visited[0] = 1;
        dfs(nums, 0, 1, nums[0], nums[0], 0);
        
        return ret;
    }
    
    void dfs(vector<int>& nums, int cur, int count, int low, int high, int sum)
    {
        if (count==n/k)
        {
            int j=0;
            while (j<n && visited[j]==1)
                j++;
            if (j==n)
            {
                ret = min(ret, sum+high-low);
            }
            else
            {
                visited[j]=1;
                dfs(nums, j, 1, nums[j], nums[j], sum+high-low);
                visited[j]=0;
            }
        }
        else
        {
            int last = -1;
            for (int i=cur+1; i<n; i++)
            {
                if (visited[i]==1) continue;
                if (nums[i]==nums[cur]) continue;
                if (i>cur+1 && nums[i]==last) continue;
                visited[i] = 1;
                dfs(nums, i, count+1, low, nums[i], sum);
                last = nums[i];
                visited[i] = 0;
            }            
        }
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/1681.Minimum-Incompatibility/1681.Minimum-Incompatibility_v2.cpp <==
snippet 1681.Minimum-Incompatibility "1681.Minimum-Incompatibility" b
class Solution {
    int n;
public:
    int minimumIncompatibility(vector<int>& nums, int k) 
    {
        unordered_map<int,int>count;
        for (auto x: nums)
            count[x]++;
        for (auto x: count)
            if (x.second > k)
                return -1;

        n= nums.size();        
        vector<int>states;
        vector<int>values;
        int state = (1 << n/k) - 1;            
        while (state < (1 << n))
        {
            int val;
            if (!containDuplicate(nums, state, val))
            {
                states.push_back(state);
                values.push_back(val);                
            }
            
            int c = state & - state;
            int r = state + c;
            state = (((r ^ state) >> 2) / c) | r;
        }

        vector<int>dpstates;
        for (int state=0; state<(1<<n); state++)
        {
            if (__builtin_popcount(state) % (n/k) ==0) 
                dpstates.push_back(state);
        }
        reverse(dpstates.begin(), dpstates.end());
        
        vector<int>dp(1<<n, INT_MAX/2);
        dp[0] = 0;

        for (int i=0; i<states.size(); i++)
        {            
            for (auto dpstate: dpstates)
            {                
                if ((dpstate & states[i])!=states[i]) continue;
                dp[dpstate] = min(dp[dpstate], dp[dpstate-states[i]]+values[i]);
            }
        }
        return dp[(1<<n)-1];
    }

    bool containDuplicate(vector<int>&nums, int state, int&val)
    {
        vector<int>p;
        for (int i=0; i<n; i++)
        {
            if ((state>>i)&1)
                p.push_back(nums[i]);
        }
        sort(p.begin(),p.end());
        for (int i=1; i<p.size(); i++)
            if (p[i]==p[i-1]) return true;
        val = p.back()-p.front();
        return false;
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/1682.Longest-Palindromic-Subsequence-II/Readme.md <==
snippet 1682.Longest-Palindromic-Subsequence-II "1682.Longest-Palindromic-Subsequence-II" b
### 1682.Longest-Palindromic-Subsequence-II

在```516.Longest-Palindromic-Subsequence```中我们采用区间型dp，令dp[i][j]表示区间[i:j]内的最长回文长度。在本题为了解决“相邻的嵌套pair不能相同的问题”，我们定义dp[i][j][k]表示区间[i:j]内、最外层是字母k的最长回文长度。

如何更新dp[i][j][k]呢？我们不着急思考k。我们先想一下区间[i:j]，如果s[i]==s[j]==a的话意味着什么呢？我们对于dp[i][j][k]的更新分为三类：
1. dp[i][j][a]就可以更新为```max{dp[i+1][j-1][kk]+2} for kk!=a```. 
2. 对于k!=a的字母，dp[i][j][k]可以更新为dp[i+1][j-1][k]，这是因为最外层{i,j}肯定不会贡献一对k，故可以直接剥去。

如果s[i]!=s[j]的话，令s[i]=a, s[j]=b，那么dp[i][j][k]的更新同样分为三类：
1. dp[i][j][a] = dp[i][j-1][a]，因为元素j不会提供字母a。
2. dp[i][j][b] = dp[i+1][j][a]，因为元素i不会提供字母b。
3. for k!=a && k!=b 的字母, 我们有 dp[i][j][k] = dp[i+1][j-1][k]，因为最外层{i,j}肯定不会贡献一对k

综上，时间复杂度是```O(N^2*26)```

$0
endsnippet

# ==> ./Dynamic_Programming/1682.Longest-Palindromic-Subsequence-II/1682.Longest-Palindromic-Subsequence-II_v1.cpp <==
snippet 1682.Longest-Palindromic-Subsequence-II "1682.Longest-Palindromic-Subsequence-II" b
class Solution {
    int dp[250][250][26];
public:
    int longestPalindromeSubseq(string s) 
    {
        int n = s.size();
        for (int i=0; i+1<n; i++)
        {
            if (s[i]==s[i+1])
                dp[i][i+1][s[i]-'a'] = 2;
        }
        
        for (int len=3; len<=n; len++)
            for (int i=0; i+len-1<n; i++)
            {
                int j = i+len-1;
                for (int k=0; k<26; k++)
                {
                    if (s[i]==s[j] && s[i]=='a'+k)
                    {
                        for (int kk=0; kk<26; kk++)
                            if (kk!=k)
                                dp[i][j][k] = max(dp[i][j][k], dp[i+1][j-1][kk]+2);
                    }
                    dp[i][j][k] = max(dp[i][j][k], dp[i+1][j][k]);
                    dp[i][j][k] = max(dp[i][j][k], dp[i][j-1][k]);
                }
            }
        
        int ret = 0;
        for (int k=0; k<26; k++)
            ret = max(ret, dp[0][n-1][k]);
        return ret;        
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/1682.Longest-Palindromic-Subsequence-II/1682.Longest-Palindromic-Subsequence-II_v2.cpp <==
snippet 1682.Longest-Palindromic-Subsequence-II "1682.Longest-Palindromic-Subsequence-II" b
class Solution {
    int dp[250][250][26];
public:
    int longestPalindromeSubseq(string s) 
    {
        int n = s.size();
        for (int i=0; i+1<n; i++)
        {
            if (s[i]==s[i+1])
                dp[i][i+1][s[i]-'a'] = 2;
        }
        
        for (int len=3; len<=n; len++)
            for (int i=0; i+len-1<n; i++)
            {
                int j = i+len-1;
                int a = s[i]-'a';
                int b = s[j]-'a';
                if (s[i]==s[j])
                {
                    for (int kk=0; kk<26; kk++)
                    {
                        if (a != kk)
                            dp[i][j][a] = max(dp[i][j][a], dp[i+1][j-1][kk]+2);
                    }
                    for (int k=0; k<26; k++)
                    {
                        if (a != k)
                            dp[i][j][k] = dp[i+1][j-1][k];
                    }
                }
                else
                {
                    dp[i][j][a] = dp[i][j-1][a];
                    dp[i][j][b] = dp[i+1][j][b];
                    for (int k=0; k<26; k++)
                    {
                        if (k!=a && k!=b)
                            dp[i][j][k] = dp[i+1][j-1][k];
                    }
                }
            }
        
        int ret = 0;
        for (int k=0; k<26; k++)
            ret = max(ret, dp[0][n-1][k]);
        return ret;        
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/1690.Stone-Game-VII/Readme.md <==
snippet 1690.Stone-Game-VII "1690.Stone-Game-VII" b
### 1690.Stone-Game-VII

本题和1563.Stone-Game-V类似，典型的区间型DP。令dp[i][j]表示我方在先手处理[i:j]时可以得到的最多的、领先对手的分差。注意，这里的分差是相对于对手在这个区间内的得分而言。

我方在处理[i:j]区间时就两种选择。

第一种是我方选择第i个元素。这样我方在本轮得分sum[i+1:j]，之后的局势是对方处理[i+1:j]，从递归的角度来看，对手可以在此区间内领先我方的最大分差是dp[i+1][j]。所以回溯到本轮，我方先手处理[i:j]区间能够得到的最大分差就是sum[i+1:j]-dp[i+1:j].

第二种是我方选择第j个元素，同理我方可以得到的最大分差就是sum[i:j-1]-dp[i:j-1]。

综上，我方会在上面两种方案中选择更优的一种。

最后答案的输出就是dp[1:n].

$0
endsnippet

# ==> ./Dynamic_Programming/1690.Stone-Game-VII/1690.Stone-Game-VII.cpp <==
snippet 1690.Stone-Game-VII "1690.Stone-Game-VII" b
class Solution {
    int dp[1005][1005];
public:
    int stoneGameVII(vector<int>& stones) 
    {
        int n = stones.size();
        stones.insert(stones.begin(), 0);
        
        vector<int>presum(n+2,0);
        for (int i=1; i<=n; i++)
            presum[i] = presum[i-1] + stones[i];        
        
        for (int i=1; i<=n; i++)
            dp[i][i] = 0;
        for (int i=1; i+1<=n; i++)
            dp[i][i+1] = max(stones[i], stones[i+1]);
                
        for (int len = 3; len<=n; len++)
        {
            for (int i=1; i+len-1<=n; i++)
            {
                int j = i+len-1;
                dp[i][j] = max(presum[j]-presum[i] - dp[i+1][j], presum[j-1]-presum[i-1] - dp[i][j-1]);
            }
        }
        return dp[1][n];        
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/1691.Maximum-Height-by-Stacking-Cuboids/Readme.md <==
snippet 1691.Maximum-Height-by-Stacking-Cuboids "1691.Maximum-Height-by-Stacking-Cuboids" b
### 1691.Maximum-Height-by-Stacking-Cuboids

#### 解法1
因为题目允许任意旋转长方体，我们尝试将每个长方体的六个旋转变种都考虑进来。这样总共有6n个cuboids。

因为从下往上堆叠的次序必须是按照长度递减的，所以我们自然会将所有的6n个cuboids按照长度降排列。那么对于长度相同的长方体呢？我们可以再按宽度降序排列；对于宽度也相同的长方体，按照高度降序排列。这样，符合要求的堆叠方案必然是这个序列的一个subsequece。注意，并不是说这个序列的任何一个subsequence都是符合要求的堆叠方案。

接下来，从这个降序序列里面找总高度最大的序列，类似于求LIS的做法。令dp[i]表示以i为最上层长方体的堆叠总高度。
```cpp
for (int i=0; i<6*n; i++)
{
  dp[i] = height[i];
  for (int j=0; j<n; j++)
    if (length[j]<=length[j] && width[j]<=width[i] && height[j]<=height[i])
      dp[i] = max(dp[i], dp[j]+height[i]);
}
```
但此时有一个问题，如何保证我们选取的这个LIS里不含有同一个长方体的若干个变体呢？事实上，通常情况下这个并不会发生，因为同一个长方体c的任何两个变体c1和c2，不可能实现c1在c2上的顺利堆叠。举个例子，令长方体的三条边为L>M>S，那么我们按照高的选择分类为三种：
```
c1: base (L,M), height (S)
c2: base (L,S), height (M)
c3: base (M,S), height (L)
```
如果按照高度的约束来看，这三种变体的堆叠只能是c1在c2上、c2在c3上。但是从底面积的约束来看，必须是c3在c2上、c2在c1上。这个是矛盾的。所以在两层循环里，我们通常是无法找到一对符合条件i和j恰好是同一个长方体的变体。

但是以上有个问题，就是如果M==S的话，那么c1和c2就长得完全一样，那么仍有可能动态规划的时候会把c1放在c2之上。解决方案是给每个长方体带上原始的编号信息，并作为第四个下标参与排序。这样的话，两个相同的长方体变种一定会相邻，并且在探索i和j配对的时候通过这个编号信息(```&&idx[i]!=idx[j]```)来排除这样的配对。

#### 解法2
我们考虑一个合法的堆叠A(a1,a2,a3)可以放在B(b1,b2,b3)之上，即a1<=b1, a2<=b2, a3<=b3. 那么可以证明max(a1,a2,a3) <= max(b1,b2,b3), mid(a1,a2,a3) <= mid(b1,b2,b3), min(a1,a2,a3) <= min(b1,b2,b3). 第一个和第三个结论显然，第二个结论通过反正：如果不是的话，是无法同时存在条件中的三个不等式的。

于是我们发现，只要A可以放在B之上，那么A的变体(min(a1,a2,a3), mid(a1,a2,a3), max(a1,a2,a3))也一定可以放在B的变体(min(b1,b2,b3), mid(b1,b2,b3), max(b1,b2,b3))之上。所以对于任何一个合法的堆叠序列，我们都可以将其中的每个长方体变化为：最短边作为length、中等边作为width、最长边作为height。变化之后，原序列依然是一个合法的堆叠，而且总高度只增不减。所以重新考虑原题，最优的解一定是把每个长方体的最长边作为height。所以对于每种长方体，我们只需要选择如上的这一种变体即可，我们能够保证：一定有一个合法的堆叠序列，并且得到的序列总高度是最高的。

于是我们将所有n个长方体经过变形后（将最短边作为length、中等边作为width、最长边作为height）按照长度和宽度进行降序排列。接下来按照解法1的思想，用N^2的LIS DP方法找到最高的总堆叠高度。因为每个长方体我们只放了一个变种，所以不需要记录idx来避免同一个长方体的duplicate。




$0
endsnippet

# ==> ./Dynamic_Programming/1691.Maximum-Height-by-Stacking-Cuboids/1691.Maximum-Height-by-Stacking-Cuboids_v1.cpp <==
snippet 1691.Maximum-Height-by-Stacking-Cuboids "1691.Maximum-Height-by-Stacking-Cuboids" b
class Solution {
public:
    int maxHeight(vector<vector<int>>& cuboids) 
    {
        int n = cuboids.size();
        vector<array<int,4>>p;
        for (int i=0; i<cuboids.size(); i++)
        {
            auto c = cuboids[i];
            p.push_back({c[0], c[1], c[2], i});
            p.push_back({c[0], c[2], c[1], i});
            p.push_back({c[1], c[0], c[2], i});
            p.push_back({c[1], c[2], c[0], i});
            p.push_back({c[2], c[0], c[1], i});
            p.push_back({c[2], c[1], c[0], i});
        }
        sort(p.begin(), p.end());
        vector<int>dp(6*n);
        for (int i=0; i<6*n; i++)
        {
            dp[i] = p[i][2];
            for (int j=0; j<i; j++)
                if (p[j][0]<=p[i][0] && p[j][1]<=p[i][1] && p[j][2]<=p[i][2] && p[j][3]!=p[i][3])
                    dp[i] = max(dp[i], dp[j]+p[i][2]);
        }

        int ret = 0;
        for (int i=0; i<6*n; i++)
            ret = max(ret, dp[i]);        
        return ret;
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/1691.Maximum-Height-by-Stacking-Cuboids/1691.Maximum-Height-by-Stacking-Cuboids_v2.cpp <==
snippet 1691.Maximum-Height-by-Stacking-Cuboids "1691.Maximum-Height-by-Stacking-Cuboids" b
class Solution {
public:
    int maxHeight(vector<vector<int>>& cuboids) 
    {
        int n = cuboids.size();
        for (auto& c:cuboids)
        {
            sort(c.begin(), c.end());
        }
        sort(cuboids.begin(), cuboids.end());

        vector<int>dp(n);
        for (int i=0; i<n; i++)
        {
            dp[i] = cuboids[i][2];
            for (int j=0; j<i; j++)
                if (cuboids[j][0]<=cuboids[i][0] && cuboids[j][1]<=cuboids[i][1] && cuboids[j][2]<=cuboids[i][2])
                    dp[i] = max(dp[i], dp[j]+cuboids[i][2]);
        }

        int ret = 0;
        for (int i=0; i<n; i++)
            ret = max(ret, dp[i]);        
        return ret;
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/1692.Count-Ways-to-Distribute-Candies/Readme.md <==
snippet 1692.Count-Ways-to-Distribute-Candies "1692.Count-Ways-to-Distribute-Candies" b
### 1692.Count-Ways-to-Distribute-Candies

我们设计dp[i][j]表示前i个糖果分放在j个袋子里，有多少种不同的方法。

突破口在第i个糖果的处理方法。有两种不同的策略：

1. 第i个糖果可以单独放在一个新袋子里，于是方案数就取决于如何把前i-1个糖果就需要放在j-1个袋子里，也就是dp[i-1][j-1]。
2. 前i-1个糖果已经放在了j个袋子里，这有dp[i-1][j]种方法。第i个糖果需要在前j个袋子选择一个，又有j种选择。故总共有dp[i-1][j]*j种方法。

dp[i][j]就是以上两种策略的相加。

$0
endsnippet

# ==> ./Dynamic_Programming/1692.Count-Ways-to-Distribute-Candies/1692.Count-Ways-to-Distribute-Candies.cpp <==
snippet 1692.Count-Ways-to-Distribute-Candies "1692.Count-Ways-to-Distribute-Candies" b
class Solution {
    long dp[1005][1005];
    long M = 1e9+7;
public:
    int waysToDistribute(int n, int k) 
    {
        for (int i=1; i<=n; i++)
            dp[i][1] = 1;
        
        for (int i=1; i<=n; i++)
            for (int j=2; j<=k; j++)
            {
                dp[i][j] = (dp[i-1][j-1] + j * dp[i-1][j] % M) % M;
            }
        return dp[n][k];
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/1723.Find-Minimum-Time-to-Finish-All-Jobs/Readme.md <==
snippet 1723.Find-Minimum-Time-to-Finish-All-Jobs "1723.Find-Minimum-Time-to-Finish-All-Jobs" b
### 1723.Find-Minimum-Time-to-Finish-All-Jobs

#### 解法1：状态压缩DP
考虑到只有不超过12件jobs，可以用大小不超过4096的01二进制bit来表示任何jobs的组合状态。我们令dp[i][state]表示使用i个工人、分配state所代表的jobs时，可以得到的the minimum possible maximum working time。突破口是第i个工人做了哪些工作？我们可以枚举state的子集subset作为第i个工人的分配任务，那么状态转移方程
```cpp
dp[i][state] = min{max(dp[i-1][state-subset], time[subset])} for all subsets.
```

#### 解法2：二分搜值+状态压缩DFS
解法1虽然写法简单，但是效率并不高。事实上很多dp[i][state]的状态其实早早对应了某个工人被分配了过长的时间，但是我们没有剪枝，而是暴力把这个二维循环统统计算了出来。

高效的办法就是用二分搜值来假设单个工人的时间上限threshold。然后判断在th的前提下，能否DFS搜索出一个可行解。这里依然可以用状态压缩的DFS。初始状态是(1<<n)-1，每一个回合就减去一个subset（注意这个subset的总时间必须小于等于th）。经过k个回合（分配了k个工人）看看是否能将状态减至0，代表所有的任务都已经安排完毕。

#### 解法3：二分搜值+常规DFS
常规的DFS也可以写，而且剪枝比状态压缩更灵活。我们令workers数组表示k个工人每人分配的时长。在递归函数dfs(i)里，我们试图分配第i个工作。只要当前workers[j]不超过th，那么我们就可以把第i个工作分配给第j个工人，然后继续递归下去。直至所有的任务都分配完。

我们用两个剪枝来优化时间。第一，我们优先分配时间较长的工作，这样能更早的触发限制，及早终止不必要的探索。第二，在某一层递归中，我们我们已经尝试过把第i个工作分配给某个空闲的工人，那么我们就不用再尝试把第i个工作分配给其他空闲的工人，因为效果是等价的。

$0
endsnippet

# ==> ./Dynamic_Programming/1723.Find-Minimum-Time-to-Finish-All-Jobs/1723.Find-Minimum-Time-to-Finish-All-Jobs_v1.cpp <==
snippet 1723.Find-Minimum-Time-to-Finish-All-Jobs "1723.Find-Minimum-Time-to-Finish-All-Jobs" b
class Solution {
    int stateTime[4097];
    int dp[13][4096];
public:
    int minimumTimeRequired(vector<int>& jobs, int k) 
    {
        int n = jobs.size();        
        for (int state = 1; state < (1<<n); state++)
        {
            int sum = 0;
            for (int i=0; i<n; i++)
                if ((state>>i)&1)
                    sum += jobs[i];
            stateTime[state] = sum;
        }

        for (int state = 1; state < (1<<n); state++)
            dp[0][state] = INT_MAX;
        dp[0][0] = 0;

        for (int i = 1; i<=k; i++)            
            for (int state=0; state<(1<<n); state++)
            {
                dp[i][state] = INT_MAX;
                for (int subset=state; subset>0; subset=(subset-1)&state)
                {
                    dp[i][state] = min(dp[i][state], max(dp[i-1][state-subset],stateTime[subset]));
                }
            }                    
        return dp[k][(1<<n)-1];
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/1723.Find-Minimum-Time-to-Finish-All-Jobs/1723.Find-Minimum-Time-to-Finish-All-Jobs_v2.cpp <==
snippet 1723.Find-Minimum-Time-to-Finish-All-Jobs "1723.Find-Minimum-Time-to-Finish-All-Jobs" b
class Solution {
    int stateTime[4100];
    int visited[4100][13];
    int k;
public:
    int minimumTimeRequired(vector<int>& jobs, int k) 
    {
        int n = jobs.size();        
        this->k = k;
        for (int state=0; state<(1<<n); state++)
        {
            int sum = 0;
            for (int i=0; i<n; i++)
            {
                if ((state>>i)&1)
                    sum += jobs[i];
            }
            stateTime[state] = sum;            
        }

        int high = accumulate(jobs.begin(), jobs.end(), 0);
        int low = 1;
        
        while (low < high)
        {
            for (int i=0; i<4100; i++)
                for (int j=0; j<=12; j++)
                    visited[i][j] = 0;

            int mid = low + (high-low)/2;
            if (dfs((1<<n)-1, mid, 0))
                high = mid;
            else
                low = mid+1;            
        }
        return high;        
    }
    
    bool dfs(int state, int th, int m)
    {       
        if (state == 0)
            return true;
        if (m==k)
            return false;
        
        if (visited[state][m]==1)
            return false;
        
        for (int subset=state; subset>0; subset=(subset-1)&state)
        {
            if (stateTime[subset] > th) continue;            
            if (dfs(state-subset, th, m+1))
                return true;
        }
        visited[state][m] = 1;
        return false;
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/1723.Find-Minimum-Time-to-Finish-All-Jobs/1723.Find-Minimum-Time-to-Finish-All-Jobs_v3.cpp <==
snippet 1723.Find-Minimum-Time-to-Finish-All-Jobs "1723.Find-Minimum-Time-to-Finish-All-Jobs" b
class Solution {
    int workers[12];
    int k;
public:
    int minimumTimeRequired(vector<int>& jobs, int k) 
    {
        int n = jobs.size();        
        sort(jobs.begin(), jobs.end());
        reverse(jobs.begin(), jobs.end());
        this->k = k;
        
        int high = accumulate(jobs.begin(), jobs.end(), 0);
        int low = 1;
        
        while (low < high)
        {
            for (int i=0; i<k; i++)
                workers[i] = 0;

            int mid = low + (high-low)/2;
            if (dfs(jobs, 0, mid))
                high = mid;
            else
                low = mid+1;            
        }
        return high;        
    }
    
    bool dfs(vector<int>&jobs, int curJob, int th)
    {       
        if (curJob == jobs.size())
            return true;            
        int flag = 0;
        for (int j=0; j<k; j++)
        {
            if (workers[j]+jobs[curJob] > th) continue;
            if (workers[j]==0)
            {
                if (flag==1) continue;
                else flag = 1;
            }            
            workers[j]+=jobs[curJob];
            if (dfs(jobs, curJob+1, th))
                return true;
            workers[j]-=jobs[curJob];
        }        
        return false;
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/1745.Palindrome-Partitioning-IV/Readme.md <==
snippet 1745.Palindrome-Partitioning-IV "1745.Palindrome-Partitioning-IV" b
### 1745.Palindrome-Partitioning-IV

关于判定一个字符串中的substring是否为回文串，区间型的DP是最常规的手段。在这里，我们可以提前用o(N^2)的时间预处理s，得到dp[i][j]表示任意一个子区间是否为回文串。

然后我们再循环遍历两个分界点i和j，将s分割为三部分，这样只需要直接调用dp[0][i],dp[i+1][j-1],dp[j+1][n-1]就可以知道这三部分是否分别都是回文串。这两层循环的时间复杂度也是o(N^2).

另外，本题有线性时间复杂度的Manacher算法。

$0
endsnippet

# ==> ./Dynamic_Programming/1745.Palindrome-Partitioning-IV/1745.Palindrome-Partitioning-IV.cpp <==
snippet 1745.Palindrome-Partitioning-IV "1745.Palindrome-Partitioning-IV" b
class Solution {
    int dp[2000][2000];
public:
    bool checkPartitioning(string s) 
    {
        int n = s.size();
        for (int i=0; i<n; i++)
            dp[i][i] = 1;
        for (int i=0; i+1<n; i++)
            if (s[i]==s[i+1])
                dp[i][i+1] = 1;
        
        
        for (int len = 3; len <= n; len ++) 
            for (int i=0; i+len-1<n; i++)
            {
                int j = i+len-1;
                if (s[i]==s[j])
                    dp[i][j] = dp[i+1][j-1];
                else
                    dp[i][j] = 0;
            }
        
        for (int i=0; i<n; i++)
            for (int j=i+2; j<n; j++)
            {
                if (dp[0][i] && dp[i+1][j-1] && dp[j][n-1])
                    return true;
            }
        return false;
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/1746.Maximum-Subarray-Sum-After-One-Operation/Readme.md <==
snippet 1746.Maximum-Subarray-Sum-After-One-Operation "1746.Maximum-Subarray-Sum-After-One-Operation" b
### 1746.Maximum-Subarray-Sum-After-One-Operation

这就是在常规的max subarray sum的基础上，再套一个“是否使用自乘权力”的选择。令a表示截止到目前为止“没有使用该权力”得到的最大子区间sum，b表示截止到目前为止“已经使用过该权力”得到的最大子区间sum，

状态转移如下：
```
a = max(a+x, x)
b = max(a+x*x, x*x, b+x, x)
ret = max(ret, a, b)
```
注意，需要在每回合的时候都更新ret，因为最大区间和可能截止在任何位置。

$0
endsnippet

# ==> ./Dynamic_Programming/1746.Maximum-Subarray-Sum-After-One-Operation/1746.Maximum-Subarray-Sum-After-One-Operation.cpp <==
snippet 1746.Maximum-Subarray-Sum-After-One-Operation "1746.Maximum-Subarray-Sum-After-One-Operation" b
class Solution {
public:
    int maxSumAfterOperation(vector<int>& nums) 
    {
        int a = 0, b = 0;
        int ret = 0;
        for (auto x: nums)
        {
            int a0 = a, b0 = b;
            a = max(a0+x, x);
            b = max(b0+x, x);            
            b = max(b, a0+x*x);
            b = max(b, x*x);
            
            ret = max(ret, a);
            ret = max(ret, b);
        }
        return ret;
        
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/1770.Maximum-Score-from-Performing-Multiplication-Operations/Readme.md <==
snippet 1770.Maximum-Score-from-Performing-Multiplication-Operations "1770.Maximum-Score-from-Performing-Multiplication-Operations" b
### 1770.Maximum-Score-from-Performing-Multiplication-Operations

这道题是比较新颖的区间型DP。我们常见的区间型DP的定义是dp[i][j]表示在区间[i:j]内可以得到的最优解。但是本题中这样定义的话需要开辟N^2的空间，会MLE。我们发现本题中需要拿取的数字个数只有m个，远比nums的长度要小，所以我们转换思路，将dp[i][j]表示我们在左侧拿了i个、右侧拿了j个可以得到的最优解。虽然有两个区间，但我们同样只需要用两个下标可以表示了。

dp[i][j]的最优解取决于最后一步拿的第i+j个数字是在左边还是右边。所以状态转移方程是：
```cpp
dp[i][j] = max(dp[i-1][j]+nums[i]*multipliers[i+j], dp[i][j-1]+nums[n-j+1]*multipliers[i+j]);  
```
dp的边界条件是dp[0][0] = 0. 

$0
endsnippet

# ==> ./Dynamic_Programming/1770.Maximum-Score-from-Performing-Multiplication-Operations/1770.Maximum-Score-from-Performing-Multiplication-Operations.cpp <==
snippet 1770.Maximum-Score-from-Performing-Multiplication-Operations "1770.Maximum-Score-from-Performing-Multiplication-Operations" b
class Solution {
public:
    int maximumScore(vector<int>& nums, vector<int>& multipliers) 
    {
        int n = nums.size(), m = multipliers.size();
        auto dp = vector<vector<int>>(m+1, vector<int>(m+1, INT_MIN/2));
        
        nums.insert(nums.begin(), 0);
        dp[0][0] = 0;
        
        int ret = INT_MIN/2;                
        for (int len = 1; len<=m; len++)
        {
            for (int i=0; i<=len; i++)
            {
                int j = len-i;
                if (i>=1) dp[i][j] = max(dp[i][j], dp[i-1][j]+nums[i]*multipliers[len-1]);
                if (j>=1) dp[i][j] = max(dp[i][j], dp[i][j-1]+nums[n-j+1]*multipliers[len-1]);
                
                if (len==m)
                    ret = max(ret, dp[i][j]);                    
            }
        }
        return ret;
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/1771.Maximize-Palindrome-Length-From-Subsequences/Readme.md <==
snippet 1771.Maximize-Palindrome-Length-From-Subsequences "1771.Maximize-Palindrome-Length-From-Subsequences" b
### 1771.Maximize-Palindrome-Length-From-Subsequences

#### 解法1：双序列DP（LCS）
本题的突破口是：A的子序列s与B的子序列t拼接起来是回文串，那么意味着t的逆序（记做t'）肯定能与s的某段前缀相同。
```
A: xxx a x b x c xxx
B: xxx c x b x a xxx
B':xxx a x b x c xxx
```
我们希望整体的回文串越长，那么自然希望B的逆序里（记做B'）能与A中的子序列匹配的字符越多越好。也就是说，我们需要求A和B'的最长公共子序列（LCS）。

那么答案就是这个LCS长度的两倍吗？并不是。LCS只是描述了A和B中能够组成的最长的相互对称序列。但是如果A的后半段，或者B的前半段（即B'的后半段），存在自相关的对称序列的话，也是可以贡献在答案里的，例如：
```
A: x x x a x b x c [x d e d]
B: [x x x] c x b x a x x x x
B':x x x a x b x c [x x x x]
```
所以当我们已知dp[i][j]表示A的前i个元素、B'的前j个元素能够组成的LCS时，还要查看A[i+1:m]存在的最长回文串长度、或者B[j+1:n]存在的最长回文串长度。两者取更大的那个，结合之前的互相对称的LCS，才是最后的答案。

#### 解法2：直接区间型DP（求palindrome length）
我们直接将word1和word2拼接起来记做word，根据区间型DP，很容易计算dp[i][j]表示区间word[i:j]内的最长回文子序列的长度。但是，符合要求的答案还需要有一个额外的限制：回文串必须跨越两个初始字符串。解决方法很简单：计算dp[i][j]的过程中，如果遇到word[i]==word[j]，并且检验发现i与j跨越两个初始字符串，那么这样的dp[i][j]就是符合题目要求的，用来更新最终的答案。

$0
endsnippet

# ==> ./Dynamic_Programming/1771.Maximize-Palindrome-Length-From-Subsequences/1771.Maximize-Palindrome-Length-From-Subsequences_v1.cpp <==
snippet 1771.Maximize-Palindrome-Length-From-Subsequences "1771.Maximize-Palindrome-Length-From-Subsequences" b
class Solution {    
public:
    vector<vector<int>> isPalindrome(string& word, int n)
    {        
        auto dp = vector<vector<int>>(n+1, vector<int>(n+1));
        for (int i=1; i<=n; i++)
            dp[i][i] = 1;
        for (int len=2; len<=n; len++)
            for (int i=1; i+len-1<=n; i++)
            {
                int j = i+len-1;
                if (word[i]==word[j])
                    dp[i][j] = dp[i+1][j-1]+2;
                else
                    dp[i][j] = max(dp[i+1][j], dp[i][j-1]);
            }
        return dp;
    }

    int longestPalindrome(string word1, string word2) 
    {
        int m = word1.size(), n = word2.size();        
        reverse(word2.begin(), word2.end());
        word1 = "#"+word1;
        word2 = "#"+word2;
                        
        auto dp1 = isPalindrome(word1, m);
        auto dp2 = isPalindrome(word2, n);       
        
        int ret = 0;
        auto dp = vector<vector<int>>(m+1, vector<int>(n+1,0));
        
        for (int i=1; i<=m; i++)
            for (int j=1; j<=n; j++)
            {
                if (word1[i]==word2[j])
                {
                    dp[i][j] = dp[i-1][j-1]+1;
                    ret = max(ret, dp[i][j]*2 + max(i+1<=m ? dp1[i+1][m]:0, j+1<=n ? dp2[j+1][n]:0));
                }                    
                else
                    dp[i][j] = max(dp[i-1][j], dp[i][j-1]);
            }                
        return ret;
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/1771.Maximize-Palindrome-Length-From-Subsequences/1771.Maximize-Palindrome-Length-From-Subsequences_v2.cpp <==
snippet 1771.Maximize-Palindrome-Length-From-Subsequences "1771.Maximize-Palindrome-Length-From-Subsequences" b
class Solution {    
public:
    int longestPalindrome(string word1, string word2) 
    {
        int m = word1.size(), n = word2.size();        
        int t = m + n;
        string word = word1+word2;
                
        int ret = 0;
        auto dp = vector<vector<int>>(t, vector<int>(t,0));

        for (int i=0; i<t; i++)
            dp[i][i] = 1;
        
        for (int len=2; len<=t; len++)
            for (int i=0; i+len-1<t; i++)
            {
                int j = i+len-1;
                if (word[i]==word[j])
                {
                    dp[i][j] = dp[i+1][j-1]+2;
                    if (i<m && j>=m)
                        ret = max(ret, dp[i][j]);
                }                    
                else
                    dp[i][j] = max(dp[i+1][j], dp[i][j-1]);
            }                
        return ret;
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/1787.Make-the-XOR-of-All-Segments-Equal-to-Zero/Readme.md <==
snippet 1787.Make-the-XOR-of-All-Segments-Equal-to-Zero "1787.Make-the-XOR-of-All-Segments-Equal-to-Zero" b
### 1787.Make-the-XOR-of-All-Segments-Equal-to-Zero

首先，我们从```A[0]^A[1]^A[2]...^A[k-1] = A[1]^A[2]...^A[k-1]^A[k]```可以得到```A[0]=A[k]```，以此类推，任何元素```A[i]=A[i-k]```，也就是说我们要使得整个数组以k为周期循环。我们令Set{i}表示```{A[i],A[i+k],A[i+2k]...}```这一组需要改为相同值的元素。总共有k组。

那么对于每一组而言，我们改成什么数值最好呢？贪心的想法是改成该组里出现频次最多的那个元素，这样改动次数就可以最少。但显然，这不一定能达到全局最小的改动次数。事实上，甚至不一定要改成该组里任何曾经出现过的元素，也就是说，全局最优解有可能对应着该组的元素全部都要改动。

想到这里的话，似乎我们只能遍历所有的取值可能；也就是说，对于任何一组元素的改动方案，我们都要把[0,1023]都尝试一遍（题目中给定了每个元素的范围）。另外，因为每个元素的取值都在[0,1023]，那么他们的XOR SUM也一定是在这个范围内，所以我们就可以设计DP算法。令dp[i][d]表示使得前i个元素的XOR-SUM等于d的最小改动（注意每次改动要把同组的元素都变一样）。那么突破口就是第i个元素的取值v，我们遍历它的可能：
```cpp
for (int i=0; i<k; i++)
  for (int d=0; d<1024; d++)
    for (int v=0; v<1024; v++)
    {
      dp[i][d] = min(dp[i][d], dp[i-1][d^v] + cost{将第i组元素都改成v});
    }
```
对于上面的表达式有几点说明：
1. d^v的本意是找一个元素x，使得前i-1个元素的XOR-SUM等于x，并且x^v之后的结果等于d。根据XOR的性质，我们可以知道这样的x其实就是d^v
2. cost{将第i组元素都改成v}可以提前计算并存储起来。它的本质就是第i组元素的总个数，减去第i组元素里数值为v的总个数。前者记为totalCnt[i]，后者记为count[i][v]，后者的空间大小是kx1024，可以接受.
3. 整体的时间复杂度是```o(k*1024*1024)```，注定会TLE。

那么如何改进呢？我们将v的选择分为两部分，第一部分是第i组里面的元素，第二部分是第i组里没有出现的元素。如果只考虑前者，那么之前的代码就是：
```cpp
for (int i=0; i<k; i++)
  for (int d=0; d<1024; d++)
    for (int j=i; j<n; j+=k)
    {
      int v = nums[j];
      dp[i][d] = min(dp[i][d], dp[i-1][d^v] + cost{将第i组元素都改成v});
    }
```
这是```o(k*n/k*1024)```的复杂度.

那么如果v是Set{i}里没有出现过的元素，我们也需要遍历v才能得到最小的dp[i][d]吗？事实上，我们可以预知哪个v能够得到最小的dp[i][d]。这是因为当v不在Set{i}里出现时，转移方程是
```
dp[i][d] = dp[i-1][d^v] + totalCnt[i]
```
其中的cost项是一个与v无关的常数。所以我们只需要找到最小的dp[i-1][d^v]，那么得到的dp[i][d]必然也是最小的。那么“最小的dp[i-1][d^v]”是什么呢？只要将dp[i-1][x]里的x从[0,1023]扫一遍就行了。找到了最小dp[i-1][x]对应的x，那么就可以计算v=d^x。

但是这里有一个很迷惑的操作：你这样计算出来的v，不一定真的不在Set{i}里面。也就是说cost不见得真的就是totalCnt[i]。你按照v不在set{i}的方法去计算得到的最优方案v，有可能确实在Set{i}里面。但是这没有关系：因为这种情况下的```cost=totalCnt[i]-count[i][v]```，比之前预期的```totalCnt[i]```更小，这一定是比v是非Set{i}元素更优的解。

综上所述，完整的算法描述为：
```cpp
for (int i=0; i<k; i++)
  for (int d=0; d<1024; d++)
  {
    Find x, s.t. dp[i-1][x]最小
    v = d^x;
    dp[i][d] = dp[i-1][x] + cost{将第i组元素都改成v});
    
    for (int j=i; j<n; j+=k)
    {
      int v = nums[j];
      dp[i][d] = min(dp[i][d], dp[i-1][d^v] + cost{将第i组元素都改成v});
    }
  }  
```
注意，```Find x, s.t. dp[i-1][x]最小```这一行虽然要遍历1024个值，但与d无关，所以可以拿到d循环的外面。于是总的时间复杂度是```o(k*( 1024 + 1024 * n/k)```.

$0
endsnippet

# ==> ./Dynamic_Programming/1787.Make-the-XOR-of-All-Segments-Equal-to-Zero/1787.Make-the-XOR-of-All-Segments-Equal-to-Zero.cpp <==
snippet 1787.Make-the-XOR-of-All-Segments-Equal-to-Zero "1787.Make-the-XOR-of-All-Segments-Equal-to-Zero" b
class Solution {
    int dp[2000][1024];
    int totalCnt[2000];
    int count[2000][1024];
public:
    int minChanges(vector<int>& nums, int k) 
    {
        int n = nums.size();
        
        for (int i=0; i<k; i++)                    
            for (int j=i; j<n; j+=k)
            {
                totalCnt[i]++;
                count[i][nums[j]]++;
            }        

        for (int d=0; d<1024; d++)
            dp[0][d] = totalCnt[0] - count[0][d];

        for (int i=1; i<k; i++)
        {
            int minCost = INT_MAX;
            int minCostD;
            for (int d=0; d<1024; d++)
            {
                if (dp[i-1][d] < minCost)
                {
                    minCost =  dp[i-1][d];
                    minCostD = d;                    
                }
            }                

            for (int d=0; d<1024; d++)
            {
                dp[i][d] = minCost + totalCnt[i] - count[i][d^minCostD];

                for (int j=i; j<n; j+=k)
                    dp[i][d] = min(dp[i][d], dp[i-1][d^nums[j]] + totalCnt[i] - count[i][nums[j]]);
            }
        }

        return dp[k-1][0];
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/1799.Maximize-Score-After-N-Operations/Readme.md <==
snippet 1799.Maximize-Score-After-N-Operations "1799.Maximize-Score-After-N-Operations" b
### 1799.Maximize-Score-After-N-Operations

观察数据大小，容易判定就是一个状态压缩的动态规划问题。转移方程是：
```
for i=1:n
 dp[集合大小是2i的state] = dp[集合大小是2(i-1)的substate] + gcd(x,y)
```
其中substate必须是state的子集，另外x和y就是差集state-substate里的那两个元素。

于是本题的关键就是如何高效遍历状态。这里就显现了Gosper's Hack的威力，它可以直接遍历所有大小为m bit、其中含有k个1 bit的二进制状态。假设2n=14，故外层的循环就是2^14/2=8192次。对于内层循环，有两种遍历策略：
1. 遍历所有state的子集，再过滤是否substate的集合大小是2(i-1)
2. 遍历所有集合大小是2(i-1)的substate，再过滤是否是state的子集。
 
对于策略2，考虑最复杂的情况，遍历有6个1的substate，总共有C(14,6) = 3003种状态，两层循环组合起来的时间复杂度应该也就是1e6数量级，可以接受。

$0
endsnippet

# ==> ./Dynamic_Programming/1799.Maximize-Score-After-N-Operations/1799.Maximize-Score-After-N-Operations_v1.cpp <==
snippet 1799.Maximize-Score-After-N-Operations "1799.Maximize-Score-After-N-Operations" b
class Solution {
    int dp[16384];
    int g[14][14];
public:
    int maxScore(vector<int>& nums) 
    {
        int n = nums.size()/2;
        for (int i=0; i<2*n; i++)
            for (int j=0; j<2*n; j++)
                g[i][j] = gcd(nums[i], nums[j]);
        
        for (int i=1; i<=n; i++)
        {
            int state = (1 << i*2) - 1;            
            while (state < (1 << n*2))
            {
                if (i==1)
                {
                    int x, y;
                    helper(state, x, y);                    
                    dp[state] = 1*g[x][y];                    
                }
                else
                {
                    for (int subset=state; subset>0; subset=(subset-1)&state)
                    {
                        if (__builtin_popcount(state-subset)!=2) continue;
                        int x, y;
                        helper(state-subset, x, y);
                        dp[state] = max(dp[state], dp[subset]+i*g[x][y]);
                    }                                
                }
                
                int c = state & - state;
                int r = state + c;
                state = (((r ^ state) >> 2) / c) | r;
            }
        }
        
        return dp[(1<<(2*n))-1];        
    }
    
    void helper(int state, int &x, int &y)
    {
        x = -1, y = -1;
        for (int i=0; i<14; i++)
        {
            if ((state>>i)&1)
            {
                if (x==-1)
                    x = i;
                else
                    y = i;
            }
        }
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/1799.Maximize-Score-After-N-Operations/1799.Maximize-Score-After-N-Operations_v2.cpp <==
snippet 1799.Maximize-Score-After-N-Operations "1799.Maximize-Score-After-N-Operations" b
class Solution {
    vector<int> stateSet[8];
    int dp[16384];
    int g[14][14];
public:
    int maxScore(vector<int>& nums) 
    {
        int n = nums.size()/2;
        for (int i=0; i<2*n; i++)
            for (int j=0; j<2*n; j++)
                g[i][j] = gcd(nums[i], nums[j]);


        for (int i=1; i<=n; i++)
        {
            int state = (1 << i*2) - 1;                        
            while (state < (1 << n*2))
            {
                stateSet[i].push_back(state);
                int c = state & - state;
                int r = state + c;
                state = (((r ^ state) >> 2) / c) | r;
            }
        }
        stateSet[0].push_back(0);
        
        
        for (int i=1; i<=n; i++)
        {
            for (int state: stateSet[i])
                for (int subState: stateSet[i-1])
                {
                    if ((state&subState)!=subState)
                        continue;
                    int x, y;
                    helper(state-subState, x, y);
                    dp[state] = max(dp[state], dp[subState]+i*g[x][y]);
                }            
        }
        
        return dp[(1<<(2*n))-1];        
    }
    
    void helper(int state, int &x, int &y)
    {
        x = -1, y = -1;
        for (int i=0; i<14; i++)
        {
            if ((state>>i)&1)
            {
                if (x==-1)
                    x = i;
                else
                    y = i;
            }
        }
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/1824.Minimum-Sideway-Jumps/Readme.md <==
snippet 1824.Minimum-Sideway-Jumps "1824.Minimum-Sideway-Jumps" b
### 1824.Minimum-Sideway-Jumps

令dp[i][j]表示从初始状态到第i位置的第j个赛道（j=1,2,3）最少需要多少次jump。显然如果j赛道上有障碍物，那么记dp[i][j]为无限大。

如果j赛道上没有障碍物，那么只有两种方法到达j赛道：第一种是从前一个位置的相同赛道dp[i-1][j]直接走过来。第二种就是从当前位置的其他赛道跳过来。我们第一步先更新dp[i][j]=dp[i-1][j]，第二步在所有dp[i][j]里面挑选最小的方案，然后+1就可以用于更新其他的dp[i][j].

$0
endsnippet

# ==> ./Dynamic_Programming/1824.Minimum-Sideway-Jumps/1824.Minimum-Sideway-Jumps.cpp <==
snippet 1824.Minimum-Sideway-Jumps "1824.Minimum-Sideway-Jumps" b
class Solution {
    int dp[500001][4];
public:
    int minSideJumps(vector<int>& obstacles) 
    {
        int n = obstacles.size()-1;
        dp[0][1] = 1;
        dp[0][2] = 0;
        dp[0][3] = 1;
        for (int i=1; i<=n; i++)
        {
            int obs = obstacles[i];            
            int minVal = INT_MAX;
            for (int j=1; j<=3; j++)
            {
                if (j==obs)
                    dp[i][j] = INT_MAX;
                else
                    dp[i][j] = dp[i-1][j];                
                minVal = min(minVal, dp[i][j]);
            }

            for (int j=1; j<=3; j++)
            {
                if (j!=obs && dp[i][j]!=minVal)
                    dp[i][j] = minVal+1;
            }
        }

        int ret = INT_MAX;
        for (int j=1; j<=3; j++)
            ret = min(ret, dp[n][j]);
        return ret;
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/1839.Longest-Substring-Of-All-Vowels-in-Order/Readme.md <==
snippet 1839.Longest-Substring-Of-All-Vowels-in-Order "1839.Longest-Substring-Of-All-Vowels-in-Order" b
### 1839.Longest-Substring-Of-All-Vowels-in-Order

#### 解法1：DP
第一类基础型DP。令dp[i][j]表示截止到第i个元素、并且结尾字母是j时的最长美丽串长度。显然，如果word[i]==j，那么前一位的字母必须与j相等或者比j小，即
```cpp
dp[i][j] = max(dp[i-1][j], dp[i-1][j-1])+1;
```
如果word[i]!=j，那么dp[i][j] = INT_MIN;

最终的答案是所有```dp[*][5]```中的最大值。

#### 解法2：贪心
实际上我们可以经验地去判断一个子串的增长是否符合美丽的条件：新增的字母必须比之前的字母相等或者更大，否则就得清零重来。那么时候可以知道收集了五个不同的字母呢？我们可以设计字母的计数器，当新增的字母必须比之前的字母更大的时候，计数器增一；当计数器变成5的时候，就知道我们收集齐了aeiou，此时的len就是一个答案。

$0
endsnippet

# ==> ./Dynamic_Programming/1839.Longest-Substring-Of-All-Vowels-in-Order/1839.Longest-Substring-Of-All-Vowels-in-Order.cpp <==
snippet 1839.Longest-Substring-Of-All-Vowels-in-Order "1839.Longest-Substring-Of-All-Vowels-in-Order" b
class Solution {    
public:
    int longestBeautifulSubstring(string word) 
    {
        unordered_map<char,int>Map{{'a',1},{'e',2},{'i',3},{'o',4},{'u',5}};
        vector<int>dp(6,INT_MIN);
        dp[0] = 0;
        vector<int>dp_tmp(6);
        int ret = 0;
        for (int i=0; i<word.size(); i++)
        {
            for (int j=0; j<=5; j++)
                dp_tmp[j] = dp[j];

            int k = Map[word[i]];
            for (int j=1; j<=5; j++)
            {
                if (j!=k)
                    dp[j] = INT_MIN;
                else
                    dp[j] = max(dp_tmp[j], dp_tmp[j-1])+1;
            }
            
            ret = max(ret, dp[5]);
        }
        return ret;
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/1872.Stone-Game-VIII/Readme.md <==
snippet 1872.Stone-Game-VIII "1872.Stone-Game-VIII" b
### 1872.Stone-Game-VIII

题目问的是最终先手相对于后手最多的净胜分，因此相应地，我们设计dp[i]表示当剩下i堆时，先手能比后手最多的净胜分。最终输出的答案是dp[n]. 另外设计前缀和数组presum[i]表示前i堆的石头总重量。

我们来看dp[1]，表示当前仅有一堆，根据规则先手无法再取，自然也没有后手，随意净胜为0，即```dp[1] = 0```.

我们再看dp[2]，表示当前有堆石头，根据规则先手只有一个决策：必须取走这两堆，且该轮得分就是这两堆的重量。事实上这两堆的重量就是全部石头的重量，即presum[n]。先手走完之后，后手面对的是仅有一堆石头的情况，它在该状态下能得的净胜分其实就是dp[1]. 所以对于dp[2]而言，先手的最大净胜分就是```presum[n]-dp[1]```.

我们再看dp[3]，表示当前有三堆。根据规则先手有两种决策：1. 取走全部的三堆，该轮得分是presum[n]，留给对手的状态是dp[1]，故先手的净胜分是```presum[n]-dp[1]```. 2. 取走左边的两堆，注意到这样的话该轮得分的本质是presum[n-1]，就给对手的状态是dp[2]，故先手的净胜分是```presum[n-1]-dp[2]```. 那么综上，对于dp[2]而言，肯定会选择```presum[n]-dp[1]```和```presum[n-1]-dp[2]```之间更大的数值做决策。

相应地，我们查看dp[4]，可以推出，当先手选择取走四堆、三堆、两堆，分别对应的净胜分就是```presum[n]-dp[1]```，```presum[n-1]-dp[2]```，```presum[n-2]-dp[3]```。我们会在这三项中选择最大的一个。而前面两项在考察dp[2]时已经计算过了，这次只不过多了一个新选项而已。

可见，我们考察dp[i]的时候，其实就是在dp[i-1]和新选项```presum[n-i+2]-dp[i-1]```中取一个更大的。

这样我们就从dp[1]一直推到dp[n]，即是答案。

$0
endsnippet

# ==> ./Dynamic_Programming/1872.Stone-Game-VIII/1872.Stone-Game-VIII.cpp <==
snippet 1872.Stone-Game-VIII "1872.Stone-Game-VIII" b
class Solution {
public:
    int stoneGameVIII(vector<int>& stones) 
    {
        int n = stones.size();
        stones.insert(stones.begin(), 0);
        vector<int>presum(n+1);
        for (int i=1; i<=n; i++)
            presum[i] = presum[i-1]+stones[i];        
        
        vector<int>dp(n+1);
        dp[1] = 0;
        dp[2] = presum[n] - dp[1];
        
        for (int i=3; i<=n; i++)
        {
            dp[i] = max(dp[i-1], presum[n-i+2]-dp[i-1]);            
        }
        
        return dp[n];            
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/1883.Minimum-Skips-to-Arrive-at-Meeting-On-Time/Readme.md <==
snippet 1883.Minimum-Skips-to-Arrive-at-Meeting-On-Time "1883.Minimum-Skips-to-Arrive-at-Meeting-On-Time" b
### 1883.Minimum-Skips-to-Arrive-at-Meeting-On-Time

虽然本题和```1870.Minimum-Speed-to-Arrive-on-Time```很像，但是本题的本质是DP。

我们令dp[i][k]表示走完第i条路、且skip了k次休息的条件下，所需要的最短时间（这是一个浮点数）。注意，这里走完了第i条路，要包括了走完该路程后的休息时间（如果选择在该路结束后休息的话）。当然，走完最后一条路的话是不需要休息的。

对于第i条路，如果我们不skip rest，那么在开始走第i条路之前所用的时间就是dp[i-1][k]（包括第i-1条路结束后可能的休息），然后紧接着第i条路需要```dist[i]*1.0/speed```，然后休息的结果是二者的时间之和向上取整，即```ceil (dp[i-1][k] + dist[i]*1.0/speed) ```.

对于第i条路，如果我们skip rest，那么在开始走第i条路之前所用的时间就是dp[i-1][k-1]（包括第i-1条路结束后可能的休息），然后紧接着第i条路需要```dist[i]*1.0/speed```，不休息意味着不需要向上取整。总时间就是二者之和```dp[i-1][k] + dist[i]*1.0/speed ```.

综上，dp[i][k]就是选二者较小的那个。

特别注意，走完最后一条路（第n条）之后不需要休息，不占用skip rest的计数，所以```dp[n][k] = dp[n-1][k] + dist[n]*1.0/speed ```

最终的答案是最小的j，使得```dp[n][j]<=beforeHours```

特别注意，因为精度问题，取ceil之前的浮点数要减去一个极小数eps。

$0
endsnippet

# ==> ./Dynamic_Programming/1883.Minimum-Skips-to-Arrive-at-Meeting-On-Time/1883.Minimum-Skips-to-Arrive-at-Meeting-On-Time.cpp <==
snippet 1883.Minimum-Skips-to-Arrive-at-Meeting-On-Time "1883.Minimum-Skips-to-Arrive-at-Meeting-On-Time" b
class Solution {   
    double eps = 1e-8; 
public:
    int minSkips(vector<int>& dist, int speed, int hoursBefore) 
    {
        int n = dist.size();
        dist.insert(dist.begin(), 0);
        vector<vector<double>>dp(n+1, vector<double>(n+1, 1e20));
        dp[0][0] = 0;
        for (int i=1; i<=n-1; i++)
            for (int k=0; k<=i; k++)
            {
                dp[i][k] = ceil(dp[i-1][k] + dist[i]*1.0/speed - eps);
                if (k>=1) 
                    dp[i][k] = min(dp[i][k], dp[i-1][k-1] + dist[i]*1.0/speed);
            }        

        for (int j=0; j<=n; j++)
        {
            dp[n][j] = dp[n-1][j] + dist[n]*1.0/speed;
            if (dp[n][j] <= hoursBefore)
                return j;
        }
        return -1;
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/1884.Egg-Drop-With-2-Eggs-and-N-Floors/Readme.md <==
snippet 1884.Egg-Drop-With-2-Eggs-and-N-Floors "1884.Egg-Drop-With-2-Eggs-and-N-Floors" b
### 1884.Egg-Drop-With-2-Eggs-and-N-Floors

此题是```887.Super-Egg-Drop```的简化版本。

对于i层楼，如果只有一个鸡蛋，我们需要测几次呢？显然只能一层一层，从第1层开始尝试，最多可能一直到到第i层都不碎（注意题目允许在最高层都不碎）。所以需要n次测试，我们记做```dp[i][1]=1```.

现在我们有两个鸡蛋。我们遍历第一个鸡蛋放在哪里。假设放在第j层，如果碎了，那么说明我们需要用剩下的一颗鸡蛋来确定极限层（恰好不破）在下方的j-1层的哪里，即dp[j-1][1]. 如果没有碎，说明极限层在第j层到第n层之间。此时我们可以把第j层看做相当于第0层（因为肯定不会破），所以我们需要的是在剩下的i-j层里面用两颗鸡蛋来确定极限层，即dp[i-j][2]. 考虑最坏情况，取```max{dp[j-1][1], dp[i-j][2]}```

注意，我们在遍历第一个鸡蛋的位置j时，最终选择的是最优解，即```dp[i][2] = min{max{dp[j-1][1], dp[i-j][2]}} for j=1,2,..,i```.

$0
endsnippet

# ==> ./Dynamic_Programming/1884.Egg-Drop-With-2-Eggs-and-N-Floors/1884.Egg-Drop-With-2-Eggs-and-N-Floors.cpp <==
snippet 1884.Egg-Drop-With-2-Eggs-and-N-Floors "1884.Egg-Drop-With-2-Eggs-and-N-Floors" b
class Solution {
    int dp[1005][3];
public:
    int twoEggDrop(int n) 
    {        
        for (int i=1; i<=n; i++)
            dp[i][1] = i;
        dp[1][2] = 1;
        
        for (int i=2; i<=n; i++)
        {
            dp[i][2] = i;
            for (int j=1; j<=i; j++)
            {                
                dp[i][2] = min(dp[i][2], max(dp[j-1][1], dp[i-j][2]) + 1);
            }
        }
        
        return dp[n][2];                            
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/1900.The-Earliest-and-Latest-Rounds-Where-Players-Compete/Readme.md <==
snippet 1900.The-Earliest-and-Latest-Rounds-Where-Players-Compete "1900.The-Earliest-and-Latest-Rounds-Where-Players-Compete" b
### 1900.The-Earliest-and-Latest-Rounds-Where-Players-Compete

#### 解法1：DP
本题的数据规模很小，可以考虑直接DP暴力。我们令dp1[n][a][b]，表示当有n个选手、其中a和b是最强的两位选手时，最少需要多少轮对决能让a与b对决。相应的，令dp2[n][a][b]表示最多需要多少轮次。

为了充分利用对称性，减少需要填充的dp值，我们约定：
1. 让```a<b```。即如果 a>b时，```return dp[b][a]```
2. 让ab整体偏向数组的左边。即如果 ```(a + b)/2.0 > (n + 1)/2.0```（你可以认为ab的中轴线超过了整体的中轴线），```return dp[n+1-b][n+1-a]```. 注意n+1-b是b的对称点，n+1-a是a的对称点。

我们分两种情况讨论。

第一种，a和b分别在中轴线两边，根据之前的约定，a会比b更靠近端点：
```
(L) XXXX a XX b' XXXX M XXXX b XX a' XXXX (R)
```
我们在上面的示意图中标记了a的对称点a'，b的对称点b'，中轴线M（可以是一个元素，也可以是一个虚拟的中轴）。

我们知道a左边的选手可输可赢，假设胜利的人数是x，那么这些人会留在这个区域。另外ab'之间的选手也是可输可赢，假设胜利的人数是y，那么这些人也会留在这个区域。b'因为会与b对决而被淘汰。b'到b之间的区域的选手，会两两对决，留下一半的人，即```z = (b-b'-1+1)/2```. 

我们发现，如果我们约定了x和y之后，剩下的一半人(n+1)/2里面，a排在第x+1位，b排在x+1+y+z+1位，故我们可以递归求解 ```dp((n+1)/2, x+1, x+1+y+z+1)```。遍历所有的x和y之后，我们可以知道dp[n][a][b]的最大值和最小值。

第二种，a和b都在中轴线左边，根据之前的约定，a会比b更靠近端点：
```
(L) XXXX a XX b XXXX M XXXX b' XX a' XXXX (R)
```
这种情况相对更简单。令a左边的区域保留x人，ab中间的区域保留y人，那么就转化为```dp((n+1)/2, x+1, x+1+y+1)```当遍历所有的x和y后，就能知道dp[n][a][b]的最大值和最小值。

最终的答案是dp[n][firstPlayer][secondPlayer].

时间复杂度分析是这样的：状态有三个维度，我们遍历所有的状态，所以是o(N^3)。在计算每一个状态的时候，又是遍历了两层for循环。所以总共是o(N^5)的复杂度。但是更细节地分析的话，对于dp[n][a][b]，第一个维度只有log(N)级别的可能。所以整体的复杂度其实是o(N^4logN).

#### 解法2：贪心
本题是两个月前残酷群的[智慧杯第四场赛题](https://wisdompeak.github.io/lc-score-board/cup.html). 原题对数据规模的要求更加高，n要求1e18. 显然必须要有log(N)的解法。

##### 最早轮次
如果a和b在中轴线的两侧，那么通常情况下，经过设计，只要经过一轮，a和b就能够中轴对称。为什么呢？
```
(L) XXXX a XX b' XXXX M XXXX b XX a' XXXX (R)
   —————  ———
     x     y
```
在这一轮对局之后，我们只需要a左边的个数等于b右边，就能让二者对称。假设(La)之间有x个元素，只要将x的元素均匀二分到(La)和(a'R)这两个区域即可。如果x是奇数没法平分，那也没关系，我们还有(ab')之间的y个元素，只要拿出一个放在(ba')区域，这样就又能使得(La)和(bR)两部分平衡。

但是我们注意到，当x是奇数，但y等于0的时候，上面的补救措施就无法实现，故需要再多加一轮才能实现a与b的对称。

如果a和b在中轴线的同侧，我们的目标只有一个，就是尽快地让整体的中轴线落在a与b之间（也就是变成上面的情况）。所以我们只需无脑地每个回合人数减半、让前半区选手通赢。
```
(L) XXXX a XX b XXXX M XXXX b' XX a' XXXX (R)
```
直至中轴线恰好落在a与b之间的这一轮，我们通过类似前述的细微调整，优化(La)区域和(ab)区域的人数，就可以直接让a与b对称。

但是同样有一个例外，那就是当n为奇数，且a与b相邻的时候，我们是无论如何都无法让a与b关于一个中轴线对称的，比如```abx```。这种情况下，我们只能继续让选手减半（方法任意，因为a与b总是相邻），直至总人数为偶数，才有可能让ab关于中轴线对称。

##### 最晚轮次
和前一个问题的思想相反，我们希望整体中轴线尽量地远离ab。因为中轴线一旦落入ab中间，那么就很容易让ab对称。所以宗旨就是，让ab尽可能地往左偏。

根据这个精神，当a和b在中轴线两侧时，我们会让(La)和(ab')这两个区间的选手都输，这样a与b就被最大程度地往左偏移，远离了整体的中轴线。
```
(L) XXXX a XX b' XXXX M XXXX b XX a' XXXX (R)
   —————  ———
     x     y
```

当a和b在中轴线同侧时，同样，我们让(La)和(ab)这两个区间的选手都输，这样a与b也是最大程度地往左偏移，远离了整体的中轴线。
```
(L) XXXX a XX b XXXX M XXXX b' XX a' XXXX (R)
```

以上只是贪心策略的大体思想，代码中还有很多细节就不再赘述了。

$0
endsnippet

# ==> ./Dynamic_Programming/1900.The-Earliest-and-Latest-Rounds-Where-Players-Compete/1900.The-Earliest-and-Latest-Rounds-Where-Players-Compete_dp.cpp <==
snippet 1900.The-Earliest-and-Latest-Rounds-Where-Players-Compete "1900.The-Earliest-and-Latest-Rounds-Where-Players-Compete" b
class Solution {
private:
    int dp1[30][30][30];
    int dp2[30][30][30];

public:
    pair<int, int> dp(int n, int a, int b) 
    {
        if (dp1[n][a][b]!=0) {
            return {dp1[n][a][b], dp2[n][a][b]};
        }

        if (a + b == n + 1) {
            return {1, 1};
        }

        if (a > b)
            return dp(n, b, a);

        if (a + b > n + 1) {
            return dp(n, n + 1 - b, n + 1 - a);
        }

        int range1 = a-1;
        int range2;
        int half_point = (n+1)/2;
        int bb = n+1-b;

        int maxVal = INT_MIN/2, minVal = INT_MAX/2;

        if (b > half_point)
        {
            range2 = bb-a-1;
            int mid = b-bb-1;
            for (int x=0; x<=a-1; x++)
                for (int y=0; y<=range2; y++)
                {
                    auto temp = dp((n+1)/2, x+1, x+1+y+(mid+1)/2+1);
                    minVal = min(minVal, temp.first + 1);
                    maxVal = max(maxVal, temp.second + 1);                
                }            
        }
        else {
            range2 = b-a-1;
            for (int x=0; x<=a-1; x++)
                for (int y=0; y<=range2; y++)
                {
                    auto temp = dp((n+1)/2, x+1, x+1+y+1);
                    minVal = min(minVal, temp.first + 1);
                    maxVal = max(maxVal, temp.second + 1);                
                }            
        }
        dp1[n][a][b] = minVal;
        dp2[n][a][b] = maxVal;
        return {minVal, maxVal};
    }

    vector<int> earliestAndLatest(int n, int firstPlayer, int secondPlayer) {
        auto [earlist, latest] = dp(n, firstPlayer, secondPlayer);
        return {earlist, latest};
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/1909.Remove-One-Element-to-Make-the-Array-Strictly-Increasing/Readme.md <==
snippet 1909.Remove-One-Element-to-Make-the-Array-Strictly-Increasing "1909.Remove-One-Element-to-Make-the-Array-Strictly-Increasing" b
### 1909.Remove-One-Element-to-Make-the-Array-Strictly-Increasing

本题的难点是如何不用暴力的线性时间的算法。

#### 解法1 (有瑕疵)：

根据To do or not to do的套路，对于这种“行使权力”的题目，我们很容易想到设计两个状态分别对应“没有删除元素”和“删除了一个元素”。在这里我们令dp0[i]表示：我们从未删除过元素、截止到i的最长连续递增序列的长度。同理令dp1[i]表示：我们已经删除过一个元素、截止到i的最长连续递增序列的长度。特别注意我们的定义，所谓“截止到i”，意思是这个最长递增序列必须以i结尾（即包含nums[i]）。也就是说，如果我们打算删除第i个元素，那么dp1[i]就应该是0.

先考虑dp0[i]，它有两个来源。首先，如果nums[i]>nums[i-1]，显然这个递增序列可以在前一个未使用删除权力的递增序列的基础上延长，即```dp0[i] = dp0[i-1]+1```. 其次，如果nums[i]<=nums[i-1]，那么以“截止到i的最长递增序列”只能是它自身，也就是```dp0[i] = 1```.

在考虑dp1[i]，它也有两个来源。首先，就是我们已经使用过了删除权力，那么我们可以在前一个已经使用删除权力的递增序列的基础上延长，即```dp1[i] = dp1[i-1]+1```，当然前提是nums[i]>nums[i-1]. 另外一个来源就是在这个回合使用删除权力。记住，我们不能删除nums[i]本身，因为dp1[i]的定义要求包含nums[i]，我们只能删除nums[i-1]（否则就会等同于前述的情况），这样dp1[i]是接在上一个未使用删除权力的递增序列的基础上延长，即```dp1[i] = dp0[i-2]+1```. 最后dp1[i]在这两个source中选较大的那个。

最终的答案是查看所有i的位置，如果有```dp0[i]>=n```或者```dp1[i]>=n-1```就说明实现目标。

#### 解法2：
令maxNon表示截止到目前为止、未使用过删除权力、最长第增序列的最大值；令maxUsed表示截止到目前为止、已经使用过删除权力后、最长第增序列的最大值。这里不要求当前元素一定是这个递增序列的一部分。

如果当前元素大于maxNon，那么maxNon就可以更新。反之，那么就无法延续当前的递增序列，我们令maxNon为无穷大。

如果当前元素大于maxUsed，那么maxUsed就可以在原先的maxUsed基础上更新。另外，我们也可以删除当前的元素，那么maxUsed就继承maxNon。这两个方案我们取较小的那个，目的是为了便于后续第增序列的延长。

最终maxNon或者maxUsed任意一个为非无穷大的话，说明有解。

#### 解法3：
我们一旦发现某两个相邻的元素不满足严格递增，即```nums[i]>=nums[i-1]```，那么说明这两个元素之中一定存在“破坏递增”的那个bad number。我们再pass两遍，分别跳过这两个元素，看看剩下的序列是否为严格递增。如果都无法保证严格递增，那么说明只删除一个bad number是无法实现要求的。

#### 解法4：
利用nlogn解法，求原数组里的longest increasing subsequence，看看长度是否大于等于 nums.size()-1.

$0
endsnippet

# ==> ./Dynamic_Programming/1909.Remove-One-Element-to-Make-the-Array-Strictly-Increasing/1909.Remove-One-Element-to-Make-the-Array-Strictly-Increasing.cpp <==
snippet 1909.Remove-One-Element-to-Make-the-Array-Strictly-Increasing "1909.Remove-One-Element-to-Make-the-Array-Strictly-Increasing" b
class Solution {
public:
    bool canBeIncreasing(vector<int>& nums) 
    {
        int n = nums.size();
        
        nums.insert(nums.begin(), INT_MIN); // nums[1:n]
        vector<int>dp0(n+1);
        vector<int>dp1(n+1);
        
        dp0[0] = 0;
        dp1[0] = 0;
        
        for (int i=1; i<=n; i++)
        {
            if (nums[i]>nums[i-1])
                dp0[i] = dp0[i-1] + 1;
            else     
                dp0[i] = 1;
            
            dp1[i] = 0;
            if (nums[i]>nums[i-1])
                dp1[i] = max(dp1[i], dp1[i-1] + 1);            
            if (i>=2 && nums[i]>nums[i-2])
                dp1[i] =  max(dp1[i], dp0[i-2] + 1);  
            
            if (dp0[i]>=n-1 || dp1[i]>=n-1)
                return true;
        }
        
        return false;
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/1909.Remove-One-Element-to-Make-the-Array-Strictly-Increasing/1909.Remove-One-Element-to-Make-the-Array-Strictly-Increasing_v2.cpp <==
snippet 1909.Remove-One-Element-to-Make-the-Array-Strictly-Increasing "1909.Remove-One-Element-to-Make-the-Array-Strictly-Increasing" b
class Solution {
public:
    bool canBeIncreasing(vector<int>& nums) 
    {
        int max0 = INT_MIN, max1 = INT_MIN;

        for (auto x: nums)
        {
            int max0_tmp = max0, max1_tmp = max1;

            max0 = (x > max0_tmp) ? x : INT_MAX;

            max1 = max0_tmp;
            if (x > max1_tmp) 
                max1 = min(max1, x);

            if (max1==INT_MAX)
                return false;         
        }

        return true;
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/1909.Remove-One-Element-to-Make-the-Array-Strictly-Increasing/1909.Remove-One-Element-to-Make-the-Array-Strictly-Increasing_v3.cpp <==
snippet 1909.Remove-One-Element-to-Make-the-Array-Strictly-Increasing "1909.Remove-One-Element-to-Make-the-Array-Strictly-Increasing" b
class Solution {
public:
    bool canBeIncreasing(vector<int>& nums) 
    {
        for (int i=0; i+1<nums.size(); i++)
        {
            if (nums[i] >= nums[i+1])
            {
                return check(nums,i) || check(nums,i+1);
            }            
        }
        return true;
    }

    bool check(vector<int>&nums, int k)
    {
        int cur = INT_MIN;
        for (int i=0; i<nums.size(); i++)
        {
            if (i==k) continue;
            if (cur >= nums[i]) return false;
            cur = nums[i];
        }
        return true;
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/1909.Remove-One-Element-to-Make-the-Array-Strictly-Increasing/1909.Remove-One-Element-to-Make-the-Array-Strictly-Increasing_v4.cpp <==
snippet 1909.Remove-One-Element-to-Make-the-Array-Strictly-Increasing "1909.Remove-One-Element-to-Make-the-Array-Strictly-Increasing" b
class Solution {
public:
    bool canBeIncreasing(vector<int>& nums) 
    {
        vector<int>arr;
        for (auto x: nums)
        {
            auto iter = lower_bound(arr.begin(), arr.end(), x);
            if (iter!=arr.end())
                *iter = x;
            else
                arr.push_back(x);
        }
        return arr.size() >= nums.size()-1;
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/1931.Painting-a-Grid-With-Three-Different-Colors/Readme.md <==
snippet 1931.Painting-a-Grid-With-Three-Different-Colors "1931.Painting-a-Grid-With-Three-Different-Colors" b
### 1931.Painting-a-Grid-With-Three-Different-Colors

观察到行数m不超过5，我们就可以考虑以每一列整体作为状态进行动态规划。每一列的状态数是3^m不超过243，其中符合条件（相邻不同色）的状态会更少,m等于5时也只有48。我们可以用一个不大的三进制整数来表示每个格子的喷涂选择。比如三进制01210就表示一列里五个格子的颜色。

我们考虑第i列的某个状态s时，唯一的制约因素就是第i-1的状态。我们遍历第i-1列的状态的所有可能t，注意查看是否s和t是否符合并存的条件（即相邻不同色），然后累加```dp[s]+=dp[t]```. 

极限数据情况下的时间复杂度大概是```48*48*1000=2e6```，时间复杂度可以接受。

$0
endsnippet

# ==> ./Dynamic_Programming/1931.Painting-a-Grid-With-Three-Different-Colors/1931.Painting-a-Grid-With-Three-Different-Colors.cpp <==
snippet 1931.Painting-a-Grid-With-Three-Different-Colors "1931.Painting-a-Grid-With-Three-Different-Colors" b
typedef long long LL;
class Solution {
    LL M = 1e9+7;
public:
    int colorTheGrid(int m, int n) 
    {
        vector<int>cand;
        for (int state = 0; state < pow(3,m); state++)
        {
            vector<int>temp;
            int state0 = state;
            int flag = 1;
            for (int i=0; i<m; i++)
            {
                int color = state0 % 3;
                if (!temp.empty() && temp.back()==color)
                {
                    flag = 0;
                    break;
                }
                temp.push_back(color);
                state0 /= 3;                
            }
            if (flag==1)
                cand.push_back(state);
        }
        
        int k = cand.size();
        vector<LL>dp(k, 1);                
               
        for (int j=1; j<n; j++)
        {       
            vector<LL>dp2(k);
            for (int s=0; s<k; s++)                            
                for (int t = 0; t<k; t++)
                {
                    if (checkOK(cand[s],cand[t],m))
                        dp2[s] = (dp2[s] + dp[t]) % M;                    
                }
            dp = std::move(dp2);
        }
                
        LL ret = 0;
        for (int s=0; s<k; s++)
            ret = (ret + dp[s])%M;
        return ret;
        
    }
    
    bool checkOK(int s, int t, int m)
    {
        for (int i=0; i<m; i++)
        {
            if (s%3==t%3)
                return false;
            s /=3;
            t /=3;
        }
        return true;
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/1937.Maximum-Number-of-Points-with-Cost/Readme.md <==
snippet 1937.Maximum-Number-of-Points-with-Cost "1937.Maximum-Number-of-Points-with-Cost" b
### 1937.Maximum-Number-of-Points-with-Cost

我们很容易写出这样的DP写法：
```cpp
for (int i=0; i<m; i++)
  for (int j=0; j<n; j++)
    for (int k=0; k<n; k++)
      dp[i][j] = max(dp[i][j], dp[i-1][k] - abs(j-k) + points[i][j]);
```
这样的时间复杂度是o(MNN)，显然会TLE。怎么改进呢？

我们将绝对值符号拆开就会发现
```cpp
dp[i][j] = max{ dp[i-1][k] + k - j  + points[i][j]};    for k<=j
dp[i][j] = max{ dp[i-1][k] - k + j  + points[i][j]};    for k>=j
```
我们将```dp[i-1][k]+k```看做是一个序列，那么dp[i][j]就需要在这个序列的前j个里面挑一个最大的。于是dp[i][j]其实就是这个序列的rolling max value，再加上一个常数项，计算量可以均摊成o(1)。

同理，我们将将```dp[i-1][k]-k```看做是一个序列，那么dp[i][j]就需要在这个序列的后面n-j个里面挑一个最大的。于是dp[i][j]也是这个序列的rolling max value再加上一个常数项，计算量可以均摊成o(1)。

注意，dp[i][j]最终是需要在两段区间（k<=j 和 k>=j）各自的最大值中挑选一个更大的。

$0
endsnippet

# ==> ./Dynamic_Programming/1937.Maximum-Number-of-Points-with-Cost/1937.Maximum-Number-of-Points-with-Cost.cpp <==
snippet 1937.Maximum-Number-of-Points-with-Cost "1937.Maximum-Number-of-Points-with-Cost" b
using LL = long long;

class Solution {
public:
    long long maxPoints(vector<vector<int>>& points) 
    {
        int m = points.size();
        int n = points[0].size();
        
        vector<vector<LL>>dp(m, vector<LL>(n, INT_MIN));
        for (int j=0; j<n; j++)
            dp[0][j] = points[0][j];
        
        for (int i=1; i<m; i++)            
        {
            LL rollingMax = INT_MIN;            
            for (int j=0; j<n; j++)
            {
                rollingMax = max(rollingMax, dp[i-1][j]+j);
                dp[i][j] = max(dp[i][j], rollingMax + points[i][j] - j);
            }
            
            rollingMax = INT_MIN;            
            for (int j=n-1; j>=0; j--)
            {
                rollingMax = max(rollingMax, dp[i-1][j]-j);
                dp[i][j] = max(dp[i][j], rollingMax +points[i][j] + j);
            }
        }
        
        LL ret = INT_MIN;
        for (int j=0; j<n; j++)
            ret = max(ret, dp[m-1][j]);
        
        return ret;
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/1947.Maximum-Compatibility-Score-Sum/Readme.md <==
snippet 1947.Maximum-Compatibility-Score-Sum "1947.Maximum-Compatibility-Score-Sum" b
### 1947.Maximum-Compatibility-Score-Sum

本题属于带权二分图匹配问题，标准的解法是KM算法。但这里用两种更容易理解和记忆的算法：状态压缩DP，最短路径Dijsktra。本题的套路和1066.Campus bike II，1879.Minimum-XOR-Sum-of-Two-Arrays 差不多。

#### 解法1：状态压缩DP
我们用m位二进制整数state表示学生被匹配的状态。比如0100101表示第1,4,6号学生与前三位导师进行了匹配。

我们令dp[j][state]表示前j个导师与学生匹配状态为state时，我们能得到的最大分数。注意，此时state显然应该恰好有j个bit 1. 状态转移的关键，就是考察当前的第j号导师匹配的是state里的哪一个学生？我们遍历state里比特为1的那些学生i，则有
```cpp
dp[j][state] = max{dp[j-1][state - (1<<i)] + match[i][j] } for all i s.t. state[i]==1
```
事实上，从state里就可以得知我们有多少个导师被匹配了，所以dp下标里的第一个维度j可以省去，即
```cpp
dp[state] = max{dp[state - (1<<i)] + match[i][j] } for all i s.t. state[i]==1
```
最终的答案是```dp[(1<<m)-1]```.

#### 解法2：Dijkstra
本题乍看是求最大的分数，无法用最短路径和的Dijkstra算法。但是我们可以反过来考虑，令unmatch[i][j]表示导师i和学生j相匹配的话会丢失的分数。我们的目的是最小化导师和学生全部配对后的总丢失分数obj。最终输出的答案是```m*n-obj```.

同样我们用state表示学生被匹配的状态。比如0100101表示第1,4,6号学生与前三位导师进行了匹配。它的邻接状态是：再选一个未曾匹配的学生与第四位导师进行匹配，比如(1)100101, 01(1)0101, 010(1)101等等都是可行的邻接节点（括号表示改动的位置）。

如果在state的基础上，我们再令第i位学生与第j位导师匹配得到新的状态state'，那么这两个状态之间的路径就是unmatch[i][j]. 由此，我们把本题就转化为了状态节点之间的最短路径问题。起点的状态节点是000000，终点的状态节点是111111，我们希望求得起点到终点的最短路径。

$0
endsnippet

# ==> ./Dynamic_Programming/1947.Maximum-Compatibility-Score-Sum/1947.Maximum-Compatibility-Score-Sum_v1.cpp <==
snippet 1947.Maximum-Compatibility-Score-Sum "1947.Maximum-Compatibility-Score-Sum" b
class Solution {
    int m, n, t;
    int match[8][8];

public:
    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) 
    {
        m = students.size();
        n = students[0].size();        
        
        for (int i=0; i<m; i++)
            for (int j=0; j<m; j++)
            {
                int count = 0;
                for (int k=0; k<n; k++)
                    count += (students[i][k]==mentors[j][k]);
                match[i][j] = count;
            }
                
        vector<int>dp(1<<m);
        
        for (int j=0; j<m; j++)
        {
            int state = (1 << (j+1)) - 1;            
            while (state < (1 << m))
            {
                for (int i=0; i<m; i++)
                {                    
                    if (((state>>i)&1)==0)
                        continue;
                    dp[state] = max(dp[state], dp[state - (1<<i)] + match[i][j]);
                }

                int c = state & - state;
                int r = state + c;
                state = (((r ^ state) >> 2) / c) | r;
            }
        }
        
        return dp[(1<<m)-1];
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/1947.Maximum-Compatibility-Score-Sum/1947.Maximum-Compatibility-Score-Sum_v2.cpp <==
snippet 1947.Maximum-Compatibility-Score-Sum "1947.Maximum-Compatibility-Score-Sum" b
using PII = pair<int,int>;
class Solution {
    int m, n;
    int match[8][8];
    
public:
    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) 
    {
        m = students.size();
        n = students[0].size();        
        
        for (int i=0; i<m; i++)
            for (int j=0; j<m; j++)
            {
                int count = 0;
                for (int k=0; k<n; k++)
                    count += (students[i][k]==mentors[j][k]);
                match[i][j] = n - count;
            }

        priority_queue<PII, vector<PII>, greater<>>pq;
        pq.push({0, 0});

        vector<int>dp(1<<m, -1);

        while (!pq.empty())
        {
            auto [cost, state] = pq.top();
            pq.pop();

            if (dp[state]!=-1) continue;
            dp[state] = cost;
            if (state == (1<<m)-1)
                return m*n-cost;

            int j = __builtin_popcount(state);
            for (int i=0; i<m; i++)
            {
                if (((state>>i)&1) == 1) continue;
                if (dp[state + (1<<i)]!=-1) continue;
                pq.push({cost + match[i][j], state + (1<<i)});
            }
        }

        return -1;
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/1955.Count-Number-of-Special-Subsequences/Readme.md <==
snippet 1955.Count-Number-of-Special-Subsequences "1955.Count-Number-of-Special-Subsequences" b
### 1955.Count-Number-of-Special-Subsequences

这道题只有三种字符，容易给人一种可以用双指针来遍历边界的错觉。但是双指针需要N^2的时间复杂度，不适合此题。

事实上这题如果想到用DP，算法并不难写。我们令dp[0]表示截止到元素i的位置、以0结尾的子序列的个数。注意，为了保证合法，这样的序列必须只包含0. 同理我们令dp[1]表示截止到元素i的位置、以1结尾的子序列的个数，这样的子序列必须只有0与1，且0都在1之前。令dp[2]表示截止到元素i的位置、以2结尾的子序列的个数，这样的子序列必须只有012，且依次出现。

我们发现，当nums[i]=0的时候，对于dp[1]和dp[2]没有影响，因为我们无法使用这个0得任何新的01序列或者012序列。但是对于已有的纯0序列，我们可以有两种操作：附加上这个位置上的0以构造出新的序列，或者不附加维持原来的纯0序列。这样dp[0]的种类其实就相当于翻倍了，故经过这个位置后，```dp[0] = dp[0]*2```

同理，当nums[i]=1的时候，对于dp[0]和dp[2]没有影响。那么01序列的个数如何变化呢？同样两种操作：不附加这个1，那么原来有多少01序列，现在仍然有多少01序列。附加这个1，那么原来有多少纯0序列和01序列，都会因为添加了这个1成为了一个新的01序列。所以经过这个位置后的01序列包括了三部分：```dp[1] = dp[1] + dp[0] + dp[1]```

同理，当nums[i]=2的时候，对于dp[0]和dp[1]没有影响。那么012序列的个数如何变化呢？同样两种操作：不附加这个2，那么原来有多少012序列，现在仍然有多少012序列。附加这个2，那么原来有多少01序列和012序列，都会因为添加了这个2成为了一个新的012序列。所以经过这个位置后的012序列包括了三部分：```dp[2] = dp[2] + dp[1] + dp[2]```

最终的答案就是在最后一个位置后的dp[2]。

本题的难点是初始状态的设计。我们可以想象，如果我们把三个量都初始化为0的话，那么所有的结果都依然为0. 所有我们不得不给一个初始的“动量”，就是令dp[0]=1. 但是这样会出现一个问题，dp[0]所表示的纯0序列的个数，其实包括了零个0的情况。当我们构造01序列时候，要求纯0序列的部分不能为空，所以对于dp[1]需要改动为```dp[1] = dp[1] + (dp[0]-1) + dp[1]```. 注意，对于dp[1]和dp[2]的表达式，我们都保证了1和2的个数都不为零，故我们没有类似的担心。经过修改后，dp[1]和dp[2]都能准确地表示合法的01序列和012序列的个数。

$0
endsnippet

# ==> ./Dynamic_Programming/1955.Count-Number-of-Special-Subsequences/1955.Count-Number-of-Special-Subsequences.cpp <==
snippet 1955.Count-Number-of-Special-Subsequences "1955.Count-Number-of-Special-Subsequences" b
using LL = long long;
class Solution {
    LL M = 1e9+7;
public:
    int countSpecialSubsequences(vector<int>& nums) 
    {
        LL dp0 = 1, dp1 = 0, dp2 = 0;
        for (int i=0; i<nums.size(); i++)
        {
            if (nums[i]==0)
                dp0 = (dp0 * 2) % M;
            else if (nums[i]==1)
                dp1 = (dp0-1 + dp1*2) % M;
            else
                dp2 = (dp1 + dp2*2) % M;
        }
        return dp2;        
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/1959.minimum-total-space-wasted-with-k-resizing-operations/Readme.md <==
snippet 1959.minimum-total-space-wasted-with-k-resizing-operations "1959.minimum-total-space-wasted-with-k-resizing-operations" b
### 1959.minimum-total-space-wasted-with-k-resizing-operations

我们令dp[i][j]表示前i个数经过j次调整后的最小浪费空间。

我们在计算dp[i][j]的时候，考虑的是最后一次调整所覆盖的范围。我们遍历一个分割位置s，假设[s:i]这个区间是最后一次调整的范围，那么状态转移方程式
```cpp
dp[i][j] = min{ dp[s-1][j-1] + cost[s:i] } for s=1,2,...,i
```
那么我们怎么知道最后一次调整应该调整到什么size呢？其实很简单，要使最后一次调整的size能够装下nums[s:i]的所有元素，并且浪费空间最少，那么必然size就是nums[s:i]中的最大值mx。这样最后一个区间的浪费空间就是```mx*(i-s+1) - intervalSum[s:i]```.

在实际的操作中，我们会将s从大到小遍历，这样mx和intervalSum都可以o(1)时间更新。

总的时间复杂度是o(NKK).

$0
endsnippet

# ==> ./Dynamic_Programming/1959.minimum-total-space-wasted-with-k-resizing-operations/1959.minimum-total-space-wasted-with-k-resizing-operations.cpp <==
snippet 1959.minimum-total-space-wasted-with-k-resizing-operations "1959.minimum-total-space-wasted-with-k-resizing-operations" b
class Solution {    
public:
    int minSpaceWastedKResizing(vector<int>& nums, int k) 
    {
        int n = nums.size();
        int dp[n][k+1];

        for (int i=0; i<n; i++)
            for (int j=0; j<=k; j++)
                dp[i][j] = INT_MAX/2;

        int mx = 0;
        int sum = 0;
        for (int i=0; i<n; i++)
        {
            mx = max(mx, nums[i]);
            sum += nums[i];
            dp[i][0] = mx*(i+1)-sum;
        }        

        for (int i=1; i<n; i++)          
            for (int j=1; j<=min(i, k); j++)
            {
                int mx = 0;
                int intervalSum = 0;
                for (int s=i; (s>=j-1) && (s>=1); s--)
                {
                    mx = max(mx, nums[s]);
                    intervalSum += nums[s];
                    dp[i][j] = min(dp[i][j], dp[s-1][j-1] + mx*(i-s+1) - intervalSum);
                }
            }

        int ret = INT_MAX/2;
        for (int j=0; j<=k; j++)
            ret = min(ret, dp[n-1][j]);
        return ret;
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/1977.Number-of-Ways-to-Separate-Numbers/Readme.md <==
snippet 1977.Number-of-Ways-to-Separate-Numbers "1977.Number-of-Ways-to-Separate-Numbers" b
### 1977.Number-of-Ways-to-Separate-Numbers

将连续的字符串划分成若干个数字组成的序列，相当于“划分区间”。如果令dp[i]表示前i个字符能组成的递增序列的方案数，那么突破口就是最后一个数字（也就是区间）的范围。这就联想到了第一类区间型DP。我们令dp[i][len]表示由前i个字符组成、且最后一个数字的字符长度是len的递增序列的方案数。
```
X X X (X X X X) [X X X X]
       k        j      i
```
在上面的例子中，令```j = i-len+1```，那么[j:i]就是最后一个元素（记做Z）。根据规则，我们需要倒数第二个元素（记做Y）小于等于Z。我们发现y的起始位置有多种可能。当k=j-1的时候，显然Y会小于Z，所以属于dp[k][j-k]的任何方案，都可以加上Z，继续构成dp[i][len]的方案。同理，当k=j-2的时候，也是成立的。显然，k可以不停前移，一直到```k = j-len```的时候打住，因为我们并不能确认此时的Y和Z是否依然是递增的（因为位数相同）。所以综上
```
dp[i][len] = sum {dp[j-1][len2]} for len2 = 1, 2, 3, ... , len-1, (len) ?
```
其中len2是否能取到len，取决于```[j-len: j-1]```与```[j:i]```孰大孰小。

所以大致的状态转移方程：
```cpp
for (int i=0; i<n; i++)
  for (int len=1; len<=i+1; len++)
  {
      int maxLen2 = len-1;
      if (s[j-len:j-1] <= s[j:i])
        maxLen2++;
      for (int len2 = 1; len2 <= maxLen2; len2++)
        dp[i][len] += dp[j-1][len2];
  }
```

此时我们发现这段代码需要三重循环，时间复杂度是N^3，会TLE。那么该如何优化呢？我们发现最内层的循环其实是dp[j-1][x]的一个前缀和```presum_dp[j-1][maxLen2]```，所以可以改写成
```cpp
for (int i=0; i<n; i++)
  for (int len=1; len<=i+1; len++)
  {
      int maxLen2 = len-1;
      if (s[j-len:j-1] <= s[j:i])
        maxLen2++;
      dp[i][len] += presum_dp[j-1][maxLen2];
  }
```

我们接着发现，我们永远是拿pre_dp给dp赋值。说明其实我们需要不停更新的是pre_dp. 所以计算得到的dp[i][len]要回馈给pre_dp. 并且len本身就是从小到大遍历的，所以我们同样构建dp[i][x]的前缀和。所以继续改写：
```cpp
for (int i=0; i<n; i++)
  for (int len=1; len<=i+1; len++)
  {
      int maxLen2 = len-1;
      if (s[j-len:j-1] <= s[j:i])
        maxLen2++;
      dp[i][len] += presum_dp[j-1][maxLen2];
      presum_dp[i][len] = presum_dp[i][len-1]+dp[i][len];
  }
```
所以这道题本质上的需要更新的状态变量不是dp[i][len]，而是presum_dp[i][len]. 而dp只是一个临时变量而已。

此时的代码看上去是二重循环了。但是其中有一个细节还需要优化：如何判断两个长度相同的字符串```s[j-len:j-1]```和```s[j:i]```谁大谁小？如果挨个字符检查一遍，就又要o(N)的复杂度。怎么优化呢？很巧妙，我们用o(N^2)的时间提前计算s里面任意两个位置a,b的longest common substring。有了lcs[a][b]的数据，那么对于两个字符串```s[j-len:j-1]```和```s[j:i]```，我们可以跳过前面的相同字符，直接定位到```j-len+lcs[j-len][j]```和```j+lcs[j-len][j]```这两个有着不同字符的位置，看看此处的字符谁大谁小即可。

最终输出的答案是```presum_dp[n-1][n]```

$0
endsnippet

# ==> ./Dynamic_Programming/1977.Number-of-Ways-to-Separate-Numbers/1977.Number-of-Ways-to-Separate-Numbers.cpp <==
snippet 1977.Number-of-Ways-to-Separate-Numbers "1977.Number-of-Ways-to-Separate-Numbers" b
using PII = pair<long, long>;
class Solution {
    long M = 1e9+7;
public:
    bool larger(string& s, int a, int b, int len)
    {        
        for (int i=0; i<len; i++)
            if (s[a+i]!=s[b+i])
                return s[a+i]>s[b+i];
        return false;
    }
    
    int numberOfCombinations(string num) 
    {
        int n = num.size(); 
        if (num[0]=='0') return 0;
        
        vector<vector<int>>accum(n+2, vector<int>(n+2));
        vector<vector<int>>lcs(n+2, vector<int>(n+2));
        
        for (int i=n-1; i>=0; i--)
            for (int j=n-1; j>=0; j--)
            {
                if (num[i]==num[j])
                    lcs[i][j] = lcs[i+1][j+1]+1;
                else
                    lcs[i][j] = 0;
            }
                
        for (int i=0; i<n; i++)    
            for (int len=1; len<=i+1; len++)                        
            {                                
                int j = i-len+1;
                int dp = 0;
                
                if (num[j]=='0')                 
                    dp = 0;
                else if (len==i+1)
                    dp = 1;
                else
                {
                    int maxLen2 = min(len, j);
                    
                    if (len==maxLen2 && lcs[j-maxLen2][j]<len && num[j-maxLen2+lcs[j-maxLen2][j]]>num[j+lcs[j-maxLen2][j]])
                        maxLen2--;
                    while (maxLen2>=1 && num[j-maxLen2]=='0')
                        maxLen2--;
                    
                    if (maxLen2>=1)
                        dp = accum[j-1][maxLen2];
                }
                
                accum[i][len] = (accum[i][len-1] + dp) % M;
            }        
                        
        return accum[n-1][n];
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/1981.Minimize-the-Difference-Between-Target-and-Chosen-Elements/Readme.md <==
snippet 1981.Minimize-the-Difference-Between-Target-and-Chosen-Elements "1981.Minimize-the-Difference-Between-Target-and-Chosen-Elements" b
### 1981.Minimize-the-Difference-Between-Target-and-Chosen-Elements

此题类似于分组背包问题。每组物品里只能取一个，求如何选取物品最接近target。

背包问题的思想核心就是以容量为考察点。选择完第一组物品会占据哪些容量。将这些可能的容量，再与第二组物品两两组合，得到第二轮结束后可能会占据哪些容量。依次处理完所有组，就可以得到最终可能会占据哪些容量，再挑选其中与target最接近的一个。

因为最多有70组，每个物品最多是70，最终总容量的可能性是```70*70=4900```，所以每一个回合需要遍历4900种容量，并且与下一组的70个物品两两组合。总共70个回合。所以总的时间复杂度是```4900*70*70```. 这样的复杂度太大了，哪里可以优化呢？

本题的target不超过800，所以每一个回合时，任何大于target的容量，我们只保留最小的一个即可。因为其他更大的容量（随着更多物品的累积）必然与target的差距会更大。所以每一个回合我们只需要遍历801种容量即可。于是时间复杂度就降下来了。

$0
endsnippet

# ==> ./Dynamic_Programming/1981.Minimize-the-Difference-Between-Target-and-Chosen-Elements/1981.Minimize-the-Difference-Between-Target-and-Chosen-Elements.cpp <==
snippet 1981.Minimize-the-Difference-Between-Target-and-Chosen-Elements "1981.Minimize-the-Difference-Between-Target-and-Chosen-Elements" b
class Solution {
public:
    int minimizeTheDifference(vector<vector<int>>& mat, int target) 
    {
        int m = mat.size();
        int n = mat[0].size();
        unordered_set<int>Set({0});
        
        for (int i=0; i<m; i++)
        {
            unordered_set<int>temp;
            int great = -1;
            for (auto x: Set)
            {
                for (auto y: mat[i])
                {
                    if (x+y <= target)
                        temp.insert(x+y);
                    else
                    {
                        if (great==-1)
                            great = x+y;
                        else if (x+y < great)
                            great = x+y;                            
                    }
                }                    
            }
            if (great!=-1)
                temp.insert(great);
            
            Set = std::move(temp);                       
        }
        
        int diff = INT_MAX;
        for (auto x:Set)
        {
            diff = min(diff, abs(x-target));
        }
        return diff;
        
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/1986.Minimum-Number-of-Work-Sessions-to-Finish-the-Tasks/Readme.md <==
snippet 1986.Minimum-Number-of-Work-Sessions-to-Finish-the-Tasks "1986.Minimum-Number-of-Work-Sessions-to-Finish-the-Tasks" b
### 1986.Minimum-Number-of-Work-Sessions-to-Finish-the-Tasks

因为数据规模n<=14，考虑到3^14是4e6数量级，可以判定这是非常套路的“枚举子集”的动态规划问题。

我们用长度为14的二进制数state的每个bit位表示该任务是否被实施，那么dp[state]表示state所代表的任务集合需要最少多少个session。

利用枚举子集的模板：
```cpp
  for (int state=1; state<(1<<n); state++)  
      for (int subset=state; subset>0; subset=(subset-1)&state)
      {
          dp[state] = DoSomething(dp[subset]);
      }  
```
dp[state]如果对应着多个session，那么它必然可以“拆分”成两个任务集subset与state-subset，然后对各自所需的session数目进行相加。所以我们需要遍历state的所有subset，找到最优的一种拆分。即```dp[state]=min{dp[subset]+dp[state-subset]}```。注意，上述的枚举子集的框架，所需要的时间复杂度是o(3^n)而不是o(2^n)

初始值：对于一些特定的任务组合state，如果总时间小于sessionTime，那么他们的dp[state]就是1. 其余的dp[state]我们都设置为无穷大。这需要花费2^n的时间预处理遍历所有的组合。。


$0
endsnippet

# ==> ./Dynamic_Programming/1986.Minimum-Number-of-Work-Sessions-to-Finish-the-Tasks/1986.Minimum-Number-of-Work-Sessions-to-Finish-the-Tasks.cpp <==
snippet 1986.Minimum-Number-of-Work-Sessions-to-Finish-the-Tasks "1986.Minimum-Number-of-Work-Sessions-to-Finish-the-Tasks" b
class Solution {
public:
    int minSessions(vector<int>& tasks, int sessionTime) 
    {        
        int n = tasks.size();
        vector<int>dp((1<<n), INT_MAX/2);
        for (int state=0; state<(1<<n); state++)
        {
            int sum = 0;
            for (int i=0; i<n; i++)
            {
                if ((state>>i)&1)
                    sum+=tasks[i];
            }
            if (sum<=sessionTime)
                dp[state]=1;
        }
        
        for (int state=1; state<(1<<n); state++)
        {
            for (int subset=state; subset>0; subset=(subset-1)&state)
            {
                dp[state] = min(dp[state], dp[subset]+dp[state-subset]);                                    
            }
        }
        return dp[(1<<n)-1];
        
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/1987.Number-of-Unique-Good-Subsequences/Readme.md <==
snippet 1987.Number-of-Unique-Good-Subsequences "1987.Number-of-Unique-Good-Subsequences" b
### 1987.Number-of-Unique-Good-Subsequences

此题和```LC940.Distinct-Subsequences-II```的联系非常紧密。我们可以先用LC940的方法计算所有distinct subsequence的总数。令dp[i]表示前i个字符的前缀里有多少个不同的子序列（包括有先导零的子序列以及空子序列）。核心代码如下：
```cpp
for (int i=1; i<=n; i++)
{
  int j = s[i]=='0' ? last0[i] : last1[i];
  dp[i] = dp[i-1]*2 - dp[j-1];
}
```
那么接下来如何转变为题目要求的“无先导零”的子序列呢？我们发现上述式子里的dp[i]都依赖于dp[i-1]，所以我们只要控制初始的dp值即可。假设binary的开头有m个零，那么显然dp[1]到dp[m]都应该是0，因为它们无法拼凑出任何合法的子序列。而dp[m+1]应该是1，因为它只能构造“1”这一个合法的子序列。此后对于i>m+1，利用上述的代码能够得到所有正确的dp[i]。

这里给个直观的解释。首先，从i=m+1开始```+ dp[i-1]*2```这部分，意思是在前面已有的合法子序列的基础上，append s[i] or not，因此所对应的一定都是已经以1开头的子序列。其次```-dp[j-1]```这部分，去重的是形如```x x x s[i]```这样的字符串，其中```x x x```是前j-1个字符所能构建的distinct subsequence. 如果j-1<=m，那么这些dp[j-1]都预置为0，所以去重的部分也不会包括以0开头的子序列。综上所述，每一步所计算的dp[i]都表达的是以1开头的子序列。

此外需要说明的是，很多题解的代码写成了如下的形式：
```cpp
if (s[i]=='0')
  dp[i][0] = dp[i-1][0]+dp[i-1][1];
else
  dp[i][1] = dp[i-1][0]+dp[i-1][1]+1;
```
这样的结果是对的，但简洁的代码背后，理解上其实有很大的思维的跳跃，我觉得不够清晰。上面的表达式dp[i][0]，看上去是说前i个字符构成的、以0结尾的合法子序列，必须是在前i-1个字符构成的合法子序列的基础上append当前s[i]所对应的这个0。dp[i][1]的解释同理类似，但多了一个单独以s[i]构造“1”的情况。但这个其实是没有道理的，我们完全有权利不使用s[i]这个字符呀。所以还有更深的微妙的分析隐藏在里面，对于这个代码的解释并不像表面上那么容易。国服的官方解答就是用了很大的篇幅才对上面的代码做了比较全面的解释。

$0
endsnippet

# ==> ./Dynamic_Programming/1987.Number-of-Unique-Good-Subsequences/1987.Number-of-Unique-Good-Subsequences_v1.cpp <==
snippet 1987.Number-of-Unique-Good-Subsequences "1987.Number-of-Unique-Good-Subsequences" b
using LL = long long;
class Solution {
    LL M = 1e9+7;
public:
    int numberOfUniqueGoodSubsequences(string binary) 
    {
        int n = binary.size();
        string s = "#" + binary;
        vector<LL>dp(n+1,0);
        
        int start = 1;
        while (start <=n && s[start]=='0')
            start++;        
        if (start==n+1) return 1;
        dp[start] = 1;

        int last0 = 0;
        int last1 = 0;
        
        for (int i=start+1; i<=n; i++)
        {            
            int j = (s[i]=='0')? last0:last1;
            dp[i] = dp[i-1] *2 - (j>=1 ? dp[j-1]:0);    
            dp[i] = (dp[i] + M) % M;

            if (s[i]=='0') last0 = i;
            else last1 = i;
        }    
        
        return dp[n] + (binary.find("0")!=-1);
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/1994.The-Number-of-Good-Subsets/Readme.md <==
snippet 1994.The-Number-of-Good-Subsets "1994.The-Number-of-Good-Subsets" b
### 1994.The-Number-of-Good-Subsets

#### 解法1： bit mask
根据题意，一个合法的集合不可能会有重复的元素（我们暂时将1移出nums不考虑），否则整体的乘积一定含有两个相同的质因数。另外约束中给出nums的数值不超过30，所以一个合法的集合的元素的个数不会超过30，并且彼此互异。同时我们考虑如果自身已经含有重复质因数的num，一定不能加入这个集合，比如2的倍数、3的倍数等等。所以集合的候选元素只可能有这些
```
{2,3,5,6,7,10,11,13,14,15,17,19,21,22,23,26,29,30}
```
总共是18个。合法的集合一定是这18个元素的一个组合，可能性就是2^18=2e6，穷举一下是可行的。

当然，并非这2^18中组合都是合法的。我们还需要检验每个组合里，是否有任意一对元素不满足互质的，所以需要套上一个```18*18```的检验。通过了校验之后，我们就可以计算这种组合有多少构造方法。假设这个组合由{a,b,c...}组成，那么能构成这种集合的数量就是```count[a]*count[b]*count[c]*...```

我们把所有组合所对应的集合数量都加起来，记做ret。此时再考虑元素1的影响：因为无论元素1是否加入集合、以及加入多少个，都不影响之前的那些集合的合法性。所以最终的答案就是 ```ret * 2^count[1]```.

#### 解法2： 状态压缩DP
上述的解法虽然用了bit mask，但本质不是状态压缩DP，仅仅是用了二进制数来方便枚举而已。并且时间复杂度刚刚过线。

我们有更巧妙的方法设计状态。我们不以nums的元素作为bit的含义，而是以30以内的质因数作为bit的含义。任何一个合法的集合，根据其所含元素的因式分解，必然对应着{2,3,5,7,11,13,17,19,23,29}的一个组合。其中的每个质因数在这个集合中只出现过一次。穷举所有的组合，只要2^10=1024种情况，效率高很多。

我们令dp[state]表示质因数组合为state所代表的集合有多少种构造方法。我们类似背包问题的思想，对于每个num，我们先分解质因数：如果它包含有重复的质因数就直接舍弃，因为它无法加入任何一个合法集合；否则的话根据它的质因数分解，我们可以得到类似的状态压缩编码encode。对于那些完全包含encode的state（即encode是state的子集），我们都可以更新那些```dp[state] += dp[state-encode] * count[num]```. 因为dp[state-encode]对应有多少种集合构造方法，在其基础上加上num，就构造出了dp[state]所对应的集合。

因为任何一个state所对应的质因数组合都是一个合法的集合，最终我们需要累加```ret += sum{dp[state]}, state=1,2,...,(1<<10)```

此外，请记得考虑元素1的影响：因为无论元素1是否加入集合、以及加入多少个，都不影响上述这些集合的合法性。所以最终的答案就是 ```ret * 2^count[1]```.

$0
endsnippet

# ==> ./Dynamic_Programming/1994.The-Number-of-Good-Subsets/1994.The-Number-of-Good-Subsets_v1.cpp <==
snippet 1994.The-Number-of-Good-Subsets "1994.The-Number-of-Good-Subsets" b
class Solution {
    long M = 1e9+7;
public:
    int numberOfGoodSubsets(vector<int>& nums) 
    {        
        unordered_set<int>Set({2,3,5,6,7,10,11,13,14,15,17,19,21,22,23,26,29,30});        
        map<int,int>Map;        
        int count1 = 0;
        for (int x: nums)
        {
            if (Set.find(x)!=Set.end())            
                Map[x]+=1;            
            if (x==1)
                count1++;
        }

        int n = Map.size();
        vector<int>count;
        vector<int>digit;
        for (auto p: Map)
        {
            digit.push_back(p.first);
            count.push_back(p.second);
        }
        
        long ret = 0;
        for (int state=1; state<(1<<n); state++)
        {
            int flag = 1;
            for (int i=0; i<n; i++)
            {
                if (((state>>i)&1)==0) continue;
                for (int j=i+1; j<n; j++)
                {                    
                    if (((state>>j)&1)==0) continue;
                    if (gcd(digit[i], digit[j])!=1)
                    {
                        flag = 0;
                        break;
                    }
                }
                if (flag==0)
                    break;
            }

            if (flag==0) continue;

            long ans = 1;
            for (int i=0; i<n; i++)
            {
                if (((state>>i)&1)==0) continue;
                ans *= count[i];
                ans %= M;
            }
            ret = (ret+ans) % M;
        }

        ret = ret * quickMul(2, count1) % M;
        return ret;
    }

    long quickMul(long x, long N) {
        if (N == 0) {
            return 1;
        }
        long y = quickMul(x, N / 2);
        return N % 2 == 0 ? y * y % M: y * y  % M * x % M;
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/1994.The-Number-of-Good-Subsets/1994.The-Number-of-Good-Subsets_v2.cpp <==
snippet 1994.The-Number-of-Good-Subsets "1994.The-Number-of-Good-Subsets" b
class Solution {
    vector<int>primes = {2,3,5,7,11,13,17,19,23,29};    
    long M = 1e9+7;
public:
    int numberOfGoodSubsets(vector<int>& nums) 
    {        
        int n = primes.size();
        vector<long>dp(1<<n);
        dp[0] = 1;

        unordered_map<int,int>Map;
        for (auto x: nums)
            Map[x]++;
        
        int count1 = 0;
        for (auto p: Map)
        {
            int x = p.first;
            int count = p.second;

            if (x==1) continue;
            int encode = encoding(x);
            if (encode==-1) continue;

            for (int state=(1<<n)-1; state>=1; state--)
            {
                if (state-encode == (state^encode))                
                    dp[state] = (dp[state] + dp[state-encode]*count%M) % M; 
            }
        }

        long ret = 0;
        for (int state=1; state<(1<<n); state++)
            ret = (ret+dp[state])%M;

        long power2 = 1;
        for (int i=0; i<Map[1]; i++)
            power2 = (power2 * 2) % M;

        return ret * power2 % M;
    }

    int encoding(int num)
    {       
        int encode = 0; 
        for (int i=0; i<primes.size(); i++)
        {
            if (num % primes[i] ==0)
            {
                encode += (1<<i);
                num /= primes[i];
            }                
            if (num % primes[i]==0)
                return -1;
        }
        return encode;
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/2036.Maximum-Alternating-Subarray-Sum/Readme.md <==
snippet 2036.Maximum-Alternating-Subarray-Sum "2036.Maximum-Alternating-Subarray-Sum" b
### 2036.Maximum-Alternating-Subarray-Sum

我们定义两个状态，curSum0[i]表示以元素i结尾、并且元素i本身未被符号翻转的情况下（即+nums[i]），能够得到的max subarray sum. 同理，curSum1[i]表示以元素i结尾、并且元素i本身已经被符号翻转的情况下（即-nums[i]），能够得到的max subarray sum. 

对于curSum0[i]，它两种可能。要么subarray仅包含单个元素+nums[i]。要么需要把+nums[i]和前面的subarray连起来使用：显然能与+nums[i]连在一起的，必然是curSum1[i-1]. 所以```curSum0[i] = max(nums[i], curSum1[i-1]+nums[i]```.

对于curSum1[i]，它其实只有一种可能，即需要和前面的subarray连起来使用。这是因为题目不允许subarray的开头是一个符号反转的元素。所以-nums[i]必须curSum0[i-1]连在一起. 所以```curSum1[i] = curSum0[i-1]-nums[i]```.

此外特别注意，对于边界条件，curSum1[-1]可以是0，但是curSum0[-1]必须设置为无穷小。这是因为nums[0]只能作为一个subarray的开头，它不能被符号翻转，所以```curSum1[0] = curSum0[-1]-nums[i]```没有意义。

$0
endsnippet

# ==> ./Dynamic_Programming/2036.Maximum-Alternating-Subarray-Sum/2036.Maximum-Alternating-Subarray-Sum.cpp <==
snippet 2036.Maximum-Alternating-Subarray-Sum "2036.Maximum-Alternating-Subarray-Sum" b
using LL = long long;
class Solution {
public:
    long long maximumAlternatingSubarraySum(vector<int>& nums) 
    {
        LL ret = INT_MIN;
        LL curSum0 = INT_MIN;
        LL curSum1 = 0;
        
        for (LL x: nums)
        {
            LL curSum0_temp = curSum0;
            LL curSum1_temp = curSum1;
            curSum0 = max(curSum1_temp + x, x);
            curSum1 = curSum0_temp - x;
                        
            ret = max(ret, curSum0);
            ret = max(ret, curSum1);
        }        
        return ret;        
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/2044.Count-Number-of-Maximum-Bitwise-OR-Subsets/Readme.md <==
snippet 2044.Count-Number-of-Maximum-Bitwise-OR-Subsets "2044.Count-Number-of-Maximum-Bitwise-OR-Subsets" b
### 2044.Count-Number-of-Maximum-Bitwise-OR-Subsets

因为所有的元素都小于1e5，它们只需要17个bit即可表达。而且不管OR的操作进行多少次，都不会溢出2^17的范围。所以我们可以枚举所有可能的bitwise OR的结果，令dp[val]表示得到val的方案数。类似背包问题，我们每得到一个新的数字x，就可以考虑它的作用，更新一遍所有的dp[val].

注意，本题中的状态转移是从现在转移到未来。也就是已知上一轮的dp[i-1][val]，那么我们此次使用x的话，可以知道这一轮dp[i][val|x]的实现至少能有dp[i-1][val]种方案（就是在原先dp[val]所对应的方案基础上都使用x）。

如果状态转移的策略反过来的话就很难做。因为如果我们想知道本轮的dp[i][val]，就需要穷举上一轮的所有满足```v|x == val```的状态v，这样才能有```dp[i][val] = sum(dp[i-1][v]```. 

$0
endsnippet

# ==> ./Dynamic_Programming/2044.Count-Number-of-Maximum-Bitwise-OR-Subsets/2044.Count-Number-of-Maximum-Bitwise-OR-Subsets.cpp <==
snippet 2044.Count-Number-of-Maximum-Bitwise-OR-Subsets "2044.Count-Number-of-Maximum-Bitwise-OR-Subsets" b
class Solution {
public:
    int countMaxOrSubsets(vector<int>& nums) 
    {
        int n = nums.size();
        int M = (1<<17);
        vector<int>dp(M+1);
        dp[0] = 1;
        
        for (int x : nums)
        {
            auto dp2 = dp;
            for (int s = 0; s<M; s++)
            {
                dp2[s|x] += dp[s];
            }
            dp = std::move(dp2);
        }
        
        for (int s=M; s>=0; s--)
        {
            if (dp[s]>0)
                return dp[s];
        }
        
        return 0;        
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/2052.Minimum-Cost-to-Separate-Sentence-Into-Rows/Readme.md <==
snippet 2052.Minimum-Cost-to-Separate-Sentence-Into-Rows "2052.Minimum-Cost-to-Separate-Sentence-Into-Rows" b
### 2052.Minimum-Cost-to-Separate-Sentence-Into-Rows

首先计算每个单词的长度，放入数组nums. 

令dp[i]表前i个单词所需要的最小cost是多少。显然我们会考虑i所在的行的第一个单词j的选择，这样就有```dp[i] = dp[j-1] +  cost(k, len[j:i], (i-j)) ```，其中len[j:i]表示第j个到第i个单词的总词长，(i-j)表示该行需要的空格长度。其中我们令j从i开始，从后往前遍历，直至不满足```len[j:i]+(i-j)<=k```

特别注意，本题中的cost不包含最后一行。因此我们在计算i=n的时候，答案就是此时所有合法dp[j-1]中的最小值。

$0
endsnippet

# ==> ./Dynamic_Programming/2052.Minimum-Cost-to-Separate-Sentence-Into-Rows/2052.Minimum-Cost-to-Separate-Sentence-Into-Rows.cpp <==
snippet 2052.Minimum-Cost-to-Separate-Sentence-Into-Rows "2052.Minimum-Cost-to-Separate-Sentence-Into-Rows" b
class Solution {
public:
    int minimumCost(string sentence, int k) 
    {
        vector<int>nums;
        for (int i=0; i<sentence.size(); i++)
        {
            int j = i;
            while (j<sentence.size() && isalpha(sentence[j]))
                j++;
            nums.push_back(j-i);
            i = j;
        }
        
        int n = nums.size();
        nums.insert(nums.begin(), 0);
        
        int ret = INT_MAX/2;
        vector<int>dp(n+1, INT_MAX/2);
        dp[0] = 0;
        for (int i=1; i<=n; i++)
        {
            int len = -1;
            int j = i;
            while (j>=1 && len+nums[j]+1 <= k)
            {
                len += nums[j]+1;                
                dp[i] = min(dp[i], dp[j-1]+(k-len)*(k-len));
                                                
                if (i==n) ret = min(ret, dp[j-1]);
                j--;
            }               
        }
        
        return ret;        
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/2088.Count-Fertile-Pyramids-in-a-Land/Readme.md <==
snippet 2088.Count-Fertile-Pyramids-in-a-Land "2088.Count-Fertile-Pyramids-in-a-Land" b
### 2088.Count-Fertile-Pyramids-in-a-Land

如果我们想不重复地数金字塔，那么就必须抓住金字塔的特征。我们通过数特征来统计金字塔的数目。

我们最容易想到的是金字塔的顶尖。任何一个金字塔都有一个唯一的顶尖，我们可以考虑遍历每个格子，思考如果它作为某个金字塔的顶尖的话，可以代表哪些金字塔。显然，我们光看这个格子A本身是不充分，我们得看它往下一格B，查看B是否为一个长度为3的区间的中点；再查看B的下一格C，查看C是否为一个长度为5的区间的中点... 直至类似的规律不能再持续下去。我们往下几行，就意味着A可以是几个不同金字塔的塔尖。不过这样的时间复杂度将会是o(MMN).

我们注意到，上述方法时间复杂度高是因为我们站在top，无法了解bottom的情况，所以才需要逐层下沉去调查。举个例子，我们知道某点A是一个三层金字塔的顶，那么它是否也是一个四层金字塔的顶呢？我们不知道，得下沉了才知道。

那么反过来会怎么样呢？我们站在下层，是否能知道上层的情况呢？这其实是可行的。比如说，我们站在某点A，如果知道它是一个三层金字塔的底座中点，那么我们就一定知道A也同时是一个二层金子它的底座中点。这样，如果考察每个点作为金字塔底座中点的情况，那么我们就不需要向上调查就能知道它可以对应几个不同的金字塔。这就方便多了。

那么对于任意一点A，我们如何可以知道它最大可以是多少层金字塔的底座中点呢？首先，我们要知道它自身可以是一个多长连续区间的中点。这个可以通过从左往右、从右往左两遍预处理得到。其次我们知道，如果A想成为一个三层金字塔的底座中点，那么A上面的那个格子B必须至少是一个两层金字塔的底座中点。所以我们对于A对应底座半径就有了如下的表达式：
```
dp(A) = min(left(A), right(A), dp(B)+1)
```
其中dp表示最大金字塔的底座半径，left表示A往左边最多连续多少个1，right表示A往右边最多连续多少个1.

注意最终答案不能包括层数为1的金字塔，所以答案是累加所有格子的dp值减1.

$0
endsnippet

# ==> ./Dynamic_Programming/2088.Count-Fertile-Pyramids-in-a-Land/2088.Count-Fertile-Pyramids-in-a-Land.cpp <==
snippet 2088.Count-Fertile-Pyramids-in-a-Land "2088.Count-Fertile-Pyramids-in-a-Land" b
class Solution {
public:
    int countPyramids(vector<vector<int>>& grid) 
    {
        int m = grid.size();
        int n = grid[0].size();
        
        vector<vector<int>>left(m, vector<int>(n));
        vector<vector<int>>right(m, vector<int>(n));
        vector<vector<int>>dp1(m, vector<int>(n));
        vector<vector<int>>dp2(m, vector<int>(n));
        
        for (int i=0; i<m; i++)
        {
            int count = 0;
            for (int j=0; j<n; j++)
            {
                if (grid[i][j]==0)
                    count = 0;
                else
                    count+=1;
                left[i][j] = count;
            }
        }
        
        for (int i=0; i<m; i++)
        {
            int count = 0;
            for (int j=n-1; j>=0; j--)
            {
                if (grid[i][j]==0)
                    count = 0;
                else
                    count+=1;
                right[i][j] = count;
            }
        }
        
        int ret = 0;
        for (int i=0; i<m; i++)
            for (int j=0; j<n; j++)
            {
                if (grid[i][j]==0) continue;
                if (i==0)
                {
                    dp1[i][j] = 1;
                }
                else
                {
                    dp1[i][j] = min(min(left[i][j], right[i][j]), dp1[i-1][j]+1);
                }
                ret += dp1[i][j]-1;
            }
        
        for (int i=m-1; i>=0; i--)
            for (int j=0; j<n; j++)
            {
                if (grid[i][j]==0) continue;
                if (i==m-1)
                {
                    dp2[i][j] = 1;
                }
                else
                {
                    dp2[i][j] = min(min(left[i][j], right[i][j]), dp2[i+1][j]+1);
                }
                ret += dp2[i][j]-1;
            }
        
        return ret;
        
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/2140.Solving-Questions-With-Brainpower/Readme.md <==
snippet 2140.Solving-Questions-With-Brainpower "2140.Solving-Questions-With-Brainpower" b
### 2140.Solving-Questions-With-Brainpower

#### 解法1

因为n是1e5数量级，我们期望能用o(n)的时间复杂度解决。我们尝试令dp[i]表示前i个元素能取得的最大值，特别注意到，dp一定是递增的序列。

第一种“填表”思路是用已知的dp来计算当前的dp[i]。显然，如果我们不取第i个元素，那么dp[i]=dp[i-1]；如果我们取第i个元素，那么就有```dp[i] = dp[j] + val[i], where j+skip[j]<i```，其中要求i必须在j的冷冻期之后。但这里有个bug，假设dp[j]=dp[j-1]（对应我们取第j-1个元素，但是不取第j个元素），但j的冷冻期很短，而j-1的冷冻期很长。这样可能i没有落在j的冷冻期，但是落在了j-1的冷冻期。此时我们计算```dp[i] = dp[j] + val[i]```就出现了问题，因为dp[j]的本质是依赖于dp[j-1]的，必须考虑的是j-1的冷冻期。

第二种“刷表”思路是用当前的dp[i]来更新未来的DP，尝试构造```dp[i+skip+1] = max{dp[i+skip+1], dp[i] + val[i+skip+1}```. 这样也是有问题的。类似的，假设dp[i]=dp[i-1]（对应取第i-1个元素，但是不取第i个元素）。但i的冷冻期很短，而i-1的冷冻期很长。这样可能i+skip+1没有落在i的冷冻期，但是落在了i-1的冷冻期。此时我们用上面的式子就出现了问题，因为dp[i]的本质是依赖于dp[i-1]的，必须考虑的是i-1的冷冻期。

本题的思路非常巧妙，就是从后往前遍历。同样dp[i]表示从i到第n-1个元素能取得的最大值。如果我们不取第i个元素，那么```dp[i] = dp[i+1]```；如果我们取第i个元素，那么必然有```dp[i] = dp[i+skip+1] + val[i]```. 无论dp[i+skip+1]对应的是取还是不取第i+skip+1个元素，都不会冷冻到第i个元素的选取。最终dp[i]就是在这两种决策中取最大值，即```max(dp[i+1], dp[i+skip+1]+val[i])```. 最终的答案是dp[0].


#### 解法2
事实上本题存在传统的“填表法”DP，不过需要分别定义dp[i][0]和dp[i][1]表示第i个元素不取、取各自所能得到最大价值。

我们有状态转移方程：
```
dp[i][0] = max(dp[i-1][0], dp[i-1][1]);
dp[i][1] = max{dp[j][1]} + val[i]; 
```
其中第二项中的j是所有小于i的位置里、满足j的冷冻期不包括i、且dp[j][1]最大那个位置。我们如何不遍历全部、高效地找到那个j呢？我们提前把所有的index按照冷冻期结束（即j+skip[j]）的先后顺序排序。我们在从小到大遍历i的过程中，就可以顺序解锁那些j+skip[j]<i的位置j，然后滚动保留最大的dp[j][1]即可。这样，DP转移的过程就是o(n)的复杂度。

最终返回的答案是max{dp[n-1][0],dp[n-1][1]}。

#### 解法3：
类似地，我们也有传统的“刷表法”DP。同样定义dp[i][0]和dp[i][1]表示第i个元素不取、取各自所能得到最大价值。

在已知dp[i][0]和dp[i][1]的情况下，对于未来的状态，我们有状态转移方程：
```
dp[i+1][0] = max(dp[i+1][0], max(dp[i][0],dp[i][1]));
dp[j][1] = max(dp[j][1], dp[i][1] + val[j]);  for all j>i+skip[i]
```
第一项比较容易理解，第i+1个元素不取的话，dp[i+1]一定就完全取决于dp[i]了.

对于第二项，我们注意到，我们必须同时更新多个dp[j][1]的值。如何高效地实现这个操作呢？我们联想到差分数组的策略。第二项的意思是从j=i+skip[i]+1开始到结束，每一个j的dp[j][1]都至少被抬升到了dp[i][1]的大小。所以我们可以新建一个数组```base[i+skip[i]+1]```来表示从j=i+skip[i]+1开始到结束，所有的dp[j][1]都被统一抬升dp[i][1]。

我们在遍历i的过程中，需要滚动更新当前的抬升```diff = max(diff, base[i])```，然后更新```dp[i][1] = diff + questions[i][0]```。最后根据当前的dp[i][1]来更新未来的base[j]。

最终返回的答案是max{dp[n-1][0],dp[n-1][1]}。

$0
endsnippet

# ==> ./Dynamic_Programming/2140.Solving-Questions-With-Brainpower/2140.Solving-Questions-With-Brainpower_v1.cpp <==
snippet 2140.Solving-Questions-With-Brainpower "2140.Solving-Questions-With-Brainpower" b
using LL = long long;
class Solution {
public:
    long long mostPoints(vector<vector<int>>& questions) 
    {
        int n = questions.size();
        vector<LL>dp(n+1);
        for (int i=n-1; i>=0; i--)
        {
            int j = i+questions[i][1]+1;            
            dp[i] = max(dp[i+1], (j<n?dp[j]:0) + questions[i][0]);
        }
        return dp[0];
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/2140.Solving-Questions-With-Brainpower/2140.Solving-Questions-With-Brainpower_v2.cpp <==
snippet 2140.Solving-Questions-With-Brainpower "2140.Solving-Questions-With-Brainpower" b
using LL = long long;
class Solution {
public:
    long long mostPoints(vector<vector<int>>& questions) {
        int n = questions.size();
        vector<vector<LL>> dp(n, vector<LL>(2));        
        dp[0][1] = questions[0][0];

        vector<pair<int, int>>endTimes;
        for (int i=0; i<n; i++)
            endTimes.push_back({i+questions[i][1], i});
        sort(endTimes.begin(), endTimes.end());
        int p = 0;
        
        LL maxPre = 0;
        for (int i = 1; i < n; ++i)
        {
            while (p<n && endTimes[p].first < i)
            {                
                maxPre = max(maxPre, dp[endTimes[p].second][1]);
                p++;
            }

            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1]);
            dp[i][1] = maxPre + questions[i][0];
        }

        return max(dp[n - 1][0] , dp[n - 1][1]);
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/2140.Solving-Questions-With-Brainpower/2140.Solving-Questions-With-Brainpower_v3.cpp <==
snippet 2140.Solving-Questions-With-Brainpower "2140.Solving-Questions-With-Brainpower" b
using LL = long long;
class Solution {
public:
    long long mostPoints(vector<vector<int>>& questions) {
        int n = questions.size();
        vector<vector<LL>> dp(n, vector<LL>(2));        
        dp[0][1] = questions[0][0];

        vector<LL>base(n);
        LL diff = 0;
        
        LL maxPre = 0;
        for (int i = 0; i < n; ++i)
        {
            diff = max(diff, base[i]);
            dp[i][1] = diff + questions[i][0];

            int skip = questions[i][1];
            if (i+1<n)
                dp[i+1][0] = max(dp[i+1][0], max(dp[i][0], dp[i][1]));
            if (i+skip+1<n)
                base[i+skip+1] = max(base[i+skip+1], dp[i][1]);
        }

        return max(dp[n-1][0], dp[n-1][1]);
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/2143.Choose-Numbers-From-Two-Arrays-in-Range/Readme.md <==
snippet 2143.Choose-Numbers-From-Two-Arrays-in-Range "2143.Choose-Numbers-From-Two-Arrays-in-Range" b
### 2143.Choose-Numbers-From-Two-Arrays-in-Range

为了方便，我们将两个数组看成一个数组。我们定义```diff[i] = nums1[i]-nums2[i]```，那么对于第i个位置，如果选择num1的元素，可以认为是加上diff，如果选择nums2的元素，可以认为是减去diff。本题就是要找子区间个数，使得子区间的的元素之和是0。

因为目标0是多个元素累加起来的和，所以我们必然会需要考虑元素累加过程中出现的各种可能的“和”。所以，我们需要定义状态dp[i][sum]，表示以i为结尾、区间和是sum的子区间的个数。显然，因为对于元素i我们只有两种策略（加上diff或者减去diff），所以d[i][sum]必然依赖于i-1处的两个前趋状态，即```dp[i-1][sum-diff] + dp[i-1][sum+diff]```。

另外注意，符合要求的子区间也可能和i-1没有关系，直接从元素i开始（即只有一个元素）。所以我们需要补上：
```
dp[i][diff[i]] += 1;
dp[i][-diff[i]] += 1;
```
这样我们就可以计算出所有dp[i][sum]。最终答案就是累加所有的dp[i][0].

因为dp状态的第二个下标可能会是负数，所以我们需要统一抬升```offset=10000```. offset根据sum的最大值而定（即nums1或nums2的所有元素之和）。

$0
endsnippet

# ==> ./Dynamic_Programming/2143.Choose-Numbers-From-Two-Arrays-in-Range/2143.Choose-Numbers-From-Two-Arrays-in-Range.cpp <==
snippet 2143.Choose-Numbers-From-Two-Arrays-in-Range "2143.Choose-Numbers-From-Two-Arrays-in-Range" b
using LL = long long;
class Solution {
    LL dp[105][20005];
    LL offset = 10000;
    LL M = 1e9+7;
public:
    int countSubranges(vector<int>& nums1, vector<int>& nums2) 
    {
        int n = nums1.size();
        nums1.insert(nums1.begin(), 0);
        nums2.insert(nums2.begin(), 0);
        
        dp[1][0+offset] = 0;
        LL ret = 0;
        
        for (int i=1; i<=n; i++)        
        {
            dp[i][offset+nums1[i]] += 1;
            dp[i][offset-nums2[i]] += 1;
            
            for (int sum = -offset; sum <= offset; sum++)
            {
                if (inbound(sum-nums1[i]))
                {
                    dp[i][sum+offset] += dp[i-1][sum+offset-nums1[i]];
                    dp[i][sum+offset] %= M;
                }
                                    
                if (inbound(sum+nums2[i]))
                {
                    dp[i][sum+offset] += dp[i-1][sum+offset+nums2[i]];
                    dp[i][sum+offset] %= M;
                }                           
            }
                        
            ret += dp[i][0+offset];
            ret %= M;
        }
        
        return ret;
    }
    
    bool inbound(int x)
    {
        return x>=-offset && x<=offset;
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/2152.Minimum-Number-of-Lines-to-Cover-Points/Readme.md <==
snippet 2152.Minimum-Number-of-Lines-to-Cover-Points "2152.Minimum-Number-of-Lines-to-Cover-Points" b
### 2152.Minimum-Number-of-Lines-to-Cover-Points

从本题的数据规模n<=10来看，用bit mask暴力穷举是正解。我们用一个二进制数state来表示一组点的集合，dp[state]表示这些点最少能用多少条直线覆盖。

如果state的所有点都在一条直线上，那么必然是```dp[state]=1```. 否则的话，这个点集的最优解是需要两条或者更多的直线来覆盖，我们必然可以将这些直线和对应的点归并出两组。这意味着必然有一种方法可以将state分为A子集和B子集，使得```dp[state]=dp[A]+dp[B]```，所以我们只需要枚举state的子集subset，那么```dp[state] = min{dp[subste] + dp[state-subset]}```.

所以本题的解法是：从小到大遍历所有的状态state，对于每个状态dp[state]，考察它的子集subset和补集（注意dp[subset]必然已经是已知的）。dp[state]要么是1，要么就是两个子集状态之和（取最小值）。

$0
endsnippet

# ==> ./Dynamic_Programming/2152.Minimum-Number-of-Lines-to-Cover-Points/2152.Minimum-Number-of-Lines-to-Cover-Points.cpp <==
snippet 2152.Minimum-Number-of-Lines-to-Cover-Points "2152.Minimum-Number-of-Lines-to-Cover-Points" b
class Solution {
public:
    int minimumLines(vector<vector<int>>& points) 
    {
        int n = points.size();
        vector<int>dp(1<<n, INT_MAX/2);
        
        for (int state = 1; state < (1<<n); state++)
        {
            if (__builtin_popcount(state)<=2)
                dp[state] = 1;
            else if (formLine(points, state))
                dp[state] = 1;            
        }
        
        for (int state = 1; state < (1<<n); state++)
        {
            for (int subset=state; subset>0; subset=(subset-1)&state)
            {
                dp[state] = min(dp[state], dp[subset] + dp[state-subset]);               
            }            
        }
        
        return dp[(1<<n)-1];
    }
    
    bool formLine(vector<vector<int>>& points, int state)
    {
        vector<int>temp;
        for (int i=0; i<points.size(); i++)
        {
            if (state%2==1)
                temp.push_back(i);
            state/=2;
        }        
        for (int i=1; i<temp.size(); i++)
        {
            int a = temp[0];
            int b = temp[1];
            int c = temp[i];
            if ((points[c][1]-points[a][1])*(points[b][0]-points[a][0])!=(points[b][1]-points[a][1])*(points[c][0]-points[a][0]))
                return false;
        }
        return true;            
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/2172.Maximum-AND-Sum-of-Array/Readme.md <==
snippet 2172.Maximum-AND-Sum-of-Array "2172.Maximum-AND-Sum-of-Array" b
### 2172.Maximum-AND-Sum-of-Array

本题看上像二分图匹配问题。左边是一堆数字，右边是一对slots，要求匹配的边权之和最大。但是标准的二分图匹配要求每条边不能有公共边，本题则是允许最多两条边共享一个slot节点。

同以往一样，我们不用KM算法来解决带权最大二分图匹配，我们也不考虑最小费用最大流的做法，这里依然用状态压缩DP。

一般我们有两种方案：1. 遍历slot，用状态来表示nums。2. 遍历nums，用状态来表示slot。

对于第一种方法，我们用二进制数state来表示那些数字已经被配对，于是dp[i][state]表达的是：用完第i个slot、配对了state所表示的数字集时，所得的最大价值。所以核心代码大致会是：
```
 for (int i=0; i<slot.size(); i++)
    for (int state=0; state<(1<<nums.size()); state++)
      for (auto pickedNum: avaiable plans)
        dp[i][state] = dp[i-1][state-pickedNum] + (pickedNum & slot[i]);
```
其中上式里的available plans比较复杂。因为slot里面可以放0个或者1个或者2个数字，所以需要在state所代表的数字集合里面任意挑选0个、1个、2个数字的组合，这个组合的大小可能会有C(18,2)的级别。综上三层循环的总复杂度会是：```9*(2^18)*C(18,2)```，这是1e8数量级的数字，会TLE。

第二种方法，我们用三进制数state来表示所有slots的匹配状态（三进制数的每个bit表示该slot里面已经装了0个、1个或2个数字）。于是dp[i][state]表达的是：用完第i个数字、配对了state所表示的slots时，所得的最大价值。所以核心代码大致会是：
```
 for (int i=0; i<nums.size(); i++)
    for (int state=0; state<pow(3, numSlots); state++)
      for (auto pickedSlot: avaiable plans)
        dp[i][state] = dp[i-1][state-pickedSlot] + (nums[i] & pickedSlot);
```
其中上式里面的avaialbe plans是指，nums[i]对应了state里面的哪一个slot。也就是说，我们需要在state里面挑一个slot，它盛装的数字数目必须大于等于1，这样才能支持dp[i][state]的定义。这个availabe plans的复杂度就是o(numSlot)，把state所代表的每个slot都检查一遍就可以了。综上，三层循环的总复杂度是```18*(3^9)*(9)```，这是3e6数量级的数字，可以接受。

事实上，上述的方法还可以进一步优化，第一层循环是不必要的。我们如果固定了slots的state，那么必然知道此时所有slots里面总共有多少个数字，那么当前所考察的i其实也就知道了。这样时间复杂度就是```(3^9)*(9)```.

$0
endsnippet

# ==> ./Dynamic_Programming/2172.Maximum-AND-Sum-of-Array/2172.Maximum-AND-Sum-of-Array_v1.cpp <==
snippet 2172.Maximum-AND-Sum-of-Array "2172.Maximum-AND-Sum-of-Array" b
class Solution {    
public:
    int maximumANDSum(vector<int>& nums, int numSlots) 
    {
        int n = nums.size();
        nums.insert(nums.begin(), 0);
        int m = pow(3, numSlots);
        vector<vector<int>>dp(n+1, vector<int>(m, INT_MIN/2));
        dp[0][0] = 0;
        
        int ret = 0;
        for (int i=1; i<=n; i++)        
            for (int state = 0; state < m; state++)
            {
                for (int j=0; j<numSlots; j++)
                {
                    if (filled(state, j)>=1)                    
                        dp[i][state] = max(dp[i][state], dp[i-1][state - pow(3,j)] + (nums[i]&(j+1))); 
                }
                if (i==n)
                    ret = max(ret, dp[i][state]);
            }        
        
        return ret;
    }
    
    bool filled(int state, int k)
    {
        for (int i=0; i<k; i++)
            state/=3;
        return state%3;
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/2172.Maximum-AND-Sum-of-Array/2172.Maximum-AND-Sum-of-Array_v2.cpp <==
snippet 2172.Maximum-AND-Sum-of-Array "2172.Maximum-AND-Sum-of-Array" b
class Solution {    
public:
    int maximumANDSum(vector<int>& nums, int numSlots) 
    {
        int n = nums.size();
        nums.insert(nums.begin(), 0);
        int m = pow(3, numSlots);
        vector<vector<int>>dp(n+1, vector<int>(m, INT_MIN/2));
        dp[0][0] = 0;
                
        int ret = 0;
        
        for (int state = 1; state < m; state++)
        {
            int i = 0;
            int temp = state;
            while (temp>0)
            {
                i+=temp%3;
                temp/=3;
            }
            if (i>n) continue;
                        
            for (int j=0; j<numSlots; j++)
            {
                if (filled(state, j)>=1)                    
                {                    
                    dp[i][state] = max(dp[i][state], dp[i-1][state - pow(3,j)] + (nums[i]&(j+1)));                     
                }
                    
            }
            if (i==n)
                ret = max(ret, dp[i][state]);
        }        
        
        return ret;
    }
    
    bool filled(int state, int k)
    {
        for (int i=0; i<k; i++)
            state/=3;
        return state%3;
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/2184.Number-of-Ways-to-Build-Sturdy-Brick-Wall/Readme.md <==
snippet 2184.Number-of-Ways-to-Build-Sturdy-Brick-Wall "2184.Number-of-Ways-to-Build-Sturdy-Brick-Wall" b
### 2184.Number-of-Ways-to-Build-Sturdy-Brick-Wall

本题的突破口在于width<=10，这暗示我们可以用一个10bit的01二进制数来表示“长度为w的线段可以如何切割为若干段”。那么如何用一串01既来表示“用了哪些长度的砖”、又可以描述“这些砖是怎么排列的”呢？方法就是着眼于那些可能是切缝的位置。

例如长度为w，就有w-1个潜在的切缝位置（编号是0到w-2），我们用1表示这确实是个两块砖之间的缝，0则表示这个位置属于一块完整的砖无法切割。特别注意，我们需要虚拟地添加上左边缘的位置（想象成第-1个切缝位置）和右边缘的位置（想象成第w-1个切缝位置）。

比如w=6，那么内部有五个切缝位置，假设是10010，表示切缝位置0、3是砖与砖的交界处。另外加上左边缘-1和右边缘5，所以总共有四个交界位置：-1,0,3,5，这说明有三块长度分别是1、3、2的砖拼接起来。也就是说，任意两个1之间的index之差，表示了中间有多少块砖。

考虑到w很小，我们穷举所有对w的切割方案，看看切割出来的每一小段是否存在于bricks里面。都存在的话就是一个合法的切割（拼接）方案。

我们得到所有合法的切割方案之后（用bitmask的形式表示），就是常规的状态压缩DP。我们用dp[i][state]表示第i层用state这种拼接方式的话可以有多少种方案。显然```dp[i][state]+=dp[i-1][state1]```其中state1和state不能在同一个切缝位置上都是拼接点，也就是说必须满足```(state & state1) == 0```。这个思想和paint house非常相似，在那道题里，任何相邻的房子不能是同一种颜色。

最终答案是 sum{dp[height-1][state]} for all states

$0
endsnippet

# ==> ./Dynamic_Programming/2184.Number-of-Ways-to-Build-Sturdy-Brick-Wall/2184.Number-of-Ways-to-Build-Sturdy-Brick-Wall.cpp <==
snippet 2184.Number-of-Ways-to-Build-Sturdy-Brick-Wall "2184.Number-of-Ways-to-Build-Sturdy-Brick-Wall" b
class Solution {
public:
    int buildWall(int height, int width, vector<int>& bricks) 
    {    
        unordered_set<int>Set(bricks.begin(), bricks.end());
        vector<int>plans;
        int m = width-1;
        for (int state=0; state<(1<<m); state++)
        {
            vector<int>temp({-1});
            for (int i=0; i<m; i++)
            {
                if ((state>>i)&1)
                    temp.push_back(i);
            }
            temp.push_back(width-1);
            
            int flag = 1;
            for (int i=1; i<temp.size(); i++)
            {
                if (Set.find(temp[i]-temp[i-1])==Set.end())
                {
                    flag = 0;
                    break;
                }
            }
            if (flag) plans.push_back(state);
        }
                
        if (height==1) return plans.size();
                
        vector<vector<int>>dp(height, vector<int>(plans.size()));
        int M = 1e9+7;
        for (int j=0; j<plans.size(); j++)
            dp[0][j] = 1;
        
        int ret = 0;
        for (int i=1; i<height; i++)
            for (int j=0; j<plans.size(); j++)
            {
                for (int k=0; k<plans.size(); k++)
                {
                    if ((plans[j]&plans[k])==0)
                        dp[i][j] = (dp[i][j] + dp[i-1][k])%M;
                }
                if (i==height-1)
                    ret = (ret + dp[i][j])%M;
            }
        return ret;
        
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/2188.Minimum-Time-to-Finish-the-Race/Readme.md <==
snippet 2188.Minimum-Time-to-Finish-the-Race "2188.Minimum-Time-to-Finish-the-Race" b
### 2188.Minimum-Time-to-Finish-the-Race

整体思想显然是DP。令dp[i]表示跑i圈的最小代价，那么它取决于最后一次换胎的选择。假设最后一次换胎跑了j圈，那么就有```dp[i] = dp[i-j] + changTime + minTime[j]```，其中j表示minTime[j]是在所有轮胎类型中跑j圈最快的时间。所以求解DP的过程大致是o(numLaps^2) = 1e6 的复杂度，可以接受。

那么预处理minTime需要多少时间呢？在有m种轮胎，如果把所有的minTime[j], j=1,2,3,...numLaps都计算的话，我们需要花```o(m*numLaps)```的时间，那就是1e8数量级，必然TLE。该如何改进呢？

事实上我们根据跑一圈的公式```t = f*r^(x-1)```，在不换胎的条件下，当x很大时，跑一圈的时间会指数级地增长。显然，当不换胎多跑一圈的时间大于换胎本身的时间时，无论对于任何轮胎，继续跑下去都是不合算的。通过尝试发现，我们在最极端的条件下，即f=1，r=2时，当x是第20圈的时候，跑一圈所花的时间就有2^19=5e5已经大于了changeTime的上限。所以无论对于什么轮胎，一次性跑20圈都是不划算的。因此在dp的转移方程里，我们对于minTime的下标不会超过20圈。

所以本题的DP计算是```o(20*numLaps)```，此外我们提前需要预处理minTime[20]需要```o(20m)=2e6```的时间。

以上的操作还会有TLE。进一步改进的方法是减少轮胎的种类。显然如果轮胎A的f参数和r参数都比轮胎B的大，那么轮胎A完全就可以忽略。所以我们可以将所有轮胎按照r参数递增排列，顺次检查这些轮胎时，如果发现任何一个轮胎的f值大于等于前面的轮胎，那么该轮胎就可以忽略。这样我们就可以大幅度地减少轮胎的种类。

$0
endsnippet

# ==> ./Dynamic_Programming/2188.Minimum-Time-to-Finish-the-Race/2188.Minimum-Time-to-Finish-the-Race.cpp <==
snippet 2188.Minimum-Time-to-Finish-the-Race "2188.Minimum-Time-to-Finish-the-Race" b
using LL = long long;
class Solution {
    static bool cmp(vector<int>&a, vector<int>&b)
    {
        if (a[1]!=b[1]) 
            return a[1] < b[1];
        else
            return a[0] < b[0];
    }
public:
    int minimumFinishTime(vector<vector<int>>& tires, int changeTime, int numLaps) 
    {
        sort(tires.begin(), tires.end(), cmp);
        vector<vector<int>>newTires;
        for (int i=0; i<tires.size(); i++)
        {                        
            if (!newTires.empty() && newTires.back()[0] <= tires[i][0])
                continue;
            newTires.push_back(tires[i]);                
        }
        
        vector<double>minTime(min(20, numLaps+1), DBL_MAX);
        for (int x=1; x<minTime.size(); x++)
        {
            for (int i=0; i<newTires.size(); i++)
                minTime[x] = min(minTime[x],  cal(newTires[i],x));             
        }
                
        vector<double>dp(numLaps+1, DBL_MAX);
        dp[0] = 0;
        for (int i=1; i<=numLaps; i++)
            for (int j=i-1; i-j<20 && j>=0; j--)
            {
                dp[i] = min(dp[i], dp[j]+minTime[i-j] + (j==0?0:changeTime));
            }                
        
        return dp[numLaps];
    }
        
    double cal(vector<int>tire, int x)
    {
        double f= tire[0], r = tire[1];
        double ret = f*(pow(r, x)-1)/(r-1);        
        return ret;
        
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/2189.Number-of-Ways-to-Build-House-of-Cards/Readme.md <==
snippet 2189.Number-of-Ways-to-Build-House-of-Cards "2189.Number-of-Ways-to-Build-House-of-Cards" b
### 2189.Number-of-Ways-to-Build-House-of-Cards

本题的直观解读是要将总数n分成若干行之和，每行的牌数是递增的，并且每行的牌数必须是```2*k+(k-1)```的形式，其中k可以理解为三角形的个数。

我们换个角度来想，假设将行数编号1,2,3,4...就对应三角形的个数，那么每行对应的牌数是```2*k+(k-1)```. 我们的任务其实是将在这些行里面挑选出若干，使得其总数为n。我们可以预料，可供选择的行号不会很多，撑死最多也就是n行（事实上单独的第n行就需要共3n-1张的牌数了）。

我们令dp[i][j]表示前i行里面（挑选若干行）、并且所用牌的总数为j可以得到的方案数。对于第i行而言只有两种选择：1. 我们不选第i行，即不搭建3i-1这种模式，那么```dp[i][j] = dp[i-1][j]```. 2.我们选择第i行，那么第i行本身占用了3i-1张牌，那么意味着我们关注的就是前i-1行里我们选用j-(3i-1)张牌能搭建多少种合法的方案，所以```dp[i][j] = dp[i-1][j-(3i-1)]```.

于是本题的转移方程就是 ```dp[i][j] = dp[i-1][j] +  dp[i-1][j-(3i-1)]```。

初始条件是```dp[0][0] = 1```，这是所有状态的“种子”。

$0
endsnippet

# ==> ./Dynamic_Programming/2189.Number-of-Ways-to-Build-House-of-Cards/2189.Number-of-Ways-to-Build-House-of-Cards.cpp <==
snippet 2189.Number-of-Ways-to-Build-House-of-Cards "2189.Number-of-Ways-to-Build-House-of-Cards" b
class Solution {
public:
    int houseOfCards(int n) 
    {
        vector<vector<int>>dp(n+1, vector<int>(n+1,0));
        dp[0][0] = 1;
        for (int i=1; i<=n/2; i++)
            for (int j=0; j<=n; j++)
            {
                dp[i][j] = dp[i-1][j] + (j>=(3*i-1)?dp[i-1][j-(3*i-1)]:0);
            }
        
        return dp[n/2][n];        
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/2209.Minimum-White-Tiles-After-Covering-With-Carpets/Readme.md <==
snippet 2209.Minimum-White-Tiles-After-Covering-With-Carpets "2209.Minimum-White-Tiles-After-Covering-With-Carpets" b
### 2209.Minimum-White-Tiles-After-Covering-With-Carpets

令dp[i][j]表示前i个格子用j块地毯覆盖，留有的最小白色区域。显然我们分两种情况讨论。

1. 如果第i个格子我们不用第j块地毯，那么我们会关注前i-1个格子用j块地毯的覆盖情况，再加上第i个格子本身是否是白色。即```dp[i][j] = dp[i-1][j] + (s[i]=='1')```
2. 如果第i个格子我们用了第j块地毯，那么这块地毯覆盖了carpetLen的区域。为了尽量节约使用地毯，我们必然希望这块地毯的效用最大化，也就是说，我们必然会把前j-1块地毯用来覆盖前i-carpetLen个格子。故```dp[i][j] = dp[i-carpetLen][j-1]```. 

我们在以上两种方案中取最大值。

需要注意的是在第二种情况里，如果```i-carpetLen<=0```怎么办？容易判断，在没有任何格子的情况下，所谓“留有的白色区域”自然也是0。

$0
endsnippet

# ==> ./Dynamic_Programming/2209.Minimum-White-Tiles-After-Covering-With-Carpets/2209.Minimum-White-Tiles-After-Covering-With-Carpets.cpp <==
snippet 2209.Minimum-White-Tiles-After-Covering-With-Carpets "2209.Minimum-White-Tiles-After-Covering-With-Carpets" b
class Solution {    
    int dp[1001][1001];
public:
    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) 
    {
        int n = floor.size();
        floor = "#"+floor;        
        
        dp[0][0] = 0;                
        for (int i=1; i<=n; i++)
            for (int j=0; j<=numCarpets; j++)
            {        
                dp[i][j] = INT_MAX/2;
                dp[i][j] = min(dp[i][j], dp[i-1][j] + (floor[i]=='1'));                               
                if (j>=1)
                    dp[i][j] = min(dp[i][j], i>=carpetLen ? dp[i-carpetLen][j-1]:0);
            }
        
        return dp[n][numCarpets];
        
    }
};

$0
endsnippet

# ==> ./Dynamic_Programming/2218.Maximum-Value-of-K-Coins-From-Piles/Readme.md <==
snippet 2218.Maximum-Value-of-K-Coins-From-Piles "2218.Maximum-Value-of-K-Coins-From-Piles" b
### 2218.Maximum-Value-of-K-Coins-From-Piles

本题的动态规划算法本身不难想到，关键在于时间复杂度的分析。

因为我们对所有的pile依次处理，所以需要一个下标来表示pile的index。另外因为所能摘取coins总数目有限制，所以我们需要第二个下标来表示当前摘取的coins数目。即dp[i][j]表示截止到第i个pile，总共摘取j个coins的最大价值。

状态转移方程的着眼点自然就是第i根pile。我们能控制的就是该pile取几个coins。所以我们需要遍历对该pile的行动方案（即取0个，取1个，取2个，... ）

所以本题的状态转移方程就是：
```
dp[i][j] = max{dp[i-1][j-t] + pilesVal[i][t] }  where t= 0,1,2,...,len(piles[i])
```
其中pilesVal[i][t]就是第i根pile取t个硬币的收益，这个是可以提前计算好的。

显然，这里似乎需要三层循环：
```cpp
for (int i=0; i<n; i++)
  for (int j=0; j<=k; j++)
    for (int t=0; t<=min(j, piles[i].size()); t++)
      dp[i][j] = max(dp[i][j], dp[i-1][j-t]+piles[i][t]);
```
那么总的时间复杂度是多少呢？看上去是```o(N*K*K)```，但是题目所给的数据量显然不支持这么大。这是怎么回事呢？

事实上第一层循环和第三层循环可以合并起来分析。我们对于每根pile（即变量i），都遍历它的硬币个数（即变量t）。将i和t全部遍历一遍，其实就是将所有pile的所有硬币遍历一遍。而题目中给出了所有pile的硬币总数不超过2000，所以本题实际的时间复杂度是```o(K*2000)```.

$0
endsnippet

# ==> ./Dynamic_Programming/2218.Maximum-Value-of-K-Coins-From-Piles/2218.Maximum-Value-of-K-Coins-From-Piles.cpp <==
snippet 2218.Maximum-Value-of-K-Coins-From-Piles "2218.Maximum-Value-of-K-Coins-From-Piles" b
class Solution {
    int dp[1002][2002];
public:
    int maxValueOfCoins(vector<vector<int>>& piles, int k) 
    {
        int n = piles.size();
        vector<vector<int>>presum(n);
        for (int i=0; i<n; i++)
        {
            int sum = 0;
            presum[i].push_back(sum);
            for (int j=0; j<piles[i].size(); j++)
            {
                sum += piles[i][j];
                presum[i].push_back(sum);
            }
        }

        int ret = 0;        
        for (int i=0; i<n; i++)
            for (int j=0; j<=k; j++)
            {                
                for (int t = 0; t<=min(j, (int)piles[i].size()); t++)
                    dp[i][j] = max(dp[i][j], (i==0?0:dp[i-1][j-t]) + presum[i][t]);                
                                    
                if (i==n-1)
                    ret = max(ret, dp[i][j]);
            }                
        
        return ret;
    }
};

$0
endsnippet
