::::::::::::::
Greedy/0041.First-Missing-Positive/041.First-Missing-Positive.cpp
::::::::::::::
class Solution {
public:
    int firstMissingPositive(vector<int>& nums) 
    {
        nums.insert(nums.begin(),0);
        for (int i=0; i<nums.size(); i++)
        {
            while (nums[i]!=i && nums[i]<nums.size() && nums[i]!=nums[nums[i]])
                swap(nums[i], nums[nums[i]]);
        }
        for (int i=1; i<nums.size(); i++)
            if (nums[i]!=i) return i;     
        
        return nums.size();
    }
};
::::::::::::::
Greedy/0041.First-Missing-Positive/Readme.md
::::::::::::::
### 041.First-Missing-Positive

首先，将nums数组之前添加一个零元素。于是本题的一个思路是：如果尝试把正整数1~N尽可能地按照顺序放入nums[1]~nums[N]后，那么从头到尾再遍历一遍nums，找到的第一个nums[i]!=i的数，就是所求的结果。 

那么如何尝试one pass就把正整数1~N尽可能地按照顺序放入nums[1]~nums[N]呢？这就是经典的array indexing的算法。遍历所有元素的时候，发现如果nums[i]!=i时，说明当前的nums[i]这个数没有被放置在合适的位置，根据对应的规则，它应该被放在nums[nums[i]]这个位置。

于是我们持续交换nums[i]和nums[nums[i]]。每一次交换的结果是：把nums[i]送到了它应该在的位置；同时i位置的元素又有了新的值，可以再次进行交换。如果这样的步骤持续到 nums[i]==i（说明第i个元素的位置已经得到满足了）或者nums[nums[i]]==nums[i]（说明第nums[i]个元素的位置也已经得到了满足），就不需要交换了。

当把所有的i都遍历一遍之后，就完成了“力所能及”的排序，意思就是nums里面所有处于1\~N之间的数，都已经在它规定的位置上了。如前所述，此时从头到尾再遍历一遍nums，找到的第一个nums[i]!=i的数，就是原先nums里面1~N之间所缺失的数。 

和本题非常相似的还有:
```
287.Find the Duplicate Number
442.Find-All-Duplicates-in-an-Array 
448.Find-All-Numbers-Disappeared-in-an-Array 
645.Set Mismatch，
```
也用到了array indexing.


[Leetcode Link](https://leetcode.com/problems/first-missing-positive)::::::::::::::
Greedy/0045.Jump-Game-II/045.Jump-Game-II.cpp
::::::::::::::
class Solution {
public:
    int jump(vector<int>& nums) 
    {
        int start = 0, end = 0;
        int step = 0;
        if (nums.size()==1) return 0;

        while (end >= start)
        {
            int start_old = start;
            int end_old = end;            
            for (int i=start_old; i<=end_old; i++)            
            {
                end = max(end, i+nums[i]);
                if (end >= nums.size()-1)
                    return step+1;
            }
            step++;
            start = end_old+1;
        }
        return 0;
    }
};
::::::::::::::
Greedy/0045.Jump-Game-II/Readme.md
::::::::::::::
### 45.Jump-Game-II

求最少步数到达目的地的算法，最常见的就是BFS。本题可以仿照其思想。

第0步所能到达的点就是0. 第一步所能到的点的右边界就是0+nums[0]，也就是说第一步跨越的范围就是[1, 0+nums[0]。那么第二步所能到达的范围是什么呢？最小的位置，应该是第一步所能达到的最远点的下一个位置；最大的位置，应该是第一步所能达到的所有的点所共同更新的最远边界。

所以我们可以类似BFS的层级遍历，每走一步，弹出旧的元素区间[start,end]，然后装入新的元素区间[start_new, end_new]。
```
start_new = end+1; 
end_new = max{i+nums[i]} for i=[start,end]
```
每一步只要start<=end，就可以认为队列里还有元素，BFS就能继续。直至end_new到达最末的位置，或者start>end。

[Leetcode Link](https://leetcode.com/problems/jump-game-ii)
::::::::::::::
Greedy/0055.Jump-Game/055.Jump-Game.cpp
::::::::::::::
class Solution {
public:
    bool canJump(vector<int>& nums) {
        
        int far = 0; 
        for(int i = 0; i<nums.size()-1; i++)
        {
            if (far < i) return false;
            far = max(far,i+nums[i]);            
        }
        
        return far>=nums.size()-1;
    }
};
::::::::::::::
Greedy/0055.Jump-Game/Readme.md
::::::::::::::
### 055.Jump-Game

比较简单的贪心法。我们从做往右每遍历一个元素，都可以动态地更新未来的右边界。直到我们遍历到右边界位置无法前进的时候，仍然没有走到数组的最后一个位置，就返回false。
::::::::::::::
Greedy/0134.Gas-Station/134.Gas-Station.cpp
::::::::::::::
class Solution {
public:
    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) 
    {
        int sum = 0;
        for (int i=0; i<gas.size(); i++)
            sum+= gas[i]-cost[i];
        if (sum<0) return -1;
        
        sum = 0;
        int result=0;
        for (int i=0; i<gas.size(); i++)
        {
            sum+= gas[i]-cost[i];
            if (sum<0)
            {
                sum = 0;
                result = i+1;
            }                
        }
        return result;
    }
};
::::::::::::::
Greedy/0134.Gas-Station/Readme.md
::::::::::::::
### 134.Gas-Station

此题和 135.Candy 等都是LC比较经典的贪心法的题目，没有固定的套路可以用在其他题目上，但是这两题各自经典的解法值得深刻地记住。

这里，先考虑是否能够成功绕行一圈的问题。这个比较好理解，将所有的gas之和减去所有的cost之和，如果是负数，那么就说明无法绕行成功。

那么可以绕行成功，那么该如何选择起点呢？这里有个先行的结论需要先理解一下：如果从A点出发，走到B点就走不下去了，那么从A点到B点之间的任意一点出发，都不可能走过B点（甚至可能在B点之前就走不下去）。这个还是比较好理解的。因为假设能从A点走到B点，说明在走到A+1这个点的时候，肯定是有一部分A点的汽油还富余着的。那么说明如果直接从A+1点作为起点出发，肯定相比于从A点作为起点出发，资源更为紧缺，肯定更不可能超越B点。

所以我们从0点开始出发，假设到了B点走不下去了，那么说明从0点到B点都不可能是作为起点。那么起点从哪里开始呢？我们可以从B+1点作为起点开始尝试。如果从B+1点作为起点走到C点就走不下去了，说明B+1点到C点也都不可能作为起点。所以我们可以从C+1点开始尝试...如此下来，我们只要转一圈，就能最终确定从哪里作为起点可以到达0点，即成功环绕一周。


[Leetcode Link](https://leetcode.com/problems/gas-station)::::::::::::::
Greedy/0135.Candy/135.Candy.cpp
::::::::::::::
class Solution {
public:
    int candy(vector<int>& ratings) 
    {
        int n = ratings.size();
        vector<int>rets(n, 1);
        for (int i=1; i<n; i++)
        {
            if (ratings[i]>ratings[i-1])
                rets[i] = max(rets[i], rets[i-1]+1);
        }
        for (int i=n-2; i>=0; i--)
        {
            if (ratings[i]>ratings[i+1])
                rets[i] = max(rets[i], rets[i+1]+1);
        }
        int sum = accumulate(rets.begin(), rets.end(), 0);
        return sum;
    }
};
::::::::::::::
Greedy/0135.Candy/Readme.md
::::::::::::::
### 135.Candy

这是一道经典的贪心法。

我们令f[0]=1，然后从左往右扫一遍，保证f[i]与f[i-1]比较时符合要求，即```f[i]=max(1, f[i-1]+1 if rating[i]>rating[i-1])```. 这个操作更新了f[i]的下限，是f[i]合法的一个必要条件。言下之意就是说，f[i]不保证是一个合法的分配，但f[i]不能更小了。

然后从右往左扫一遍，保证f[i]与f[i+1]比较时符合要求，即```f[i]=max(f[i], f[i+1]+1 if rating[i]>rating[i+1])```. 这个操作同样进一步更新了f[i]的下限，即f[i]不能更小了。

以上两步操作都是必要条件，找到了f[i]的一个下限。但是这个下限本身是否就是符合要求的方案呢？事实上就是如此。上面两轮two pass保证了每个小朋友与相邻两个人做比较时都是公平的。换句话说，任意两个相邻小朋友之间的比较和分配都是公平的。所以此时f[i]的分布同时也是一个充分解。

贴着下限的充分解，就是题目要求的最优解（最少分发总数）。

[Leetcode Link](https://leetcode.com/problems/candy)
::::::::::::::
Greedy/0164.Maximum-Gap/164.Maximum Gap.cpp
::::::::::::::
class Solution {
public:
    int maximumGap(vector<int>& nums) 
    {
        int N=nums.size();
        if (N<2) return 0;
        
        int MIN=INT_MAX;
        int MAX=INT_MIN;
        for (int i=0; i<nums.size(); i++)
        {
            MIN=min(MIN,nums[i]);
            MAX=max(MAX,nums[i]);
        }
        
        int bucket_size = max(1,(MAX-MIN)/(N-1));
        int bucket_nums = (MAX-MIN)/bucket_size+1;
        vector<int>bucket_min(bucket_nums,INT_MAX);
        vector<int>bucket_max(bucket_nums,INT_MIN);
        
        unordered_set<int>Set;
        for (int i=0; i<N; i++)
        {
            int idx=(nums[i]-MIN)/bucket_size;
            bucket_min[idx]=min(nums[i],bucket_min[idx]);
            bucket_max[idx]=max(nums[i],bucket_max[idx]);
            Set.insert(idx);
            //cout<<idx<<" "<<bucket_min[idx]<<" "<<bucket_max[idx]<<endl;
        }
        
        int result=INT_MIN;
        int pre=0;
        for (int i=0; i<bucket_nums; i++)
        {
            if (Set.count(i)==0) continue;
            result=max(result,bucket_min[i]-bucket_max[pre]);
            pre = i;
        }
        
        return result;        
    }
};
::::::::::::::
Greedy/0164.Maximum-Gap/Readme.md
::::::::::::::
### 164.Maximum-Gap

假设有N个元素A到B。

那么可以推算，相邻元素的maxumum gap不会小于(B - A) / (N - 1)，否则无法达到B-A的跨越。

所以令bucket（桶）的大小 bucket_size = (B - A) / (N - 1)，则最多会有 bucket_nums = (B - A) / bucket_size + 1个桶。

对于数组中的任意整数nums[i]，很容易通过算式 idx = (nums[i] - A) / bucket_nums 找出其桶的位置，然后维护每一个桶的最大值和最小值。

由于前面提到，maximum gap不会小于bucket_size，而同一个桶里的元素的差值最多是bucket_size-1，因此最终答案所对应的两个数不会来自同一个桶中。

对于每一个非空的桶p，找出下一个非空的桶q，则q.min - p.max可能就是备选答案。返回所有这些可能值中的最大值。


[Leetcode Link](https://leetcode.com/problems/maximum-gap)
::::::::::::::
Greedy/0179.Largest-Number/179.Largest-Number.cpp
::::::::::::::
class Solution {
    static bool cmp(string&a, string&b)
    {
        return (a+b)>(b+a);
    }
public:
    string largestNumber(vector<int>& nums) 
    {
        vector<string>strs;
        for (int i=0; i<nums.size(); i++)
            strs.push_back(to_string(nums[i]));

        sort(strs.begin(), strs.end(), cmp);

        string result;
        for (int i=0; i<strs.size(); i++)
            result+=strs[i];

        int i=0;
        while (result[i]=='0') i++;
        if (i==result.size())
            return "0";
        else
            return result.substr(i);
            
        return result;
    }
};
::::::::::::::
Greedy/0179.Largest-Number/Readme.md
::::::::::::::
### 179.Largest-Number

本题的本质是一个非常有用的知识点：给你一个字符串数组，如何排序拼接这些字符串实现字典序最大？方法是设计一个巧妙的排序函数：
```
static bool cmp(string a, string b)
{
    string c=a+b;
    string d=b+a;
    return stoll(c)>stoll(d);
}

sort(Nums.begin(),Nums.end(),cmp);
```
将以此排序的字符串拼接起来，就是字典序最大的！

证明：

1. 传递性      
我们试图证明如果s3>s2，且s2>s1，那么就一定共有s3>s1. 因为只有具备传递性的大小比较，才能将所有的字符串的唯一排序。

我们令s3、s2、s1的长度对应的10的幂分别是n3、n2、n1（比如说1000,100,10），那么就有
```
s3 > s2 => s3s2 > s2s3 => s3*n2+s2 > s2*n3+s3 => s3(n2-1) > s2(n3-1)
s2 > s1 => s2s1 > s1s2 => s2*n1+s1 > s1*n2+s2 => s2(n1-1) > s1(n2-1)
```
因为所有的都是非负数，所以有
```
s3s2(n2-1)(n1-1) > s2s1(n3-1)(n2-1)
```
如果s2!=0，那么得到```s3(n1-1)>s1(n3-1) => s3n1+s1 > s1n3+s3```，即 s3>s1        
如果s2==0，那么s1==0，必然有 s3>s1        

2. 算法的正确性       
对于任意一个乱序的字符串数组，我们都可以通过交换一对相邻的逆序对来实现“冒泡”排序。比如
```
s3s1s2s4
s3s1s4s2
s3s4s1s2
s4s3s1s2
s4s3s2s1
```
在每一步中，只有一对相邻的字符串做了交换，每次交换的过程中都是将较大的si移动到较小的sj的前面，即由```...sjsi....```变成了```...sisj....```。显然我们发现这一步变化是将整体的字符串的字典序变大的。于是我们推断出每一步变化都是将这个字符串的字典序变大。也就是说，任意一个乱序拼接的字符串，都不如按照排序函数得到顺序拼接的字符串大。


::::::::::::::
Greedy/0229.Majority-Element-II/229.Majority-Element-II.cpp
::::::::::::::
class Solution {
public:
    vector<int> majorityElement(vector<int>& nums) 
    {
        int x1,x2;
        int count1=0,count2=0;
        
        for (int i=0; i<nums.size(); i++)
        {
            if (count1>0 && nums[i]==x1)
            {
                count1++;
            }
            else if (count2>0 && nums[i]==x2)
            {
                count2++;
            }
            else if (count1==0)
            {
                x1=nums[i];
                count1=1;
            }
            else if (count2==0)
            {
                x2=nums[i];
                count2=1;
            }
            else if (nums[i]!=x1 && nums[i]!=x2)
            {
                count1--;
                count2--;
            }            
        }
                
        vector<int>results;
        count1=0;
        count2=0;
        for (int i=0; i<nums.size(); i++)
        {
            if (nums[i]==x1) count1++;
            if (nums[i]==x2) count2++;
        }  
        if (count1>nums.size()/3) results.push_back(x1);
        if (x1!=x2 && count2>nums.size()/3) results.push_back(x2);
        
        return results;
    }
};
::::::::::::::
Greedy/0229.Majority-Element-II/Readme.md
::::::::::::::
### 229.Majority-Element-II

本题的解法非常巧妙，令人印象深刻。第一次不会做没有关系，但第二次遇到就应该能牢牢记住。

解法的基本思想就是：如果同时消去数组中互不相同的三个数，那么在剩下的数组中，超过1/3的那些数仍然是超过1/3的。所以我们只要不停找到三个互不相同的数并做消去，剩下的就是超过1/3的那些数（最多两个）。

所以我们在遍历nums数组的过程中，设置两个容器：如果有对应是相同元素的容器，那么就放进那个容器里；如果容器有空的，那么新进来的数就放进容器里；如果两个容器都非空，并且这三个数互不相同，那么就把这三个都消去。

注意，遍历完之后，最后剩下的两个容器里有可能都是答案，需要单独验证。

显然，本题可以扩展到定义大于 N/4, N/5 ... 的majority element。只要设置更多的容器即可。


[Leetcode Link](https://leetcode.com/problems/majority-element-ii)::::::::::::::
Greedy/0268.Missing-Number/268.Missing-Number_v1.cpp
::::::::::::::
class Solution {
public:
    int missingNumber(vector<int>& nums) 
    {
        int n = nums.size();
        nums.push_back(n+1);
        for (int i=0; i<=n; i++)
        {
            while (nums[i]!=i && nums[i]<=n && nums[i]!=nums[nums[i]])
                swap(nums[i], nums[nums[i]]);
        }
        for (int i=0; i<=n; i++)
            if (nums[i]!=i)
                return i;
        return 0;
    }
};
::::::::::::::
Greedy/0268.Missing-Number/268.Missing-Number_v2.cpp
::::::::::::::
class Solution {
public:
    int missingNumber(vector<int>& nums) 
    {
        int k=0;
        for (int i=0; i<=nums.size(); i++)
            k = k^i;
        for (int i=0; i<nums.size(); i++)
            k = k^nums[i];
        return k;
    }
};
::::::::::::::
Greedy/0268.Missing-Number/Readme.md
::::::::::::::
### 268.Missing-Number

#### 解法1：
对于凡是与“从0到N”数字相关的题目，indexing sort（或者叫cyclic sort？）总是一个值得尝试的角度。我们试图将0~N这些数字依次填充到nums的第0\~N个位置。移动的方法就是逐个考察每个index，如果第i个位置的数字不是nums[i]，那么我们就交换nums[i]和nums[nums[i]]：目的是把nums[i]直接送到它应该所在的地方（也就是index是nums[i]的位置）；同时，如果交换来的nums[nums[i]]依然不是我们想要的数字i，那么我们就重复这个swap的操作，直至：
1. 当前的第i个位置放的就是数字i；or
2. nums[i]和nums[nums[i]]相等，也就是说swap(nums[i], nums[nums[i]])没有任何效果；or
3. nums[nums[i]]越界了，也就是nums[i]不是一个合法的index

按照以上规则处理完所有的index之后，我们就已经竭尽全力地把所有数字和索引相match。此时再扫一遍nums数组，唯一的一处nums[i]!=i的地方，就是说明数字i是missing的。

#### 解法2：
有一个更优雅的做法。nums[i]包含了0\~N的所有数（除了一个missing number，假设是x）。我们将其亦或起来。同时将这个结果再与0\~N都亦或一遍。这样，除了x，其他的数字都被xor了两遍而被消除。剩下的结果就是x。
::::::::::::::
Greedy/0300.Longest-Increasing-Subsequence/300.Longest-Increasing-Subsequence_v1.cpp
::::::::::::::
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) 
    {
        int n = nums.size();
        vector<int>dp(n,1);
        for (int i=0; i<n; i++)
        {
            for (int j=0; j<i; j++)
            {
                if (nums[j]<nums[i])
                    dp[i] = max(dp[i], dp[j]+1);
            }
        }
        
        int ret = 0;
        for (int i=0; i<n; i++)
            ret = max(ret, dp[i]);
        
        return ret;

    }
};
::::::::::::::
Greedy/0300.Longest-Increasing-Subsequence/300.Longest-Increasing-Subsequence_v2.cpp
::::::::::::::
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) 
    {
        int n = nums.size();              
        vector<int>q(n, INT_MAX);
        for (int i=0; i<n; i++)
        {
            auto iter = lower_bound(q.begin(),q.end(),nums[i]);
            *iter = nums[i];
        }
        for (int i = n - 1; i >= 0; i--)
        {
            if (q[i] != INT_MAX)
                return i + 1;  
        }
        return 0;    
    }
};
::::::::::::::
Greedy/0300.Longest-Increasing-Subsequence/Readme.md
::::::::::::::
### 300.Longest-Increasing-Subsequence

#### 解法1：DP
这是第II类基本型的动态规划。我们考虑以nums[i]为结尾的LIS的第二大元素是什么？于是我们在i之前的所有index里找一个最好的j：如果nums[j]<nums[i]，那么以j为结尾的LIS就可以被收编进以i为结尾的LIS。显然，最好的j就是dp[j]最大的那个。

DP的时间复杂度是o(N^2)

#### 解法2：Greedy
贪心算法中的经典题：求最长子序列。时间复杂度可以是o(NlogN)

遍历所有元素，维护一个递增的数组q：当q为空，或者新元素val大于q.back()时加入q尾；否则，寻找q中第一个适合val插入的位置（原q序列里第一个大于等于val的位置），替换成val。 这么做的目的是：虽然LIS的长度并没有改变，但是使得当前q里面的LIS“变矮了”，更有利于后续元素加入进来构建更长的LIS。

举个例子：1 3 10 4 6. 考虑前三个元素后的q是[1 3 10]，但是考虑第四个元素后，我们将10替换成了4. 这样的好处是，第五个元素5可以直接append到这个q末尾从而时LIS再增长1.

如此遍历结束之后，q.size()就是最长子序列的长度。

对于C++，用lower_bound(q.begin(),q.end(),val)返回的就是第一个大于或等于val的元素的迭代器（或者说是地址）。


[Leetcode Link](https://leetcode.com/problems/longest-increasing-subsequence)
::::::::::::::
Greedy/0330.Patching-Array/330.Patching-Array.cpp
::::::::::::::
class Solution {
public:
    int minPatches(vector<int>& nums, int n) 
    {
        int count=0;
        long miss=1;
        int i=0;
        
        while (miss<=n)
        {
            if (i>=nums.size() || miss<nums[i])
            {
                count++;
                miss+=miss;
            }
            else
            {
                miss+=nums[i];
                i++;
            }
        }
        
        return count;
    }
};
::::::::::::::
Greedy/0330.Patching-Array/Readme.md
::::::::::::::
### 330.Patching-Array

假设miss是当前无法通过nums[0]~nums[i-1]这i个数通过题述的加和规则得到的、最小的那个整数，那么我们考虑下一个nums[i]会带来什么影响？

如果nums[i]>miss，说明它的加入对于我们试图得到miss没有任何帮助，因为nums[i]太大了；并且之后的nums元素更不会有帮助，只会更大。所以miss只能是我们必须人为补充的一个数，即我们手工补上miss。这时下一个无法得到的整数是什么呢？那就是miss\*2.因为miss加入前，1~miss-1我们都可以得到，所以miss加入后最大能得到2\*miss-1.

如果nums[i]<=miss，说明它的加入可以将miss提升至miss+nums[i].因为nums[i]加入前，1~miss-1我们都可以得到，所以miss加入后最大能得到miss-1+nums[i].

如此循环重复上述的过程，不断提升miss，直至miss>n. 注意这个过程中nums可以提前用完。

另外，值得注意的是，miss的初始值是1，而不是0. 因为没有任何nums提供时，我们首先试图要填补的就是1.


[Leetcode Link](https://leetcode.com/problems/patching-array)::::::::::::::
Greedy/0334.Increasing-Triplet-Subsequence/334.Increasing-Triplet-Subsequence_v1.cpp
::::::::::::::
class Solution {
public:
    bool increasingTriplet(vector<int>& nums) 
    {
        int N = nums.size();
        if (N==0) return false;
        
        vector<int>LeftMin(N,0);
        LeftMin[0] = INT_MAX;
        for (int i=1; i<N; i++)
            LeftMin[i] = min(LeftMin[i-1],nums[i-1]);
        
        vector<int>RightMax(N,0);
        RightMax[N-1] = INT_MIN;
        for (int i=N-2; i>=0; i--)
            RightMax[i] = max(RightMax[i+1],nums[i+1]);
        
        for (int i=1; i<N-1; i++)
        {
            if (LeftMin[i]<nums[i] && RightMax[i]>nums[i])
                return true;
        }
        return false;
        
    }
};
::::::::::::::
Greedy/0334.Increasing-Triplet-Subsequence/334.Increasing-Triplet-Subsequence_v2.cpp
::::::::::::::
class Solution {
public:
    bool increasingTriplet(vector<int>& nums) 
    {
        vector<int>q;
        for (auto x: nums)
        {
            if (q.empty() || q.back()<x)
                q.push_back(x);
            else
            {
                auto iter = lower_bound(q.begin(), q.end(), x);
                *iter = x;
            }
            if (q.size()==3)
                return true;
        }
        return false;
    }
};
::::::::::::::
Greedy/0334.Increasing-Triplet-Subsequence/Readme.md
::::::::::::::
### 334.Increasing-Triplet-Subsequence

#### 解法1：
从左往右，从右往左，各扫一遍数组，计算每个元素的LeftMin和RightMax。那么只要LeftMin[i]<nums[i]<RightMax[i]即可找到一对triplet

这样的话，时间是o(3N),空间是o(2N)

#### 解法2：
非常巧妙的思维，本题即是在这个数组里找到长度为3的increasing subsequence即可！

用一个数组来记录当前的递增序列，长度达到3即可停下来。时间最差是nlog(3)，空间是o(3)。


[Leetcode Link](https://leetcode.com/problems/increasing-triplet-subsequence)::::::::::::::
Greedy/0354.Russian-Doll-Envelopes/354.Russian-Doll-Envelopes_v1.cpp
::::::::::::::
class Solution {
public:
    int maxEnvelopes(vector<vector<int>>& envelopes) 
    {
        int n = envelopes.size();
        sort(envelopes.begin(), envelopes.end());
        vector<int>dp(n,0);
        for (int i=0; i<n; i++)
        {
            dp[i] = 1;
            for (int j=0; j<i; j++)
            {
                if (envelopes[j][0]<envelopes[i][0] && envelopes[j][1]<envelopes[i][1])
                    dp[i] = max(dp[i], dp[j]+1);
            }
        }
        
        int ret = 0;
        for (int i=0; i<n; i++)
            ret = max(ret, dp[i]);
        return ret;
    }
};
::::::::::::::
Greedy/0354.Russian-Doll-Envelopes/354.Russian-Doll-Envelopes_v2.cpp
::::::::::::::
class Solution {
    static bool cmp(vector<int>&a, vector<int>&b)
    {
        if (a[0]==b[0])
            return a[1]>b[1];
        else
            return a[0]<b[0];
    }
public:
    int maxEnvelopes(vector<vector<int>>& envelopes) 
    {
        sort(envelopes.begin(), envelopes.end(), cmp);
        vector<int>q;
        for (auto x: envelopes)
        {
            if (q.empty() || x[1]>q.back())
                q.push_back(x[1]);
            else
            {
                auto iter = lower_bound(q.begin(), q.end(), x[1]);
                *iter = x[1];
            }
        }
        return q.size();
    }
};
::::::::::::::
Greedy/0354.Russian-Doll-Envelopes/Readme.md
::::::::::::::
### 354. Russian-Doll-Envelopes

#### 解法1：
我们将所有的信封按照长度从小到大排序之后，符合要求的信封嵌套序列一定是这个排序数组的一个subsequence（否则无法满足长度的递增要求）。

我们可以用N^2的DP方法，在这个数组中找到宽度的最长递增子序列(LIS)。参考```300. Longest Increasing Subsequence```. 注意对于第i个元素，想寻找它在LIS中的前一个元素j，必须同时满足两个条件：
```width[j]<width[i] && length[j]<length[i]```。否则会将长度相等、宽度不等的两个信封选入同一个LIS中。

#### 解法2：
本题有一个技巧可以在求LIS的过程中不用再考虑长度的制约。那就是排序的时候，将长度相同的信封按照宽度降序排列。这样的好处是，相同长度的信封，不可能在宽度上是递增的。这样求宽度的LIS时，不可能选到两个长度相同的信封。于是，单纯求解宽度数组的LIS序列，就可以用o(NlogN)的贪心解法了。参考```300. Longest Increasing Subsequence```. 

[Leetcode Link](https://leetcode.com/problems/russian-doll-envelopes)
::::::::::::::
Greedy/0386.Lexicographical-Numbers/386.Lexicographical-Numbers.cpp
::::::::::::::
class Solution {
public:
    vector<int> lexicalOrder(int n) 
    {
        int current=1;
        vector<int>results(n);
        
        for (int i=0; i<n; i++)
        {
            results[i]=current;
            
            if (current*10<=n)
                current=current*10;
            else
            {
                if (current+1>n) 
                    current=current/10;
                current++;
                while (current % 10==0)
                    current/=10;
            }
        }
        return results;
    }
};
::::::::::::::
Greedy/0386.Lexicographical-Numbers/Readme.md
::::::::::::::
### 386.Lexicographical-Numbers

研究序列[1,10,11,12,13,2,3,4,5,6,7,8,9]，找出字典序的规律。

规律1：不考虑上限，元素1后面跟什么元素？10, 100 … 也就是不断乘以10。

规律2：如果99是上限，那么10后面的元素不能是100了，该怎么办？答案是11，也就是加1，这样个位上的数变大了。如果加1导致进位的话，虽然个位数变0，但十位上的数会变大，总之肯定字典序往后移。但此时得到的并不是下一个的目标，因为把其末尾的0去掉会得到字典序相对更前的数。砍掉0之后就可以重复规律1的操作了。

规律3：如果上限是19，那么19后面的元素就不能是20了，该怎么办？答案是将19除以10，然后再重复规律2（也就是加1），也就是得到2，之后又可以重复规律1了。


[Leetcode Link](https://leetcode.com/problems/lexicographical-numbers)::::::::::::::
Greedy/0406.Queue-Reconstruction-by-Height/406.Queue-Reconstruction-by-Height.cpp
::::::::::::::
class Solution {
public:
    static bool cmp(pair<int,int>a,  pair<int,int>b)
    {
        if (a.first==b.first)
            return a.second<b.second;
        else
            return a.first>b.first;
    }
    vector<pair<int, int>> reconstructQueue(vector<pair<int, int>>& people) 
    {
        sort(people.begin(),people.end(),cmp);
        vector<pair<int, int>>results;
        for (int i=0; i<people.size(); i++)
        {
            if (results.size()==0)
            {
                results.push_back(people[i]);
                continue;
            }
            
            int pos = people[i].second;
            results.insert(results.begin()+pos,people[i]);
        }
        return results;
    }
};
::::::::::::::
Greedy/0406.Queue-Reconstruction-by-Height/Readme.md
::::::::::::::
### 406.Queue-Reconstruction-by-Height

此题我们来这样考虑，比如对于[h,k]来说，如果只考虑那些身高比他高、位置比他靠前的人群，他是排第k+1个。那如果我们把所有身高比他高的人都已经拉了出来排成一排，我们再将这个人塞进第k+1位，也是不违和的。因为剩下那些比他矮的人，无论放在哪里，都不会再影响到k这个数值。

于是，贪心的方法很简单。我们按身高依次处理。当处理某人时，所有比他高的都已经处理完了，然后将该人放在第k+1个位置即可。他的插入不会对之前那些“高人”的排名产生任何的影响。依次类推处理完所有的人。

这里，当有两个人的身高相同怎么办呢？先处理k小的，他优先插入，优先得到更靠前的位置。


[Leetcode Link](https://leetcode.com/problems/queue-reconstruction-by-height)::::::::::::::
Greedy/0435.Non-overlapping-Intervals/435.Non-overlapping-Intervals_v1.cpp
::::::::::::::
class Solution {
    static bool cmp(vector<int>&a, vector<int>&b)
    {
        return a[1]<b[1];
    }
public:
    int eraseOverlapIntervals(vector<vector<int>>& intervals) 
    {
        sort(intervals.begin(), intervals.end(), cmp);
        int i = 0;
        int count = 0;
        while (i<intervals.size())
        {
            count++;
            int j = i+1;
            while (j<intervals.size() && intervals[j][0] < intervals[i][1])
                j++;
            i = j;
        }
        return intervals.size()-count;
    }
};
::::::::::::::
Greedy/0435.Non-overlapping-Intervals/435.Non-overlapping-Intervals_v2.cpp
::::::::::::::
class Solution {
public:
    int eraseOverlapIntervals(vector<vector<int>>& intervals) 
    {
        sort(intervals.begin(), intervals.end());
        int far = INT_MIN;
        int count = 0;
        for (auto interval: intervals)
        {
            if (interval[0] >= far)
            {
                far = interval[1];
                count++;
            }
            else if (interval[1] < far)
            {
                far = interval[1];
            }
        }
        return intervals.size()-count;
    }
};
::::::::::::::
Greedy/0435.Non-overlapping-Intervals/Readme.md
::::::::::::::
### 435.Non-overlapping-Intervals

#### 解法1

此题和452. Minimum Number of Arrows to Burst Balloons非常类似，可以用贪心法来解决类似的区间问题。

我们之前总结过，对区间排序的贪心法，有的需要sort by starting point，有的需要sort by ending point. 大致的规律是：
1. 如果求的是maximum number of non-overlapping intervals，用sort by ending point的方法
2. 如果求的是minimum number of intervals to cover the whole range，用sort by starting point的方法

本题就是前者。我们把右边界最小（成为right）的那个区间做为首区间，从排序后的interval中找到所有start小于当前这个右边界right的区间．这些区间都是可以删掉的！这是因为这些区间都互相重合，必然只能保留一个．而保留哪一个呢？就是保留当前这个右边界最小的区间，因为其他区间的右边界都较大，可能会造成对后面区间的重合，有潜在的风险，去掉他们最保险．

或者我们这样理解：为了保留更多的区间数目，在众多重合的区间里面，我们会优先选择右端点靠前的区间。因为它对后续的影响最小，有更大的概率让更多的区间出现。

#### 解法2

因为我们求的是non-overlapping intervals，所以从左往右看每个区间的ending point，就是从右往左看每个区间的starting point。所以理论上本题也一定可以用sort by starting point来做。

当然，具体的做法与1不太一样。我们将所有的区间按照starting point排序之后，依次遍历它们。我们维护一个当前能到达的最远点far。如果
1. 新区间的左端点在far的右边，那么新区间就不会与之前的任何区间重合，计数器加1
2. 新区间的右端点在far的左边，那么新区间就被旧区间包围。我们于是舍弃之前的区间，而prefer当前的区间，并更新far为右端点，使其变得更靠前。目的是让后面有机会加入更多的区间。

[Leetcode Link](https://leetcode.com/problems/non-overlapping-intervals)
::::::::::::::
Greedy/0442.Find-All-Duplicates-in-an-Array/442.Find-All-Duplicates-in-an-Array_v1.cpp
::::::::::::::
class Solution {
public:
    vector<int> findDuplicates(vector<int>& nums) 
    {
        int n = nums.size();
        nums.insert(nums.begin(),0);
        for (int i=1; i<=n; i++)
        {
            while (nums[i]!=i && nums[i]<=n && nums[i]!=nums[nums[i]])
                swap(nums[i], nums[nums[i]]);
        }
        vector<int>rets;
        for (int i=1; i<=n; i++)
        {
            if (nums[i]!=i)
                rets.push_back(nums[i]);
        }
        return rets;
    }
};
::::::::::::::
Greedy/0442.Find-All-Duplicates-in-an-Array/442.Find-All-Duplicates-in-an-Array_v2.cpp
::::::::::::::
class Solution {
public:
    vector<int> findDuplicates(vector<int>& nums) 
    {
        int n = nums.size();
        nums.insert(nums.begin(),0);
        vector<int>results;
        for (int i=1; i<=n; i++)
        {
            if (nums[abs(nums[i])]<0)
                results.push_back(abs(nums[i]));
            else
                nums[abs(nums[i])] *= -1;                                  
        }
        return results;
    }
};
::::::::::::::
Greedy/0442.Find-All-Duplicates-in-an-Array/Readme.md
::::::::::::::
### 442.Find-All-Duplicates-in-an-Array

#### 解法1
此题和 041.First-Missing-Positive 的解法非常相似。题目的共同点是：数组的元素规定了是从1\~N. 这就强烈暗示了，如果试图把正整数1~N顺次放入nums[1]~nums[N]中，那么没有被正确归位的那个元素（即nums[i]!=i）一定有“问题”。

对于“把正整数1~N顺次放入nums[1]~nums[N]中”的这种特殊的排序任务，有如下典型的时间复杂度o(n)、空间复杂度o(1)的方法：

遍历所有元素nums[i]，发现如果nums[i]!=i时，说明当前的nums[i]这个数没有被放置在合适的顺序位置。于是交换nums[i]和nums[nums[i]]。这样做的结果是：把nums[i]放到了它应该在的位置（正确归位），同时nums[i]有了新的值，需要再重复判断、交换的过程。这样的步骤持续到 nums[i]==nums[nums[i]]，这样就到了一个死循环，对于i这个位置就不能再做任何操作，于是跳过。

等到所有元素都遍历结束，那么所有元素就会被“力所能及”地归入了它们应该在的顺序位置。那么此时，对于那些nums[i]!=i的、没有正确归位的元素，在本题的题意下，就是那些重复的元素，可以轻易地挑出来。

#### 解法2
还有一种比较花哨的解法。对于数值x，我们如何不通过extra space来记录它是否出现过呢？方法是将nums[x]上的数字变成负数来进行标记，注意我们并不关心nums[x]是多少。只关心nums[x]是负数时表示x曾经出现过，反之表示x还没出现过。

所以我们依次遍历数组里的每个数字abs(x)，注意我们关心数值时必须看的是abs(x)，因为x的符号可能被encode了其他含义（如上所说）。如果nums[abs[x]]<0，表示abs(x)曾经出现过，加入我们的答案中。反之，说明abs(x)第一次出现，所以我们将nums[abs(x)]标记为负数，以此留下这个标记。


[Leetcode Link](https://leetcode.com/problems/find-all-duplicates-in-an-array)
::::::::::::::
Greedy/0448.Find-All-Numbers-Disappeared-in-an-Array/448.Find-All-Numbers-Disappeared-in-an-Array.cpp
::::::::::::::
class Solution {
public:
    vector<int> findDisappearedNumbers(vector<int>& nums) {
        int n = nums.size();
        nums.insert(nums.begin(),0);
        for (int i=1; i<=n; i++)
        {
            while (nums[i]!=i && nums[i]<=n && nums[i]!=nums[nums[i]])
                swap(nums[i], nums[nums[i]]);
        }
        vector<int>rets;
        for (int i=1; i<=n; i++)
        {
            if (nums[i]!=i)
                rets.push_back(i);
        }
        return rets;
    }
};
::::::::::::::
Greedy/0448.Find-All-Numbers-Disappeared-in-an-Array/Readme.md
::::::::::::::
### 448.Find-All-Numbers-Disappeared-in-an-Array

对于这种数列[1,..,N]摆放在index为[1,..,N]的数组，有一种比较常见的巧妙解法，就是index sorting.

我们观察一个i位置上的数，如果nums[i]!=i的话，那么说明这个nums[i]本不应该在这个位置上，于是我们就把它送到它应该待的地方，也就是index为nums[i]的地方，直至这种交换无法继续为止。什么情况下无法继续呢？一种就是nums[i]==i，说明位置i已经放置了应该出现的数；另一种就是nums[nums[i]]==nums[i]，也就是打算安排nums[i]的位置已经有一个合适的数在那里了，我们也无法继续了，说明位置i上注定无法放置期望出现的数。

核心代码如下：
```cpp
        while (i<nums.size())
        {
            if (nums[i]==i || nums[nums[i]]==nums[i])             
                i++;            
            else            
                swap(nums[i],nums[nums[i]]);            
        }
```        
此题本质上和 442. Find All Duplicates in an Array 一模一样，只不过最终输出的内容是index而不是元素的值。


[Leetcode Link](https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array)::::::::::::::
Greedy/0452.Minimum-Number-of-Arrows-to-Burst-Balloons/452.Minimum-Number-of-Arrows-to-Burst-Balloons.cpp
::::::::::::::
class Solution {
    static bool cmp(pair<int,int>a, pair<int,int>b)
    {
        return a.second<b.second;
    }
public:
    int findMinArrowShots(vector<pair<int, int>>& points) 
    {
        sort(points.begin(),points.end(),cmp);
        
        int j=0;
        int count=0;
        while (j<points.size())
        {            
            int right=points[j].second;
            while (j<points.size() && points[j].first<=right)
                j++;
            count++;
        }
        
        return count;
    }
};
::::::::::::::
Greedy/0452.Minimum-Number-of-Arrows-to-Burst-Balloons/Readme.md
::::::::::::::
### 452.Minimum-Number-of-Arrows-to-Burst-Balloons

将所有的气球按照右边界进行从小到大的排序。

按照排序后的右边界的值right进行遍历。对于所有未被射破的、左边界小于当前right的气球（此时他们的右边界必然大于right，因为right是从小到大遍历的），只要沿着这个right进行射击，就能最大效率地射破这些气球。

接下来寻找未被射破的下一个气球，更新最小的right。


[Leetcode Link](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons)::::::::::::::
Greedy/0484.Find-Permutation/484.Find-Permutation.cpp
::::::::::::::
class Solution {
public:
    vector<int> findPermutation(string s) 
    {
        s.insert(s.begin(),s[0]);
        int N=s.size();
        vector<int>results(N,0);
        
        int left=0;
        int right=0;
        
        while (right<s.size())
        {
            while (right+1<s.size() && !(s[right]=='D' && s[right+1]=='I'))
                   right++;
            if (right==s.size()) right--;
            
            int top=left;
            while (s[top+1]=='I') top++;
            for (int i=left; i<top; i++)
                results[i]=i+1;
            for (int i=top; i<=right; i++)
                results[i]=top+1+right-i;
            left=right+1;
            right=right+1;
        }
        
        return results;
            
    }
};
::::::::::::::
Greedy/0484.Find-Permutation/Readme.md
::::::::::::::
### 484.Find-Permutation

需要人工分析出最优的策略。

以“下拐点”为分界点将s序列分为若干个II...IIDD...DD的组合。对于每个II...IIDD...DD，可以知道最优方法是：将除最后一个I之外的所有I对应一个递增数列，剩下的一个I和所有的D对应一个递减数列，且递减数列的最小值是那个递增数列最大值加1。更有用的是，可以知道，所有的递增数列的值都是和它的index值是对应的`results[i]=i+1`。

那么s的位数和results的位数不一样怎么办？一个简单的方法是`s.insert(s.begin(),s[0])`，这样s和results的元素数目就是一致的，且各个位置都适用同样的代码语句。


[Leetcode Link](https://leetcode.com/problems/find-permutation)::::::::::::::
Greedy/0517.Super-Washing-Machines/517.Super-Washing-Machines.cpp
::::::::::::::
class Solution {
public:
    int findMinMoves(vector<int>& machines) 
    {
        int n = machines.size();
        vector<int>left(n,0);
        vector<int>right(n,0);

        int sum = 0;
        for (auto x:machines)
            sum += x;
        if (sum%n!=0) return -1;
        int k = sum/n;

        right[0] = machines[0] - k;
        for (int i=1; i<n-1; i++)
        {
            left[i] = -right[i-1];
            right[i] = machines[i]-k-left[i];
        }
        left[n-1] = machines[n-1]-k;

        int ret = 0;
        for (int i=0; i<n; i++)
        {
            int t = 0;
            if (left[i]>0) t+= left[i];
            if (right[i]>0) t+= right[i];
            ret = max(ret,t);
        }
        return ret;
    }
};
::::::::::::::
Greedy/0517.Super-Washing-Machines/Readme.md
::::::::::::::
### 517.Super-Washing-Machines

此题初看会有一种用DP的错觉．但细细想一想，其实最优策略是可以手工制定出来的，这就是贪心法．

首先，我们应该有这样的直觉，对任意一台洗衣机，最优的转移策略肯定不会出现＂反反复复＂的情况．即经过充分的优化调度后，衣物的转移应该是单向的．假设对于第i台洗衣机，最终平衡态是k件，设整个过程中i总共向左边净转移了left[i]件衣物，向右边净转移了right[i]件衣物，则必定满足如下关系：
```
machines[i]-k = left[i]+right[i]
```
并且在实际的最优操作中，第i台一定只需要向左移动left[i]件衣物，向右移动right[i]件衣物即可（注意，这两个值可能是负数）。总之同一个边不会有多余的双向操作。

其次，我们把所有洗衣机的初始状态想象成一座连绵起伏的山峦。每一次move前，我们知道哪些山峰是净输出的，哪些山谷是净输入的，而这一次move的效果就是：将某些山峰的一件衣物“超距作用”地转移到某些山谷中去。所谓的“超距作用”，就是说这种山峰填山谷的操作只需要一个回合就能完成。这是因为每个回合所有的洗衣机都在同时工作，每个洗衣机只有三种作用：净输出1，净值为0，净输入1或者2（某个山谷同时由两边来填）。那些净值为0的洗衣机其实就相当于传送带，某一边输入一件，同时又往另一边输出一件，从而协助了山峰填山谷的超距作用。

很显然，整批洗衣机需要停止工作的回合，就是等到那些山峰最终夷为平地的时刻。所以最终答案，就是找到“总输出”最多的那台机器即可。为什么是要算总输出呢？因为有可能是这种情景:左边的次山峰->主山峰->填补谷底。这样的一个回合，主山峰其实并没有净输出，是次山峰在净输出。但我们可以想象，主山峰一定是在不停地输出（不一定是净输出），而当主山峰不输出了，说明肯定一切都已经夷为平地了。

至于如何确定left[i]和right[i]是比较简单的，突破口就是最左边的洗衣机，其left[i]一定是零；次外，所有的```right[i]=-left[i+1]```。故这些变量都可解。


[Leetcode Link](https://leetcode.com/problems/super-washing-machines)::::::::::::::
Greedy/0524.Longest-Word-in-Dictionary-through-Deleting/524.Longest-Word-in-Dictionary-through-Deleting.cpp
::::::::::::::
class Solution {
public:
    string findLongestWord(string S, vector<string>& dictionary) 
    {
        int m = S.size();
        S = "#"+S;
        int next[m+1][26];
        
        for (int k=0; k<26; k++)
            next[m][k] = -1;
        for (int i=m; i>=1; i--)
        {
            for (int k=0; k<26; k++)
                next[i-1][k] = next[i][k];
            next[i-1][S[i]-'a'] = i;
        }
        
        string ret = "";
        for (auto word: dictionary)
        {
            int flag = 1;
            int i = 0;
            for (auto ch: word)
            {
                i = next[i][ch-'a'];
                if (i==-1)
                {
                    flag = 0;
                    break;
                }                
            }
            if (flag)
            {
                if (word.size() > ret.size() || (word.size() == ret.size() && word < ret))
                    ret = word;
            }
        }
        return ret;        
    }
};
::::::::::::::
Greedy/0524.Longest-Word-in-Dictionary-through-Deleting/Readme.md
::::::::::::::
### 524.Longest-Word-in-Dictionary-through-Deleting

此题等同于```792.Number-of-Matching-Subsequences```. 我们预处理得到next[i][ch]，表示S中位置i右边第一个出现字符ch的位置。这样对于每一个单词word，假设长度为n，我们只需要用o(n)的时间就可以找到全部字符在s中的对应位置。具体做法是，令初始i=0，然后遍历word所有的ch，不断地更新```i = next[i][ch]```。如果某个```next[i][ch]==-1```，那么就说明word不是s的subsequence。
::::::::::::::
Greedy/0581.shortest-unsorted-continuous-subarray/581.shortest-unsorted-continuous-subarray.cpp
::::::::::::::
class Solution {
public:
    int findUnsortedSubarray(vector<int>& nums) 
    {
        int curMax=INT_MIN;
        int right_bound=0;
        for (int i=0; i<nums.size(); i++)
        {
            if (nums[i]<curMax)
                right_bound=i;
            curMax=max(curMax,nums[i]);
        }
        
        int curMin=INT_MAX;
        int left_bound=nums.size()-1;
        for (int i=nums.size()-1; i>=0; i--)
        {
            if (nums[i]>curMin)
                left_bound=i;
            curMin=min(curMin,nums[i]);
        }        
        
        cout<<left_bound<<" "<<right_bound<<endl;
        
        return left_bound>=right_bound?0:right_bound-left_bound+1;
    }
};
::::::::::::::
Greedy/0581.shortest-unsorted-continuous-subarray/Readme.md
::::::::::::::
### 581.shortest-unsorted-continuous-subarray

本题的难点是如何设计不需要排序的o(n)算法。

找出这样一个right_bound：位于该数左边的所有数的最大值，要比这个数大，这说明这个数在排序后需要变换位置。怎么找呢？将数组从左到右过一遍，实时保存最大值即可，不断刷新这个right_bound。

同理，找到这样一个left_bound：位于该数右边的所有数的最小值，要比这个数小，这说明这个数在排序后需要变换位置。也是讲数组从右往左过一遍，实时保存最小值。

最后当right_bound>left_bound时，结果就是 right_bound-left_bound+1


[Leetcode Link](https://leetcode.com/problems/shortest-unsorted-continuous-subarray)::::::::::::::
Greedy/0624.Maximum-Distance-in-Arrays/624.Maximum-Distance-in-Arrays.cpp
::::::::::::::
class Solution {
public:
    int maxDistance(vector<vector<int>>& arrays) 
    {
        vector<int>Mins;
        vector<int>Maxs;
        for (int i=0; i<arrays.size(); i++)
        {
            Mins.push_back(arrays[i][0]);
            Maxs.push_back(arrays[i].back());
        }
        
        sort(Mins.begin(),Mins.end());
        sort(Maxs.begin(),Maxs.end());
        
        int N=arrays.size();
        int flag=0;
        for (int i=0; i<arrays.size(); i++)
        {
            if (arrays[i][0]==Mins[0] && arrays[i].back()==Maxs.back() )
            {
                flag=1;
                break;                    
            }            
        }
        
        if (flag==0)
            return Maxs.back()-Mins[0];
        else
            return max(Maxs.back()-Mins[1],Maxs[N-2]-Mins[0]);
    }
};
::::::::::::::
Greedy/0624.Maximum-Distance-in-Arrays/Readme.md
::::::::::::::
### 624.Maximum-Distance-in-Arrays

最粗浅的最优策略就是，把每个数组的第一个元素挑出来组成Mins数组，每个数组的最后一个元素挑出来组成Maxs数组。理想情况下，Maxs.back()-Mins[0]就是最大的一对差值。

当Maxs.back()和Mins[0]来自同一个数组怎么办？这时候考察Maxs[n-2]-Mins[0]以及Maxs.back()-Mins[1]，取其中较小的。而且这两对数字肯定不会是在同一个数组中的。


[Leetcode Link](https://leetcode.com/problems/maximum-distance-in-arrays)::::::::::::::
Greedy/0645.Set-Mismatch/645.Set-Mismatch.cpp
::::::::::::::
class Solution {
public:
    vector<int> findErrorNums(vector<int>& nums) 
    {
        int n = nums.size();
        nums.insert(nums.begin(), 0);
        for (int i=1; i<=n; i++)
        {
            while (nums[i]!=i && nums[i]<=n+1 && nums[i]!=nums[nums[i]])
            {
                swap(nums[i], nums[nums[i]]);
            }
        }
        
        for (int i=1; i<=n; i++)
        {
            if (nums[i]!=i)
               return {nums[i],i}; 
        }

        return {-1,-1};   
    }
};
::::::::::::::
Greedy/0645.Set-Mismatch/Readme.md
::::::::::::::
### 645.Set-Mismatch

此题其实就是```442.Find-All-Duplicates-in-an-Array```和```448.Find-All-Numbers-Disappeared-in-an-Array```的拼接。最后遍历到```nums[i]!=i```的位置时，说明nums[i]是duplicated number，而i就是missing number.

[Leetcode Link](https://leetcode.com/problems/set-mismatch)
::::::::::::::
Greedy/0646.Maximum-Length-of-Pair-Chain/646.Maximum-Length-of-Pair-Chain.cpp
::::::::::::::
class Solution {
    static bool cmp(vector<int>&a, vector<int>&b)
    {
        return a[1]<b[1];
    }
public:
    int findLongestChain(vector<vector<int>>& pairs) 
    {
        sort(pairs.begin(), pairs.end(), cmp);
        int i=0, count = 0;
        while (i<pairs.size())
        {
            int j = i;
            while (j<pairs.size() && pairs[j][0]<=pairs[i][1])
                j++;
            count++;
            i = j;
        }
        return count;
    }
};
::::::::::::::
Greedy/0646.Maximum-Length-of-Pair-Chain/Readme.md
::::::::::::::
### 646.Maximum-Length-of-Pair-Chain

此题本质和 435.Non-overlapping-Intervals 一模一样。
::::::::::::::
Greedy/0649.Dota2-Senate/649.Dota2-Senate.cpp
::::::::::::::
class Solution {
public:
    string predictPartyVictory(string senate) 
    {
        string str=senate;
        int len=0;
        int count=0;
        while (senate.size()!=len)
        {
            len=senate.size();
            string s;
            for (int i=0; i<senate.size(); i++)
            {
                if (senate[i]=='R')
                {                    
                    if (count>=0) s.push_back('R');
                    count++;
                }
                else
                {                    
                    if (count<=0) s.push_back('D');
                    count--;
                }
            }
            senate = s;
        }
        
        if (senate[0]=='R')
            return "Radiant";
        else
            return "Dire";
    }
};
::::::::::::::
Greedy/0649.Dota2-Senate/Readme.md
::::::::::::::
### 649.Dota2-Senate

对于R来说，其最优的策略是消灭其身后第一个仍存活的D，如果没有，再从队首开始找第一个仍存活的D。

此题如果依此策略进行模拟的话，效率很低。有比较巧妙的贪心算法，可以o(n)得到结果。

设置一个字符串s，代表senate经过一轮厮杀之后得以存活进入下一轮的子串。那么怎么从senate快捷方便地得到s呢？我们设置一个计数器count，如果遇到R就加一，遇到D就减一。注意，如果遇到R的时候，count>=0，说明之前的所有R/D厮杀得到的结果是R净胜，说明当前的R是不会被之前的任何D所封禁的，所以可以放心地将R加入s中。反之，如果遇到D的时候，count<=0，说明之前的所有R/D厮杀得到的结果是D净胜，说明当前的D是不会被之前的任何R所封禁的，所以可以放心地将D加入s中。其他情况下，都说明当前的R或D都无法能够存活，不能被加入下一轮的s中。

扫完一轮之后，接下来的关键点是：更新senate为s，但count不清零，重复上述的步骤。这是因为上一轮末的count其实反映了队尾存留的R的数目（或者D），他们能可以封禁残存的位于队首的D（或者R）。

最后循环直到新生成的s的长度不再变化，说明此时的s里面全部都是R或者D了。


[Leetcode Link](https://leetcode.com/problems/dota2-senate)::::::::::::::
Greedy/0659.Split-Array-into-Consecutive-Subsequences/659.Split-Array-into-Consecutive-Subsequences.cpp
::::::::::::::
class Solution {
public:
    bool isPossible(vector<int>& nums) 
    {
        unordered_map<int,int>left;
        unordered_map<int,int>seq;
        for (auto x: nums)
            left[x]++;

        for (auto x: nums)
        {
            if (left[x]==0) continue;
            if (seq[x-1]>0)
            {                
                left[x]--;
                seq[x-1]-=1;
                seq[x]+=1;                
            }
            else
            {
                if (left[x+1]==0 || left[x+2]==0)
                    return false;
                left[x]--;
                left[x+1]--;
                left[x+2]--;
                seq[x+2]+=1;
            }
            
        }
        return true;        
    }
};
::::::::::::::
Greedy/0659.Split-Array-into-Consecutive-Subsequences/Readme.md
::::::::::::::
### 659.Split-Array-into-Consecutive-Subsequences

假设我们当前处理的数字是x。下面分两种情况讨论：

如果之前的处理过的元素里，已经有以x-1为结尾的、长度大于等于3的序列，那么我们必然会将x接在这个已有的序列上。为什么呢？如果我们不接，那么x必然是作为一段新序列的首元素。但是如果后面没有x+1和x+2接上，那么x这个新序列就无法满足长度要求。而如果后面有x+1和x+2，那么我们何不将x,x+1,x+2一并都接在以x-1为结尾的序列上呢？可见不管后面是否有x+1/x+2，将x接在已有的序列上，都是最保险的决策。

如果之前的处理过的元素里，已经有以x-1为结尾的、长度大于等于3的序列，那么我们该怎么办呢？我们就必须创建以x为首元素的新序列，同时为了保证该新序列的最终长度要大于等于3，我们必须向后面“预支”两个元素：x+1和x+2。如果我们能提前知道后面已经没有了x+1和x+2，那么我们就可以返回false。

所以我们需要两个哈希表。seq[x]表示目前为止已经构建了多少个以x为结尾的、长度大于等于3的序列。left[x]表示后面还有多少个x没有被处理（初始值就是原数组中的x的个数）。当第一种情况时，以x-1结尾的序列会变成以一个新的以x为结尾的序列。第二种情况时，会增加一个以x+2为结尾的序列，同时注意相应的left[x],left[x+1],left[x+2]都需要自减1.

[Leetcode Link](https://leetcode.com/problems/split-array-into-consecutive-subsequences)
::::::::::::::
Greedy/0665.Non-decreasing-Array/665.Non-decreasing-Array_v1.cpp
::::::::::::::
class Solution {
public:
    bool checkPossibility(vector<int>& nums) 
    {
        int count=0;
        for (int i=1; i<nums.size(); i++)
        {            
            if (nums[i-1]>nums[i])
            {
                count++;
                
                if (count==2) return false;
                
                if (i>=2 && nums[i-2]>nums[i])
                    nums[i]=nums[i-1];
                else
                    nums[i-1]=nums[i];
            }
        }
        return true;
    }
};
::::::::::::::
Greedy/0665.Non-decreasing-Array/665.Non-decreasing-Array_v2.cpp
::::::::::::::
class Solution {
public:
    bool checkPossibility(vector<int>& nums) 
    {
        int a = -1, b = -1;
        for (int i=1; i<nums.size(); i++)
        {
            if (nums[i-1]>nums[i])
            {
                a = i-1;
                b = i;
            }
        }
        if (a==-1) return true;
        
        int flag = 1;
        for (int i=1; i<nums.size(); i++)
        {
            if (i==a) continue;
            else if (i==a+1)
            {
                if (i-2>=0 && nums[i-2]>nums[i])
                {
                    flag = false;
                    break;                    
                }                
            }
            else if (nums[i-1]>nums[i])
            {
                flag = false;
                break;
            }                
        }
        if (flag) return true;
        
        flag = 1;
        for (int i=1; i<nums.size(); i++)
        {
            if (i==b) continue;
            else if (i==b+1)
            {
                if (i-2>=0 && nums[i-2]>nums[i])
                {
                    flag = false;
                    break;                    
                }  
            }
            else if (nums[i-1]>nums[i])
            {
                flag = false;
                break;
            }                
        }
        if (flag) return true;
        return false;
    }
};
::::::::::::::
Greedy/0665.Non-decreasing-Array/Readme.md
::::::::::::::
### 665.Non-decreasing-Array

此题属于贪心法。考虑为了满足数列递增关系，遇到“坏点”的时候，最优的改动策略是什么。

#### 解法1

遍历数列一路查验是否递增，如果发现nums[i-1]>nums[i]，首先考虑的改动方案是将nums[i-1]=nums[i]，这样就避免改动nums[i]引发后续的变动。但是，如果又有nums[i-2]>nums[i]的话，那没有办法，为了避免改动两次，只能令nums[i]=nums[i-1]。此时计数1次。如果下次再出现了nums[i-1]>nums[i]的话，就返回false。

#### 解法2
遍历数列一路查验是否递增，如果发现nums[i-1]>nums[i]，说明坏点必然是nums[i-1]和nums[i]中间的一个。我们可以对其中一个进行隐去，看剩下的是否是non-decreasing序列。如果任意一个隐去后都不成立，就返回false。

[Leetcode Link](https://leetcode.com/problems/non-decreasing-array)
::::::::::::::
Greedy/0667.Beautiful-Arrangement-II/667.Beautiful-Arrangement-II.cpp
::::::::::::::
class Solution {
public:
    vector<int> constructArray(int n, int k) 
    {
        vector<int>ret({k+1});
        int count = 1;
        for (int d=k; d>=1; d--)
        {
            if (count%2==1)
                ret.push_back(ret.back()-d);
            else
                ret.push_back(ret.back()+d);
            count++;
        }
        reverse(ret.begin(), ret.end());
        for (int i=k+2; i<=n; i++)
            ret.push_back(i);
        
        return ret;
        
    }
};
::::::::::::::
Greedy/0667.Beautiful-Arrangement-II/Readme.md
::::::::::::::
### 667.Beautiful-Arrangement-II

通过简单的探索，不难发现，例如要构造1-5这五个不同的差，我们只需要用到1-6这六个数字构成wiggle序列即可：6,1,5,2,4,3. 如果还有剩余的数字，他们都是从7开始连续递增by 1的，我们将其放在6前面即可，即```...9,8,7,6,1,5,2,4,3```，不增加更多的差的数目。
::::::::::::::
Greedy/0670.Maximum-Swap/670.Maximum-Swap.cpp
::::::::::::::
class Solution {
public:
    int maximumSwap(int num) 
    {
        int MAX=0;
        int pos;
        string str=to_string(num);
        
        string str2=str;
        sort(str2.begin(),str2.end());
        reverse(str2.begin(),str2.end());
        
        int j=0;
        while (j<str.size() && str[j]==str2[j])
            j++;
        
        if (j==str.size()) return num;
                
        for (int i=j; i<str.size(); i++)
        {
            if (str[i]-'0'>=MAX)
            {
                MAX=str[i]-'0';
                pos=i;
            }
        }
        
        for (int i=j; i<pos; i++)
        {
            if (str[i]-'0'>=MAX)
                continue;
            swap(str[i],str[pos]);         
            break;
        }
        
        return stoi(str);
        
        
    }
};
::::::::::::::
Greedy/0670.Maximum-Swap/Readme.md
::::::::::::::
### 670.Maximum-Swap

从前往后遍历，排除最前的极大递减序列之外，找到剩下的序列里最大的那个数字（有相同的取靠后的），用它和递减序列之后的第一个元素交换。

比如986737，我们将它和排序之后的987763比较，发现前两位就是极大递减序列，所有不用管。从第三位开始，找剩下里面的最大值（相同最大值则取靠后的），结果是最后一个数字7。我们将这个7和递减序列之后的6对换，就得到了最终答案987736。


[Leetcode Link](https://leetcode.com/problems/maximum-swap)::::::::::::::
Greedy/0678.Valid-Parenthesis-String/678.Valid-Parenthesis-String.cpp
::::::::::::::
class Solution {
public:
    bool checkValidString(string s) 
    {
        int lower=0;
        int upper=0;
        
        for (int i=0; i<s.size(); i++)
        {
            if (s[i]=='(')
            {
                lower++;
                upper++;
            }
            else if (s[i]=='*')
            {
                lower--;
                upper++;
            }
            else if (s[i]==')')
            {
                lower--;
                upper--;
            }
            
            if (lower<0) lower=0;
            
            if (upper<0) return false;                        
        }
        
        return (lower==0);
    }
};
::::::::::::::
Greedy/0678.Valid-Parenthesis-String/Readme.md
::::::::::::::
### 678.Valid-Parenthesis-String

回想一下，如果没有“\*”的话，我们怎么处理？我们其实只需要一个计数器count表示未匹配的括号，遇到左括号就加一，遇到右括号就减一。在遍历的过程中，count不能小于零；在结束遍历后，count必须等于零。

那么有“\*”的情况下，我们的计数器需要表示一个范围[lower,upper]，表示未匹配的左括号的可能的数目。遇到左括号，未匹配的左括号数就加一；遇到右括号，未匹配的左括号数就减一，这个规则没有变。但是遇到\*的时候，它可以当做左括号，也可以当做右括号,也可以当做空号。所以我们需要处理的方法是：lower--; upper++。换句话说，lower表示我们在探索过程中尽可能地将星号转化为右括号，upper表示我们在探索过程中尽可能地将星号转化为左括号，但是同时保证当前的字符串不违法。最终遍历结束后，未匹配的左括号的数目范围需要包括零。

那么遍历的过程中这个范围会有什么变化呢？

首先，当lower小于0的时候，说明右括号太多了。那么之前出现的某个\*不能再代表右括号了，可以表示成空号。所以lower此时重置为0。而upper保持不变。

（特别注意,如果题目中说的是\*不能作为空号而只能用作左右括号的话,此时的lower应该置为1,因为我们是把一个可能用作右括号的\*确定必须为左括号.一正一反相当于lower的值会增2。此时upper的值仍然不变。）

其次，当upper小于0的时候，依然说明右括号太多了。但因为记录upper的原则是：之前的星号都尽可能地转化为左括号。说明此刻此刻，我们并没有任何多余的星号可以再变成左括号了。因此可以提前判断终止.

最后，遍历结束时，lower和upper还需要满足什么条件？显然[lower,upper]必须包括零点（事实上，lower永远不会小于零），这样表示有可能整体未被匹配的左括号数目为零。

类似的题有[lintcode 1475.Minimum-Legal-Bracket-Sequence](https://github.com/wisdompeak/LintCode/tree/master/Greedy/1475.Minimum-Legal-Bracket-Sequence)

[Leetcode Link](https://leetcode.com/problems/valid-parenthesis-string)
::::::::::::::
Greedy/0683.K-Empty-Slots/683.K-Empty-Slots.cpp
::::::::::::::
class Solution {
public:
    int kEmptySlots(vector<int> &flowers, int k) 
    {
        int N = flowers.size();
        vector<int>days(N);
        for (int i=0; i<N; i++)
            days[flowers[i]-1] = i;
        
        int result = INT_MAX;
        int candidate;
        for (int i=0; i<N; i++)
        {
            int left = i;
            int right = left+k+1;
            if (right>=N) break;
            
            bool flag = 1;
            for (int j=left+1; j<=right-1; j++)
            {
                if (days[j]<days[left] || days[j]<days[right])
                {
                    flag = 0;
                    i = j-1;
                    break;
                }
            }
            if (flag) 
            {
                candidate = max(days[left],days[right])+1;
                result = min(result,candidate);
            }
        }
        if (result==INT_MAX)
            return -1;
        else
            return result;
    }
};
::::::::::::::
Greedy/0683.K-Empty-Slots/Readme.md
::::::::::::::
### 683.K-Empty-Slots

此题可以用set的迭代器来做，每插入一个元素，只要在这个有序容器里找到前面和后面一个元素，看看之间是否相差ｋ即可．

更巧妙的o(n)解法是一个贪心策略．

我们将题目的条件转换成另一个数组days[i]，表示位置```ｉ```的花在```days[i]```这一天开放．那么我们希望得到什么呢？我们希望有这么一个宽度为k+1的区间[left,right],对于任意left<i<right，都有days[i]>days[left] && days[i]>days[right]．这说明这个区间内部的花都比两边的要晚开．等到left或right其中较晚的一个开放时，他们正好就是一对间隔Ｋ个ｐａｉｒ．

那么如何找到这样一个窗口呢？我们尝试让它滑动起来．令left=0,right=left+k+1,然后逐个考察其中的```ｉ```是否符合条件．如果遇到不符合条件的，说明days[i]要比两边的都要早，成为了一个＂钉子户＂,所有小于i的left都不可能符合要求了．那么显然，我们的策略就是让这个钉子户作为新的left，进行下一次的搜索．

注意,一旦找到一个合适的区间,那么输出的答案应该是max(days[left],days[right]),因为只有两边的花都开了,这个区间才成立.


[Leetcode Link](https://leetcode.com/problems/k-empty-slots)::::::::::::::
Greedy/0727.Minimum-Window-Subsequence/727.Minimum-Window-Subsequence_v1.cpp
::::::::::::::
class Solution {
public:
    string minWindow(string S, string T) 
    {
        int m = S.size();
        int n = T.size();
        S = "#"+S;
        T = "#"+T;
        auto dp = vector<vector<int>>(m+1,vector<int>(n+1,0));
        
        for (int j=1; j<=n; j++)
            dp[0][j] = INT_MAX/2;
        for (int i=0; i<=m; i++)
            dp[i][0] = 0;
        
        for (int i=1; i<=m; i++)
            for (int j=1; j<=n; j++)
            {
                if (S[i]==T[j])
                    dp[i][j] = dp[i-1][j-1]+1;
                else
                    dp[i][j] = dp[i-1][j]+1;
            }
        
        int len  = INT_MAX/2;
        int pos;
        for (int i=1; i<=m; i++)
        {
            if (dp[i][n] < len)
            {
                len = dp[i][n];
                pos = i;
            }
        }
        
        if (len>=INT_MAX/2)
            return "";
        else
            return S.substr(pos-len+1,len);
        
    }
};
::::::::::::::
Greedy/0727.Minimum-Window-Subsequence/727.Minimum-Window-Subsequence_v2.cpp
::::::::::::::
class Solution {
public:
    string minWindow(string s1, string s2) 
    {
        int m = s1.size();
        int next[m+1][26];
        s1 = "#" + s1;
        
        for (int ch=0; ch<26; ch++)
            next[m][ch] = -1;
        for (int i=m-1; i>=0; i--)
        {
            for (int ch=0; ch<26; ch++)
                next[i][ch] = next[i+1][ch];
            next[i][s1[i+1]-'a'] = i+1;
        }
        
        vector<int>start;
        for (int i=1; i<=m; i++)
        {
            if (s1[i]==s2[0])
                start.push_back(i);
        }
        
        string ret = "";
        for (int i: start)
        {
            int j = i-1;
            int flag = 1;
            for (auto ch: s2)
            {
                j = next[j][ch-'a'];
                if (j==-1)
                {
                    flag = 0;
                    break;
                }
            }
            if (flag)
            {
                int len = j-i+1;
                if (ret == "" || len < ret.size())
                {
                    ret = s1.substr(i, len);
                }
            }        
        }
        
        return ret;
    }
};
::::::::::::::
Greedy/0727.Minimum-Window-Subsequence/Readme.md
::::::::::::::
### 727.Minimum-Window-Subsequence

#### 解法1：双序列DP
对于双字符串的题目，双序列DP是一个非常自然的思路。根据双序列DP的套路，我们定义dp[i][j]表示，截止到S[i]的最短的substring长度，使得T[1:j]是这个substring的subsequence。注意，这个substring一定要包括S[i]本身。也就是说，如果这个dp的值是k，那么要求T[1:j]是S[i-k+1:i]的一个subsequence。

最终的答案是 min {dp[i][N]} (i=1,2,...M)。

根据双序列DP的套路，转移方程的入手点就是观察S[i]和T[j]的关系。
```cpp
for (int i=1; i<=M; i++)
 for (int j=1; j<=N; j++)
 {
    if (S[i]==T[j])
       dp[i][j]=dp[i-1][j-1]+1;
    else
       dp[i][j]=dp[i-1][j]+1; //说明S[i]对于构建T[1:j]没有帮助，T[1:j]得从dp[i][j-1]里面找
 }
```
然后我们考虑边界条件。易知 dp[0][j] (i=0, j=1,2,...N) 都是需要定义的边界条件。长度为0的S子串肯定不会是T的supersequence。故这些初始值应该是INT_MAX.

其次可以看出 dp[i][0] (i=0,1,2,...,M)也是需要提前设置初始值。显然，长度为0的T子串是任何长度为0的S子串的subsequence，故初始值是0.

最后在所有dp[i][N]中找到第一个最小值k，那么 S.substr(i-k+1,k)就是答案。

显然时间复杂度是o(MN).

#### 解法2：状态机
其实只要确定T[0]在S中的位置（比如说是start），那么T在S里的superstring就可以唯一地用贪心法确定。简单的方法就是双指针：S的指针指向start，T的指针指向0，S的指针一直向右遍历，试图去匹配T里面的每一个字符。如果T能够扫描完每一个字符，那么S指针的位置就是这个superstring的结尾。这样的做法复杂度是```(M+N)*K```，其中K是T[0]在S中出现的次数。

也可以利用类似```LC 792```的状态机的做法。提前对S预处理得到next[i][ch]，表示在S串的i位置上向右看，第一个出现ch的位置。这样我们就可以用o(1)时间实现S指针的跳转。这样的做法时间复杂度是```N*K```.


[Leetcode Link](https://leetcode.com/problems/minimum-window-subsequence)
::::::::::::::
Greedy/0731.My-Calendar-II/731.My-Calendar-II.cpp
::::::::::::::
class MyCalendarTwo {
    vector<pair<int,int>>events;
public:
    MyCalendarTwo() 
    {
        
    }
    
    bool book(int start, int end) 
    {
        vector<pair<int,int>>temp;
        for (int i=0; i<events.size(); i++)
        {
            if (!(events[i].second<=start || events[i].first>=end))
                temp.push_back(events[i]);
        }
        sort(temp.begin(),temp.end());
        
        for (int i=1; i<temp.size(); i++)
        {
            if (temp[i].first<temp[i-1].second)
                return false;
        }
        
        events.push_back({start,end});        

        return true;
    }
};

/**
 * Your MyCalendarTwo object will be instantiated and called as such:
 * MyCalendarTwo obj = new MyCalendarTwo();
 * bool param_1 = obj.book(start,end);
 */
::::::::::::::
Greedy/0731.My-Calendar-II/731.My-Calendar-II_v2.cpp
::::::::::::::
class MyCalendarTwo {
    multiset<pair<int,int>>Set;
public:
    MyCalendarTwo() 
    {
        
    }
    
    bool book(int start, int end) 
    {
        vector<pair<int,int>>p;
        for (auto x: Set)
        {
            if (!(end<=x.first || start>=x.second))
                p.push_back(x);
            if (end<=x.first) break;
        }        
        for (int i=1; i<p.size(); i++)
        {
            if (p[i].first<p[i-1].second)
                return false;
        }
        Set.insert({start,end});
        return true;
    }
};

/**
 * Your MyCalendarTwo object will be instantiated and called as such:
 * MyCalendarTwo obj = new MyCalendarTwo();
 * bool param_1 = obj.book(start,end);
 */
::::::::::::::
Greedy/0731.My-Calendar-II/Readme.md
::::::::::::::
### 731.My-Calendar-II

不需要考虑有序Hash和迭代器。此题只要找出所有与[start,end)重合的区间，再检查这些区间是否有互相的重合。是的话，说明必然有triple booking。


[Leetcode Link](https://leetcode.com/problems/my-calendar-ii)::::::::::::::
Greedy/0757.Set-Intersection-Size-At-Least-Two/757.Set-Intersection-Size-At-Least-Two.cpp
::::::::::::::
class Solution {
    static bool cmp(vector<int>&a, vector<int>&b)
    {
        if (a[1]==b[1])
            return a[0]>b[0];
        else
            return a[1]<b[1];
    }
public:
    int intersectionSizeTwo(vector<vector<int>>& intervals) 
    {
        sort(intervals.begin(), intervals.end(), cmp);
        int a = intervals[0][1]-1, b = intervals[0][1];
        int count = 2;

        for (auto& interval: intervals)
        {
            if (interval[0]<=a)
                continue;
            else if (interval[0]<=b)
            {
                count++;
                a = b;
                b = interval[1];
            }
            else
            {
                count+=2;
                a = interval[1]-1;
                b = interval[1];
            }
        }
        return count;
    }
};
::::::::::::::
Greedy/0757.Set-Intersection-Size-At-Least-Two/Readme.md
::::::::::::::
### 757.Set-Intersection-Size-At-Least-Two

我们想象如果我们能找出一系列non-overlapping的区间，那么我们的答案必然需要在每个区间内至少采集两点。所以本题的答案至少是maximum number of non-overlapping intervals的两倍。所以借鉴435的思路，我们采用sort by ending points的方法去下手。这个突破口的想法和```452.Minimum-Number-of-Arrows-to-Burst-Balloons```很相似。

如果我们将这些区间按照后边界从小到大排序后（相同后边界的情况下，显然只考虑区间跨度最短的，因为短区间能被S覆盖的话，那么相同右端点的长区间必然也能被覆盖），先考虑第一个区间。对于这个区间，我们肯定会选该区间的最后两点加入S，因为这两点是最有可能与后面的区间重合的，效率最高。

然后我们再考虑下一个区间[x,y]，此时S应该如何更新呢？一个最明显的特点是，y一定大于等于S里的最大点。于是此时最有影响的其实就只是区间的前边界a。我们分类讨论x的位置查看对S的影响：
1. 如果[x,y]覆盖了S最后两个点，那么S就不用更新；
2. 如果[x,y]只覆盖了S最后一个点，那么这个点其实就一定是S的后边界，那么S需要再补一个点。这个点是什么呢?最好的选择就是[x,y]的最后一个点，即y。这种做法是最“贪心”的，因为它最可能会与[x,y]之后的区间重合。
3. 如果[x,y]没有覆盖S，那么S就要加上什么呢，是[x,y]的最后两个点即可，同理也是用贪心的策略。

综上，我们其实只要每次关注集合S里的最大两个点a，b即可，不断与下一个区间[x,y]考察相对关系，更新S。


[Leetcode Link](https://leetcode.com/problems/set-intersection-size-at-least-two)
::::::::::::::
Greedy/0761.Special-Binary-String/761.Special-Binary-String.cpp
::::::::::::::
class Solution {
public:
    string makeLargestSpecial(string S) 
    {
        if (S.size()==2) return S;

        vector<string>strs;
        
        for (int i=0; i<S.size(); i++)
        {
            int i0=i;
            int count=0;
            while (i<S.size())
            {
                if (S[i]=='1')
                    count++;
                else
                    count--;                
                if (count==0)
                    break;   
                i++;
            }
            strs.push_back("1"+makeLargestSpecial(S.substr(i0+1,i-i0-1))+"0");
        }
        
        sort(strs.begin(),strs.end(),greater<string>());
        string result;
        for (auto a:strs) result+=a;
        return result;
        
    }
};
::::::::::::::
Greedy/0761.Special-Binary-String/Readme.md
::::::::::::::
### 761.Special-Binary-String

首先，应该容易分析出：对于一个special string S，它整体可以拆分为一个或若干个不可再拆分的、连续的sub special string。对于每个不可再连续拆分的sub special string S'，它的首位一定是1，末位一定是0，中间一定还是一个special string，于是可能还可以继续拆分下去。

写成式子就是： 任何 S = （1）ABCDEF（0）,首位的1和末位的0可能存在，而中间的ABCDEF都还是不可连续拆分的speical string，

因为题目规定的swap的规则必须是在相邻的special string之间进行，所以对于任何一个S,只能通过内部的ABCDEF这些S'之间的位置调整,使得S自身调整至字典序最大（暂时不考虑ABCDEF内部的调整，假设它们已经各自字典序最优）。那么如何调整ABCDEF使得S的字典序最大呢？显然，只要让ABCDEF按照字典序从大到小排列即可。

这就有了递归的思路。把S拆成ABCDEF，让它们各自递归成字典序最大，然后优化后的ABCDF按字典序重排，技能得到字典序最大的S。


[Leetcode Link](https://leetcode.com/problems/special-binary-string)::::::::::::::
Greedy/0767.Reorganize-String/767.Reorganize-String_v1.cpp
::::::::::::::
class Solution {
public:
    string reorganizeString(string S) 
    {
        unordered_map<char,int>count(26);        
        for (auto ch:S) 
            count[ch]++;

        vector<pair<int,char>>arr;
        for (auto ch: S)
            arr.push_back({count[ch], ch});
        sort(arr.rbegin(), arr.rend());

        string ret(S.size(),' ');

        int i = 0;
        for (auto [cnt, ch]: arr)
        {
            ret[i] = ch;
            if (i>=1 && ret[i]==ret[i-1])
                return "";
            i+=2;
            if (i>=S.size())
                i = 1;            
        }

        return ret;
    }
};
::::::::::::::
Greedy/0767.Reorganize-String/767.Reorganize-String_v2.cpp
::::::::::::::
class Solution {
public:
    string reorganizeString(string S) 
    {
        unordered_map<char,int>count;
        for (auto ch:S) count[ch]++;

        priority_queue<pair<int,char>>pq;        
        for (auto x:count) 
            pq.push({x.second, x.first});        
        
        string result;
        while (!pq.empty())
        {
            int k = min(2,(int)pq.size());
            vector<pair<int,char>>temp;
            
            for (int i=0; i<k; i++)
            {
                auto [num, ch] = pq.top(); 
                pq.pop();
                result+=ch;
                num--;
                if (num!=0) temp.push_back({num,ch});                
            }
            if (k<2 && temp.size()>0) return "";
            for (auto a:temp) pq.push(a);
        }
        return result;
    }
};
::::::::::::::
Greedy/0767.Reorganize-String/Readme.md
::::::::::::::
### 767.Reorganize-String

本题本质上```1953.Maximum-Number-of-Weeks-for-Which-You-Can-Work```的follow up，要求将具体的规划方案打印出来。此题和```1054.Distant-Barcodes```一模一样。类似地，本题还是```358. Rearrange String k Distance Apart```在k=2时的特例。

#### 解法1：贪心
我们将所有的字符按照频次重新排序，例如abcbba，就会重排成bbbaac。对于频次较高的字符我们会尽量安排它们间隔排列，即先放在奇数的位置上。一旦奇数位置上放满了，就从头开始在偶数位置上。这样就最大限度地避免高频词的字符被放在相邻的位置。

从上面的贪心策略我们可以推论出，只要最高频次的字符的数目不多于总数目的一半，那么用上面的方法构造出的结果就是合法的。反之必然会有相邻的字符相同。

#### 解法2：优先队列
之前的方法是跳跃地构造结果。用优先队列可以直接顺序地构造结果。

基本的思想就是：每个回合尽量使用当前频次最多的两个字母。如果不优先使用频次最多的字母，则越有可能提早耗尽其他频次较低的字符种类。当最终手头只剩一种字母时，构造就无法进行下去。

数据结构上，维护一个优先队列来实时得到当前频次最多的两个字母。只要每次能取两个不同字母组成一对加入字符串，可以保证顺利构造结果。记得使用完之后，将这两种字母频次减一之后再放入队列之中。

失败的条件：队列中只有一种字母，并且字母的频次大于等于2.
::::::::::::::
Greedy/0781.Rabbits-in-Forest/Readme.md
::::::::::::::
### 781.Rabbits-in-Forest

如果answers里面含有元素m，那么我们最多允许它出现m+1次，使得这m+1个汇报的兔子是属于共同颜色的。如果出现了第m+2只兔子同样汇报了m，那么它只能是另外一种颜色，即必然另外m+1只兔子属于另一个颜色圈。

更一般的，如果有n只兔子都汇报了m，那么“颜色圈”的数量最少是```k = (n-1) / (m+1) + 1```。那么对应有```(m+1)*k```只兔子。
::::::::::::::
Greedy/0792.Number-of-Matching-Subsequences/792.Number-of-Matching-Subsequences_v1.cpp
::::::::::::::
class Solution {
public:
    int numMatchingSubseq(string S, vector<string>& words) 
    {
        auto table = vector<vector<int>>(26);
        for (int i=0; i<S.size(); i++)
            table[S[i]-'a'].push_back(i);
        
        int count = 0;
        for (auto str:words)
        {
            if (str.size()>S.size()) continue;
            if (check(str,table)) count++;
        }
            
        return count;
    }
    
    bool check(string A, vector<vector<int>>&table)
    {
        int i=0;
        for (char ch:A)
        {
            auto iter = lower_bound(table[ch-'a'].begin(),table[ch-'a'].end(),i);
            if (iter==table[ch-'a'].end()) return false;
            i = *iter+1;
        }
        return true;
    }
};
::::::::::::::
Greedy/0792.Number-of-Matching-Subsequences/792.Number-of-Matching-Subsequences_v2.cpp
::::::::::::::
class Solution {
public:
    int numMatchingSubseq(string S, vector<string>& words) 
    {
        int m = S.size();
        S = "#"+S;
        int next[m+1][26];
        
        for (int k=0; k<26; k++)
            next[m][k] = -1;
        for (int i=m; i>=1; i--)
        {
            for (int k=0; k<26; k++)
                next[i-1][k] = next[i][k];
            next[i-1][S[i]-'a'] = i;
        }
        
        int ret = 0;
        for (auto word: words)
        {
            int flag = 1;
            int i = 0;
            for (auto ch: word)
            {
                i = next[i][ch-'a'];
                if (i==-1)
                {
                    flag = 0;
                    break;
                }                
            }
            if (flag) ret++;
        }
        return ret;        
    }    
};
::::::::::::::
Greedy/0792.Number-of-Matching-Subsequences/Readme.md
::::::::::::::
### 792.Number-of-Matching-Subsequences

传统的方法，利用双指针挨个比较s和word，那么时间复杂度就是o(ST)，其中S是s的长度，T是words的总长度。本题的考点在于s的长度很大时，时间复杂度如何优化。

#### 解法1：二分搜索
我们可以提前预处理s，将每个字符出现的位置分别归类，即pos[ch]包含了s里字符ch所在的位置（可能有若干个）。假设我们在查看word[0]='a'的时候，直接从pos['a']里面找最早的位置i。再查看word[1]='b'的时候，又从pos['b']里面找第一个大于等于i的位置j。再查看word[1]='c'的时候，从pos['c']里面找第一个大于等于j的位置k。依次类推。如果遇到某个word的字符ch，但是pos[ch]里面没有大于等于某个期望位置的元素时，那么这个word就不是s的子序列了。

时间复杂度是o(TlogS)，因为在word中每处理一个字符，都需要在pos[ch]里进行一次二分查找。

#### 解法2：状态机
我们提前处理s，得到next[i][ch]，表示i位置之后下一个出现字符ch的位置是哪里；如果再没有出现过ch，那么标记-1. next数组的预处理是从后往前进行的，时间是o(26S).

在处理word时，我们通过next[0][word[0]]，找到下一个出现word[0]的位置i。再通过next[i][word[1]]，找到下一个出现word[1]的位置j。再通过next[i][word[2]]，找到下一个出现word[2]的位置k。依次类推，如果word的每一个字符都能在next中找到，那么就OK。否则如果遇到类似```next[k][word[3]]==-1```，就说明该字符找不到，即word不是s的子序列。

时间复杂度是o(T).
::::::::::::::
Greedy/0826.Most-Profit-Assigning-Work/826.Most-Profit-Assigning-Work.cpp
::::::::::::::
class Solution {
public:
    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) 
    {
        vector<pair<int,int>>tasks;
        for (int i=0; i<difficulty.size(); i++)
            tasks.push_back({difficulty[i],profit[i]});
        
        sort(tasks.begin(),tasks.end());
        
        int MAX = tasks[0].second;
        for (int i=1; i<tasks.size(); i++)
        {
            tasks[i].second = max(tasks[i].second,MAX);
            MAX = tasks[i].second;
        }        
        
        int sum = 0;
        for (int x:worker)
        {
            auto iter = upper_bound(tasks.begin(),tasks.end(),make_pair(x,INT_MAX));
            if (iter!=tasks.begin())
            {
                iter = prev(iter,1);
                sum+=iter->second;
            }
        }
        return sum;
    }
};
::::::::::::::
Greedy/0826.Most-Profit-Assigning-Work/Readme.md
::::::::::::::
### 826.Most-Profit-Assigning-Work

此题不难想到正确的贪心解法。

我们将所有的任务ｔａｓｋｓ按照难度从小到大进行排序然后遍历。如果难度小的任务的收益是ｐ，那么比之难度更大的任务的收益理论上不应该比ｐ更小，否则我们可以选择用难度小收益大的项目替代更划算。所以我们将这些任务的收益重新赋值，使得ｔａｓｋｓ按照难度从小到大排列后，收益也是递增的。

接下来对于任何一个工人，我们在这个ｔａｓｋｓ序列中找到他所能接受的最大难度ｄ的任务，那么这个任务对应的（重新赋值后的）收益，就是这个工人所能创造的最大收益。因为这个收益，本质对应了所以难度小于等于ｄ的任务中的最高收益。每个工人都是如此计算，得到的总收益就是答案。

本题的ｃｐｐ解法要注意下面这句：
```
auto iter = upper_bound(tasks.begin(),tasks.end(),make_pair(x,INT_MAX));
```
这里的第三个参数一定要用make_pair来生成，不能用{x,INT_MAX}，否则编译器不能自动正确地转化。


[Leetcode Link](https://leetcode.com/problems/most-profit-assigning-work)::::::::::::::
Greedy/0870.Advantage-Shuffle/870.Advantage-Shuffle.cpp
::::::::::::::
class Solution {
public:
    vector<int> advantageCount(vector<int>& A, vector<int>& B) 
    {
        int n = A.size();
        vector<pair<int,int>>BB;
        for (int i=0; i<n; i++)
            BB.push_back({B[i],i});
        sort(BB.begin(), BB.end());
        sort(A.begin(), A.end());
        
        int j=0;
        vector<int>rets(n,-1);
        for (int i=0; i<n; i++)
        {
            while (j<n && A[j]<=BB[i].first)
                j++;
            if (j<n)
            {
                rets[BB[i].second] = A[j];
                A[j] = -1;
            }                
        }
        
        j = 0;
        for (int i=0; i<n; i++)
        {
            if (rets[i]!=-1) continue;
            while (j<n && A[j]==-1) j++;
            rets[i] = A[j];
            j++;
        }
        return rets;
    }
};
::::::::::::::
Greedy/0871.Minimum-Number-of-Refueling-Stops/871.Minimum-Number-of-Refueling-Stops.cpp
::::::::::::::
class Solution {
public:
    int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) 
    {
        if (startFuel>=target) return 0;
        
        stations.push_back({target,0});
        
        int stationID = 0;
        int curFuel = startFuel;
        priority_queue<int>pq;
        int count = 0;
        
        while (stationID<stations.size())
        {
            if (curFuel>=stations[stationID][0])
            {
                pq.push(stations[stationID][1]);
                stationID++;                
            }
            else
            {
                while (curFuel<stations[stationID][0] && pq.size()>0)
                {
                    curFuel+=pq.top();
                    pq.pop();
                    count+=1;
                }
                
                if (curFuel<stations[stationID][0] && pq.size()==0)
                    return -1;
            }
        }
        
        return count;        
    }
};
::::::::::::::
Greedy/0871.Minimum-Number-of-Refueling-Stops/Readme.md
::::::::::::::
### 871.Minimum-Number-of-Refueling-Stops

我们可以这样考虑．现在有一定量的startFuel，假设可以驶过两个加油站，但是达不到第三个加油站．说明我们应该在前两个加油站中的某一个或全部两个停下来加油．但是该加多少呢？

其实，我们不用想的太远，千里之行始于足下，目前只需要加油使得能够开到第三个加油站即可．于是，我们优先考虑前两个加油站里较多的那一个，不够的话就算上另一个．反正到了第三个加油站后，我们就又多了一个option．等过了第三个加油站，我们再类似地考虑，是否需要加油才能开到第四个加油站．如果需要，就在前三个加油站里面尚未加过油的那些里，选择油量最多的那个即可；不需要的话，就把第四个加油站放入option list,考虑是否需要加油才能开到第五个加油站...

这就是贪心法的最优策略．特别注意，我们得把target当做一个加油站来处理。不能只用贪心法处理到最后一个加油站，再用剩下的curFuel来考虑是否能到target，那样是错误的：因为这样的话你只是用尽全力到达最后一个加油站，而并没有用尽全力去到达target。


[Leetcode Link](https://leetcode.com/problems/minimum-number-of-refueling-stops)::::::::::::::
Greedy/0881.Boats-to-Save-People/881.Boats-to-Save-People_v1.cpp
::::::::::::::
class Solution {
public:
    int numRescueBoats(vector<int>& people, int limit) 
    {
        sort(people.begin(), people.end());
        int i=0, j=people.size()-1;
        int count = 0;
        while (i<=j)
        {
            if (people[i]+people[j]<=limit)
                i++;
            j--;
            count++;
        }
        return count;
    }
};
::::::::::::::
Greedy/0881.Boats-to-Save-People/881.Boats-to-Save-People_v2.cpp
::::::::::::::
class Solution {
public:
    int numRescueBoats(vector<int>& people, int limit) 
    {
        vector<int>p(limit+1,0);
        for (int w: people)
            p[w]++;
        
        int count = 0;
        for (int x = limit; x>0; x--)   // weight of the heaviest guy up to now
        {
            for (int i = p[x]; i>0; i--)
            {
                count++;
                p[x]--;
                
                int y = limit-x;
                while (y>0 && p[y]==0) y--;
                if (y>0) p[y]--;
                if (x==y) i--;
            }
        }
        return count;
    }
};
::::::::::::::
Greedy/0881.Boats-to-Save-People/881.Boats-to-Save-People_v3.cpp
::::::::::::::
class Solution {
public:
    int numRescueBoats(vector<int>& people, int limit) 
    {
        vector<int>p(limit+1,0);
        for (int w: people)
            p[w]++;
        
        int count = 0;
        int x = limit;
        int y = 1;
        
        while (x>0)
        {
            while (x>0 && p[x]==0)
                x--;
            if (x==0) break;
            count++;
            p[x]--;
            
            while (y+x<=limit && p[y]==0) 
                y++;
            if (y+x<=limit && p[y]>0) 
                p[y]--;
        }
                
        return count;
    }
};
::::::::::::::
Greedy/0881.Boats-to-Save-People/Readme.md
::::::::::::::
### 881.Boats-to-Save-People

#### 解法1：
容易想到比较严谨的贪心解，就是找到当前最重的小胖x，然后找到当前最大的小瘦y使得```x+y<=limit```，这样x和y的配对是对资源的最优利用。

事实上这个贪心法可以进行松弛：对于当前最重的小胖x，只需要找到当前最小的小瘦y进行配对，就可以实现对资源的最优利用。分析如下。假设我们将所有人从轻到重排序```y1,y2,y3,y4,...,x4,x3,x2,x1```。对于当前最重的小胖对应的是x1，假设如果根据严谨的贪心算法找到的配对是y4（也就是恰好满足y4+x1<=limit），那么容易证明{x1,y1},{x2,y2},{x3,y3},{x4,y4}这四对其实都满足条件（即两个人加起来不超过limit）。所以我们可以将这四对剥离（因为已经充分利用了资源），对于剩下的人同理进行递归处理就可以了。

于是这道题就转化为了双指针。左右指针朝中间移动，计算有多少对满足```people[i]+people[j]<=limit```.

这种解法最大的隐患是时间复杂度需要O(NlogN)，勉强可以通过。

#### 解法2：
如何避免排序就能确定最重的人是谁呢？我们可以借鉴桶排序的思想：用一个计数器数组p来记录每个重量的人数。

假设当前最重的小胖的体重是x，那么对于x的值我们可以从limit开始往下猜，一旦发现p[x]>0，说明我们找到了这个最重的人。那么如何寻找x的最合理队友呢？我们可以从体重y=limit-x开始往下猜，一旦发现p[y]>0，就说明我们找到了最适合与x配对的小瘦（其体重为y）。记得每次配对之后，我们都需要及时更新计数器p[x]-- and/or p[y]--.

这种解法最大的雷区在于：如果遇到了```x==y```的情况，说明小胖和小瘦的体重相同，那么对于小胖的处理次数就不是原先的p[x]了，而是需要及时减去一才对。

#### 解法3：
可以将解法1的松弛贪心思想，以及解法2桶排序的思想结合起来。基本思想依然是双指针，但指针指的不是数组首尾的index，而是区间范围[1,limit]左右边界的value.

假设当前最重的小胖的体重是x，那么对于x的值我们可以从limit开始往下猜，一旦发现p[x]>0，说明我们找到了这个最重的人。同时我们寻找当前最轻的小瘦，假设其体重为y，对于y的值我们可以从1开始往上猜，一旦发现p[y]>0，说明我们找到了当前最轻的人。对于每个小胖我们都试图寻找当前最轻的小瘦，如果符合```x+y<0 && p[y]>0```就说明存在它可以与小胖同船。

显然容易分析出时间复杂度是o(N+limit)，比解法1要优秀.


[Leetcode Link](https://leetcode.com/problems/boats-to-save-people)::::::::::::::
Greedy/0910.Smallest-Range-II/910.Smallest-Range-II.cpp
::::::::::::::
class Solution {
public:
    int smallestRangeII(vector<int>& A, int K) 
    {
        sort(A.begin(), A.end());
        int diff = A.back()-A[0];
        for (int i=0; i<A.size()-1; i++)
        {
            int MAX = max(A[i]+K, A.back()-K);
            int MIN = min(A[0]+K, A[i+1]-K);
            diff = min(diff, MAX-MIN);
        }
        return diff;
    }
};
::::::::::::::
Greedy/0910.Smallest-Range-II/Readme.md
::::::::::::::
### 910.Smallest-Range-II

首先要有一个直觉：我们将A排序之后，为了减少“贫富差距”，我们一定是将A的左边一部分元素都加上K，右边一部分元素都减去K。为什么左边那部分一定都是加上K，而不是加减交错呢？比如说，a<b<c，如果我们决策是 a+K, b-K, c+K 的话，b和c之间的差距不仅没有减小反而被拉大了。所以在最终的方案里，绝对不可能出现“加，减，加”交错操作的情况，唯一的方案就是：左边一部分加K，右边一部分减K。

那么如果确定这个分界线呢？其实并没有更优秀的办法，挨个尝试就行了。假设这个分界线在A[i]后面，也即是说A[0]～A[i]都是加K，A[i+1]～A[n-1]都是减K，那么这个新数组B的最大值，其实可以从左右两部分分别的最大值得到，即```MAX = max(A[i]+K, A.back()-K)```.同理，这个新数组B的最小值，其实可以从左右两部分分别的最小值得到，即```MIN = min(A[0]+K, A[i+1]-K)```。而我们的答案就是在所有的```diff=MAX-MIN```中挑选最小的那个。


[Leetcode Link](https://leetcode.com/problems/smallest-range-ii)::::::::::::::
Greedy/0921.Minimum-Add-to-Make-Parentheses-Valid/921.Minimum-Add-to-Make-Parentheses-Valid.cpp
::::::::::::::
class Solution {
public:
    int minAddToMakeValid(string S) 
    {        
        int count = 0;
        int ret = 0;
        for (auto ch:S)
        {
            if (ch=='(')
                count++;
            else
                count--;
            if (count < 0)
            {
                ret += 1;
                count = 0;
            }
        }
        ret += count;
        return ret;
    }
};
::::::::::::::
Greedy/0921.Minimum-Add-to-Make-Parentheses-Valid/Readme.md
::::::::::::::
### 921.Minimum-Add-to-Make-Parentheses-Valid

此题的贪心法比较容易理解。我们维护一个计数器count，表示是目前为止尚未被匹配的左括号的数目。

举个例子：s = (()))((

我们依次查看到```((```的时候，count=2，此时我们并不着急对s做任何改动，因为s后面还有字符，说不定这些左括号都能被匹配到。

我们继续查看到```(())```的时候，count=0，果然这时候的字符就是匹配的，我们依然不需要对s做任何改动。

我们继续查看到```(()))```的时候，count=-1，此时我们不得不出手。因为无论s后面的字符如何，都无法挽救当前这个无法被匹配的右括号。此时必须处理，即增加一个左括号与之匹配。至于放在哪里我们并不关心，总之有地方放就是了。注意，既然增加一个左括号，那么此时的count=0.

我们继续查看到```(()))((```的时候，count=2，字符串完结。对于这两个未被匹配的左括号，我们也必须处理，不得不增加两个右括号与之匹配。

回顾上述的过程，我们所有增加括号的操作都是必要操作。最终我们实现了count=0，意味着这个字符串此时已经合法了。所以之前的“必要操作”也是“充分操作”，就是最终解。

如果题目改成"Minimum delete to Make Parentheses Valid"，答案其实一模一样。我们增加多少括号促成匹配，就等效于减少多少（对称的）括号促成匹配。
::::::::::::::
Greedy/0932.Beautiful-Array/932.Beautiful-Array.cpp
::::::::::::::
class Solution {
public:
    vector<int> beautifulArray(int N) 
    {
        if (N==1) return {1};
        if (N==2) return {2,1};
        
        vector<int>A = beautifulArray((N+1)/2);
        vector<int>B = beautifulArray(N-(N+1)/2);
        vector<int>ret;
        for (int x:A) ret.push_back(x*2-1);
        for (int x:B) ret.push_back(x*2);
        return ret;
    }
};
::::::::::::::
Greedy/0932.Beautiful-Array/Readme.md
::::::::::::::
### 932.Beautiful-Array

此题的突破点是：如果A是奇数，B是偶数，那么A和B的摆放位置是任意的，因为不可能有C夹在AB之间且C*2=A+B.所以这就提示我们如果我们把所有的奇数组成一个beautiful array，所有的偶数组成一个beautiful array，那么把这两个array简单的拼接，就能组成一个完整的beautiful array.

那么我们怎么把所有的奇数,比如说[1,3,5,7]组成一个beautiful array呢？这是一个四元素的数组，我们很容易想到，如果已知[1,2,3,4]组成的beautiful array，那么将它们统统乘以2减去1，就能得到用[1,3,5,7]组成的beautiful array了。同理，将[1,2,3,4]组成的beautiful array乘以2，也能得到[2,4,6,8]组成的beautiful array。于是两者拼接，就有了从1到8组成的beautiful array。

由此可见，这道题就是考察了简单的递归思想。


[Leetcode Link](https://leetcode.com/problems/beautiful-array)::::::::::::::
Greedy/0936.Stamping-The-Sequence/936.Stamping-The-Sequence.cpp
::::::::::::::
class Solution {
public:
    vector<int> movesToStamp(string stamp, string target) 
    {
        bool changed = 1;
        vector<int>results;
        
        while (changed==1)
        {
            changed = 0;
            for (int i=0; i<target.size(); i++)
            {
                if (check(stamp,target,i))
                {                    
                    for (int k=0; k<stamp.size(); k++)
                        target[i+k] = '*';       
                    results.push_back(i);
                    changed = 1;
                    break;
                }
            }
        }
        
        for (int i=0; i<target.size(); i++)        
            if (target[i]!='*') return {};
                            
        reverse(results.begin(),results.end());
        return results;
        
    }
    
    bool check(string&stamp, string&target, int pos)
    {
        int flag = 0;
        for (int i=0; i<stamp.size(); i++)
        {
            if (pos+i>=target.size()) return false;
            if (target[pos+i]=='*') continue;
            if (target[pos+i]!=stamp[i]) return false;
            flag = 1;
        }
        return flag;
    }
};
::::::::::::::
Greedy/0936.Stamping-The-Sequence/Readme.md
::::::::::::::
### 936.Stamping-The-Sequence

周赛的时候想到的是递归。对于这一系列ｓｔａｍｐ的操作，只关注最后一次盖章：其实可以看成找到中间某处完全匹配的地方，将整个序列断成了两部分，能匹配的部分我们就替换成是"*****".这样我们将原来的问题分解为了两个子序列，可以再递归处理。其中如果遇到边界是星号的部分我们都认为能匹配上的。

其实上面的想法再进一步的话，可以得到更优美的贪心解法。

思想本质是：我们只要在当前的target中能够找到匹配stamp的片段，比如说是区间[a,b],我们就将标记这个操作为最后一步操作。然后无论我们怎么处理剩下的序列，当我们回过头来最终执行替换[a,b]的操作时，都能保证[a,b]是正确的。也就是说，无论怎么折腾剩下的，最终都不会影响[a,b]。同理，如果我们再在剩下的target里中能找到匹配stamp的片段，比如说[c,d]时，我们就将其标记为倒数第二次操作，那么无论再之后的操作如何，最终都不会影响[c,d]以及[a,b]。

举个例子：
```
target:
XXXXabcabcdcdXXX

operations:
#N-0: XXXXXXXabcdXXXXX
#N-1: XXXXabcd***XXXXX
#N-2: XXXXXXX**abcdXXX
...
```
当从下往上执行最后三步替换之后，一定能保证序列最终中间的部分是期望的```abcabcdcd```.原因在于，后面的操作会覆盖前面的操作，所以前面的操作(比如说第N-1次)只需要负责后面操作（第Ｎ次）覆盖不到的那部分即可(i.e. abc)，其他的反正都会被后面的操作覆盖(i.e. d)，当前的替换即使不正确也没关系。

所以我们的策略是从上往下,只要能在当前序列中能找到匹配的，我们就将其置为星号。然后再剩下的序列里，只要能找到匹配的（其中如果序列中已经有星号则视为任意匹配），我们也立即将其置为星号。直至序列中所有的字符都已经置为星号为止。注意，最终的操作顺序则是反过来。


[Leetcode Link](https://leetcode.com/problems/stamping-the-sequence)::::::::::::::
Greedy/0948.Bag-of-Tokens/948.Bag-of-Tokens.cpp
::::::::::::::
class Solution {
public:
    int bagOfTokensScore(vector<int>& tokens, int P) 
    {
        sort(tokens.begin(),tokens.end());
        int i = 0;
        int j = tokens.size()-1;
        int score = 0;
        int result = 0;
        
        while (i<=j)
        {
            if (P>=tokens[i])
            {
                P-=tokens[i];
                i++;
                score++;
                result = max(result,score);
            }
            else if (score>0)
            {
                score--;
                P+=tokens[j];
                j--;
            }
            else
                break;
        }
        
        return result;
    }
};
::::::::::::::
Greedy/0948.Bag-of-Tokens/Readme.md
::::::::::::::
### 948.Bag-of-Tokens

本题的大体思路是，我们先将tokens排序，优先用手头的P去收购面值最小的tokens[i]，等到手头的P不够用了怎么办？我们将当前手头最小的token[i]兑换成1个point再去兑换面值最大的token[j]，这样空手套白狼，就将手头的P又凭空增加了token[j]．但代价有两个：第一是我们少了一个point；第二是我们失去未来收购面值最大的token[j]的机会．

所以，总体的最优策略已经出来了．那就是按照上面的方法，手头的Ｐ按从小到大能收购多少token那就收购，不能收购就卖掉面值减去1分（卖掉最小的token）换面值最大的，增值手头的Ｐ．然后重复上述过程．整个流程中，手头曾持有最多的token的数量，就是答案．

核心的代码如下：
```cpp
        while (i<=j)  // 保证手头待买入的i必须在待替换的j之前
        {
            if (P>=tokens[i])   // 仍然有钱买入
            {
                P-=tokens[i];
                i++;
                points++;
                result = max(result,points);
            }
            else if (points>0)  // 没钱买了，但是仍有分可以卖
            {
                points--;
                P+=tokens[j];
                j--;
            }
            else                // 既不能买，也不能卖，策略结束
                break;
        }
```


[Leetcode Link](https://leetcode.com/problems/bag-of-tokens)::::::::::::::
Greedy/0955.Delete-Columns-to-Make-Sorted-II/955.Delete-Columns-to-Make-Sorted-II.cpp
::::::::::::::
class Solution {
public:
    int minDeletionSize(vector<string>& A) 
    {
        int m = A.size();
        int n = A[0].size();
        vector<int>p(m, 0);
        int ret = 0;
        for (int j=0; j<n; j++)
        {
            vector<int>p2 = p;
            int flag = true;
            for (int i=1; i<m; i++)
            {
                if (p[i]==1) continue;
                if (p[i]==0)
                {
                    if (A[i][j]>A[i-1][j])
                        p2[i] = 1;
                    else if (A[i][j]<A[i-1][j])
                    {
                        flag = false;
                        break;
                    }                        
                }
            }
            if (flag==true)
                p = p2;
            else
                ret++;
        }
        return ret;

    }
};
::::::::::::::
Greedy/0955.Delete-Columns-to-Make-Sorted-II/Readme.md
::::::::::::::
### 955.Delete-Columns-to-Make-Sorted-II

我们考虑第一列。如果有任何相邻两行字符的关系是降序的，就意味着第一列我们必须删除。如果没有出现逆序，那么我们就可以保留第一列。

假设我们可以保留第一列，那么我们考虑第二列时，在判断相邻两行字符串A[i-1][0:1]和A[i][0:1]的关系时，如何高效地判断是否存在逆序呢？我们注意到，如果A[i-1][0]<A[i][0]，那么无论A[i-1][1]和论A[i][1]的关系如何，这两个字符串总是升序关系的。如果A[i-1][0]==A[i][0]，那么这两个字符串的关系就取决于A[i-1][1]和A[i][1]。至于A[i-1][0]>A[i][0]，那是不可能出现的，因为我们之前所做的任何删除列的操作就是为了保证每行的字符串是增序的。

所以我们维护一个数组p，p[i]=1表示第i行的字符串已经大于第i-1行的字符串，否则表示目前为止第i行的字符串完全等于第i-1行的字符串。这样我们只需要根据上一轮的p[i]、和这一列A[i-1][j]与A[i][j]两个字符的关系，就能判断是否维持了增序，并且记得更新p[i]。具体的是：
1. 如果p[i]=1，那么已经增序，不用判断。
2. 如果p[i]=0，且A[i-1][j]==A[i][j]，那么继续维持p[i]=0
3. 如果p[i]=0，且A[i-1][j]<A[i][j]，那么可以更新p[i]=1
4. 如果p[i]=0，且A[i-1][j]>A[i][j]，那么整个第j列都不能保留，同时p也不更新。
::::::::::::::
Greedy/0968.Binary-Tree-Cameras/968.Binary-Tree-Cameras.cpp
::::::::::::::
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
    // 0: uncovered
    // 1: with camera
    // 2: covered without camera
    int result;
public:
    int minCameraCover(TreeNode* root) 
    {
        result = 0;
        int temp = DFS(root);
        if (temp==0) result++;
        return result;
    }
    
    int DFS(TreeNode* node)
    {
        if (node==NULL) return 2;
        int left = DFS(node->left);
        int right = DFS(node->right);
        if (left==0 || right==0)
        {
            result++;
            return 1;
        }
        if (left==2 && right==2)
        {
            return 0;
        }
        return 2;
    }
};
::::::::::::::
Greedy/0968.Binary-Tree-Cameras/Readme.md
::::::::::::::
### 968.Binary-Tree-Cameras

本题粗看有点像house robber系列，考虑是否可以用ＤＰ来解，似乎应该设计三个状态：本身没有被cover(0),本身有camera(1)，本身没camera但是被邻近的camera给cover了(2)。基本的思路应该是，按照从上往下的顺序，后续节点的状态取决于前面的（若干个）节点状态。但是问题在于，依照从上往下的顺序的话，每个节点只能受父节点或者更高层的节点影响，显然是不合适的，因为它应该还应该受平行的兄弟节点的影响，而这个在线性的ＤＰ遍历中没法实现（因为你没法保证在考察这个node之前，它的兄弟node已经被更新过了）。

于是我们反向考虑，如果从下往上走会怎么样？这样，每个节点的状态可以取决于它的两个子节点。这个方案似乎有戏。为什么呢？假设我们从下往上依次更新，考察node时它的两个子节点的状态是已知的：

1.如果当前node的两个子节点只要有一个状态是0，那么该node必须设置为状态１，以保证两个子节点都被cover到。相应result++.

2.如果当前node的两个子节点都是状态２，那么按照从简的原则，当前node就可以不必安排camera，故状态可以设置为0。状态是0了没有被cover怎么办？不用担心，靠后续node的父节点来兜着就行，当前不用操心。

3.其他情况下，当前node都没有必要设置camera，并且当前node必然已经被某个子节点给cover了，所以我们设置node状态为2.

有了以上的传递关系，我们再考虑边界条件。边界条件就是叶子节点（最底层）。直觉告诉我们，所有的叶子节点没有必要设置camera，只要把camera放在它的父节点即可，这样肯定不亏（父节点装一个camera可以管两个子节点）。事实上，这个贪心法的思想（将最底层节点设置状态为２）是整个递归传递(从下往上更新)的根基。因此只有double check这个贪心的思想是对的，这个算法才是可行的。

最后需要注意的是，如果根节点最终设置状态为0了（此时程序结束），那么我还需要额外再在root上加一个camera以覆盖root。


[Leetcode Link](https://leetcode.com/problems/binary-tree-cameras)::::::::::::::
Greedy/0984.String-Without-AAA-or-BBB/984.String-Without-AAA-or-BBB_greedy.cpp
::::::::::::::
class Solution {
public:
    string strWithout3a3b(int A, int B) 
    {
        string ret;
        
        if (A>B)
        {
            int diff = A-B;
            for (int i=0; i<B; i++)
            {
                ret.push_back('a');
                if (diff>0)
                {
                    ret.push_back('a');
                    diff--;
                }
                ret.push_back('b');
            }
            for (int i=0; i<diff; i++)
                ret.push_back('a');
        }
        else
        {
            int diff = B-A;
            for (int i=0; i<A; i++)
            {
                ret.push_back('b');
                if (diff>0)
                {
                    ret.push_back('b');
                    diff--;
                }
                ret.push_back('a');
            }
            for (int i=0; i<diff; i++)
                ret.push_back('b');
        }
        
        return ret;
        
    }
};
::::::::::::::
Greedy/0984.String-Without-AAA-or-BBB/984.String-Without-AAA-or-BBB_pq.cpp
::::::::::::::
class Solution {
public:
    string strWithout3a3b(int A, int B) 
    {
        priority_queue<pair<int,char>>pq;
        pq.push({A,'a'});
        pq.push({B,'b'});

        string ret;
        while (!pq.empty())
        {
            if (pq.size()==1) 
            {
                int k = pq.top().first;
                if (k>2)
                    return "";
                else
                {
                    for (int i=0; i<k; i++)                    
                        ret.push_back(pq.top().second);
                    return ret;
                }
            }

            auto x = pq.top();
            pq.pop();
            auto y = pq.top();
            pq.pop();

            int k = min(1+x.first-y.first, 2);
            for (int i=0; i<k; i++)
                ret.push_back(x.second);
            ret.push_back(y.second);

            x.first-=k;
            y.first-=1;
            if (x.first!=0) pq.push(x);
            if (y.first!=0) pq.push(y);
        }
        return ret;
    }

};
::::::::::::::
Greedy/0984.String-Without-AAA-or-BBB/Readme.md
::::::::::::::
### 984.String-Without-AAA-or-BBB

#### 解法1： 贪心
假设A的频次比B多。因为题目保证总有答案，所以一定有```A<=B*2+2```.

我们可以先构建```ab ab ab...ab ab```，然后将多余的a，往每个ab段之间分别插入。还有更多的的a的话（最多两个）就再加在最后。

#### 解法2： 优先队列
对于这类题目，按照频次从大到小在优先队列里排列是个套路解法。

假设A的字符比B多。总体的算法思想是：

1. 每回合要取两种字符。否则这个回合取字符A的话，下一个回合A可能还是频次最多的字符，依然会取到A，就可能使得连续的A的数目超标。所以每回合加入一个B，就能够阻断两个回合的A相邻接。

2. 每回合中每种字符所取的数目，是为了使得剩下每种字符的数目尽量相等。（假想手头的A和B数目相等，那么之后的构造就非常容易，就不停ABAB...即可。）那么如何确定每个回合A取多少个呢？很简单，如果A的频次比B的频次多一个以上，就取两个A加一个B。这样做既可以避免连续的A超标，也最大限度地拉近了剩余两个字符的频次。

不断重复上述每个回合的操作。直到最后队列里只剩一种字符，并且那个字符的个数不超过2，那么直接加在ret最后即可。
::::::::::::::
Greedy/1024.Video-Stitching/1024.Video-Stitching.cpp
::::::::::::::
class Solution {
    static bool cmp(vector<int>&a, vector<int>&b)
    {
        if (a[0]!=b[0])
            return a[0]<b[0];
        else
            return a[1]>b[1];
    }
public:
    int videoStitching(vector<vector<int>>& clips, int T) 
    {
        if (T==0) return 0;
        sort(clips.begin(),clips.end(),cmp);        
        
        int far = 0;
        int i = 0;
        int count = 0;
                
        while (i < clips.size())
        {            
            int nextFar = far;
            while (i<clips.size() && clips[i][0]<=far)
            {
                nextFar = max(nextFar, clips[i][1]);
                i++;
            }
            count++;

            if (nextFar >= T)
                return count;
            else if (nextFar == far)
                return -1;                            
            far = nextFar;
        }        

        return -1;        
    }
};
::::::::::::::
Greedy/1024.Video-Stitching/Readme.md
::::::::::::::
### 1024.Video-Stitching

此题非常类似 45.Jump Game II，整体就是一个贪心的策略。略微的差异就是我们需要预先将这些clips排序，排序的原则就是左端点靠前的优先，其次右端点靠后的优先。

我们从第一个区间[0,right]开始考虑，将之后所有左端点位于right之前的clips都查看一遍（意味着与之前的区间有overlap），考察他们各自的右端点，取最大值得到能够推进到最远的位置farReach。这对应增加一个clip的操作（这个clip的右端点就是farReach）。然后更新right=farReach，再重复之前的操作，直到抵达target。

特别注意，如果更新farReach之后仍然等于right，就意味着没有其他clip与当前的区间能够overlap，应该及时返回-1，否则会死循环。


[Leetcode Link](https://leetcode.com/problems/video-stitching)::::::::::::::
Greedy/1040.Moving-Stones-Until-Consecutive-II/1040.Moving-Stones-Until-Consecutive-II.cpp
::::::::::::::
class Solution {
public:
    vector<int> numMovesStonesII(vector<int>& stones) 
    {
        sort(stones.begin(),stones.end());
        int n = stones.size();
        
        int a = (stones[n-2]-stones[0]+1)-(n-1);
        int b = (stones[n-1]-stones[1]+1)-(n-1);
        int y = max(a,b);
        
        int j = 0;
        int x = INT_MAX;
        for (int i=0; i<n; i++)
        {
            while (j<n && stones[j]-stones[i]+1<n)
                j++;
            if (j==n) break;
            
            int gap;
            if (stones[j]-stones[i]+1==n)
                gap = n-(j-i+1);
            else if (j-i==n-1)
                gap = 2;
            else
                gap = n-(j-i);
            
            x = min(x,gap);
        }
        
        return {x,y};
    }
};
::::::::::::::
Greedy/1040.Moving-Stones-Until-Consecutive-II/Readme.md
::::::::::::::
### 1040.Moving-Stones-Until-Consecutive-II

此题非常考验分析推理的能力，和编程技巧本身的关系倒是不大。

#### max move
要使得操作数尽可能地多，我们需要将end point的石头填充到下一个最靠外的空缺（但这个空缺本身不能是end point)。这样，每动一步只消灭一个最靠外的空缺，就能够使得这个move足够缓慢。举个例子：
```
OOXXXOO
1234567
```
我们的方案就是将7移动到5，消灭一个最靠外的空缺；然后将6移动到4，再消灭一个此时最靠外的空缺；然后将5移动到3，再消灭一个此时最靠外的空缺...以此类推，每移动一步，我们就消灭一个空缺，因此总移动的步数，就是被初始状态的石头所“内含”的空缺个数。

但是这个有一个特殊情况
```
OOXXXOXO
12345678
```
此时第一步不允许将8移动到7.根据要求8只能移动到5，然后转换为

```
OOXXOO
123456
```
此时我们就可以放心地用上运用之前的规律：需要移动的步数，就是此时"内含“的空缺数2。所以结论就是```stones[n-2]-stones[0]+1-(n-1)```

当然，上面的公式考虑的是移动右边的石头往左边填充。反过来也可以考虑移动左边的石头往右边填充：```stones[n-1]-stones[1]+1-(n-1)```

最终max move是两者取最大值。

#### min move
min move的基本思想是：我们尽量找初始状态下分布就相对集中靠拢的区域，尝试将其他的石头直接搬往这个区域的两边。举个例子：
```
OOXOOXXXO
123456789
```
我们发现1-5这个区间里面就有四个石头，显然直接将9搬到3就可以将区间1-5填满。所以这就提示我们寻找一个长度为n的sliding window，里面的石头越多越有利。理想情况下，我们只需要搬运```n-(这个长度为n的窗口里的石头数)```

但是同样有一个特殊情况
```
OOOOXXXXO
123456789
```
这个时候，虽然1-5这个区间里面有四块石头，是最理想的聚集区，但是，我们无法直接将9移动到5.这是因为这个“理想聚集区”的右端点5这个位置，目前是空缺，并且窗口的右侧只有一个石头。此时我们只有多操作一步，将1移动到6，形成
```
 OOOXOXXO
123456789
```
的局面，使得理想聚集区变成了[2-6]，然后再使用上面的规则:搬运```n-(这个长度为n的窗口里的石头数)```次,将9移动到5即可。事实上，这种特殊情况只有在n-1个石头连续排放的时候才会出现，因此操作数就是2。

所以，处理min move的逻辑是：
```
for i =0; i<n; i++   // 大框架是遍历窗口的左端的位置
{
  找到j，使得stones[j]-stones[i]+1>=n.
  if stones[j]-stones[i]+1==n
    说明从stones[i]到stones[j]这个窗口正好有n个位置，并且窗口的最右端是块石头，
    所以我们只要搬运```n-(这个长度为n的窗口里的石头数)```次，即```n-(j-i+1)```
  else 
    说明从stones[i]开始的长度为n的窗口，最右端不是石头
    if (j-i==n-1) 
      说明是分析到的特殊情况，n-1个石头连排，答案返回2
    else
      说明是一般的情况，所以我们只要搬运```n-(这个长度为n的窗口里的石头数)```次，即```n-(j-i)```
}
```


[Leetcode Link](https://leetcode.com/problems/moving-stones-until-consecutive-ii)::::::::::::::
Greedy/1054.Distant-Barcodes/1054.Distant-Barcodes_v1.cpp
::::::::::::::
class Solution {
public:
    vector<int> rearrangeBarcodes(vector<int>& barcodes) 
    {
        unordered_map<int,int>Map;
        for (auto x:barcodes)
            Map[x]+=1;
        
        vector<pair<int,int>>p;
        for (auto x: barcodes)
            p.push_back({Map[x], x});        
        sort(p.begin(), p.end());
        reverse(p.begin(), p.end());

        int n = barcodes.size();
        vector<int>ret(n);
        int i = 0;
        for (auto x: p)
        {
            ret[i] = x.second;
            i+=2;
            if (i>=n) i = 1;
        }
        return ret;            
    }
};
::::::::::::::
Greedy/1054.Distant-Barcodes/1054.Distant-Barcodes_v2.cpp
::::::::::::::
class Solution {
public:
    vector<int> rearrangeBarcodes(vector<int>& barcodes) 
    {
        unordered_map<int,int>Map;
        for (auto x:barcodes)
            Map[x]+=1;
        priority_queue<pair<int,int>>pq;
        for (auto x: Map)
            pq.push({x.second, x.first});

        vector<int>ret;
        while (!pq.empty())
        {
            if (pq.size()<2 && pq.top().first>1)
                return {};
                        
            vector<pair<int,int>>temp;
            int len = pq.size();
            for (int i=0; i<min(2, len); i++)
            {
                ret.push_back(pq.top().second);                
                if (pq.top().first!=1)
                    temp.push_back(pq.top());
                pq.pop();
            }

            for (auto x: temp)
            {
                x.first -= 1;
                pq.push(x);
            }
                
        }

        return ret;
    }
};
::::::::::::::
Greedy/1054.Distant-Barcodes/Readme.md
::::::::::::::
### 1054.Distant-Barcodes

#### 解法1：
将所有元素按照频次从大到小排列（所以相同的元素都会排在一起）。然后将这些元素先顺次填满答案序列index为奇数的位置，然后在顺次填满答案序列index为偶数的位置。这样就能尽可能地保证相同的元素不会排在一起了。

#### 解法2：
套路题：将所有数字按照频次放在一个优先队列里。每次从队列首取出两种不同的数字。频次减一之后再放回。

注：本题与```767.Reorganize String```完全一致。

[Leetcode Link](https://leetcode.com/problems/distant-barcodes)
::::::::::::::
Greedy/1055.Shortest-Way-to-Form-String/1055.Shortest-Way-to-Form-String.cpp
::::::::::::::
class Solution {
    int next[1001][26];
public:
    int shortestWay(string source, string target) 
    {
        int n = source.size();
        source = "#" + source;
        
        for (int k=0; k<26; k++)
            next[n][k] = -1;
        
        for (int i=n-1; i>=0; i--)      
        {
            for (int k=0; k<26; k++)
                next[i][k] = next[i+1][k];
            next[i][source[i+1]-'a'] = i+1;
            
        }
        
        int j = 0;
        int count = 1;
        for (int i=0; i<target.size(); i++)
        {               
            if (next[j][target[i]-'a'] != -1)
            {
                j =  next[j][target[i]-'a'];
            }
            else
            {
                if (j==0) return -1;
                j = 0;
                count++;
                i--;
            }                
        }
        return count;        
    }
};
::::::::::::::
Greedy/1055.Shortest-Way-to-Form-String/Readme.md
::::::::::::::
### 1055.Shortest-Way-to-Form-String

本题的最优策略就是贪心。我们总试图在source里找到一个subsequence去匹配target的前几个字符。匹配完若干个字符后，就从头再在source里找subsequence去匹配target的接下来的几个字符。直至把target全部匹配完，或者source完全无法提供匹配。

这样的解法有多种多样，但最优的写法类似792，采用状态机可以做到o(N)级别。

我们预先用o(26N)的时间来处理source。我们构建next[i][k]表示在source的第i个位置的下一个字符k在哪个位置。注意为了方便起见，我们将source调整为1-index。如果i的位置后面没有字符k，则令next[i][k]=-1.

接下来我们遍历target，用i表示我们在source里寻找target的第i个字符，用j表示我们当前位于source里的位置。假设我们在source的位置j找到了target[i-1]，那么target[i]就应该位于next[j][target[i]]。于是接下来我们需要更新
```
j = next[j][target[i]];
```
注意，如果此时j=-1，表示我们已经搜完了一遍source但是没有找到匹配target[i]，此时需要重置j=0再在source中搜一轮。如果j!=-1，那么说明target[i]已经找到，可以i+=1.

最终统计我们在source里面搜过了几轮，就是需要几个source的subsequence来拼接成target。
::::::::::::::
Greedy/1191.K-Concatenation-Maximum-Sum/1191.K-Concatenation-Maximum-Sum.cpp
::::::::::::::
class Solution {
    long M = 1e9+7;
public:
    int kConcatenationMaxSum(vector<int>& arr, int k) 
    {   
        if (k==1)
            return maxSubArrSum(arr)%M; 
        
        long arrSum = 0; 
        for (int i = 0; i < arr.size(); i++) 
        {
            arrSum += arr[i]; 
            arrSum %= M;
        }            
         
        int len = arr.size();
        for (int i=0; i<len; i++)
            arr.push_back(arr[i]);
        
        if (arrSum < 0)                     
            return maxSubArrSum(arr)%M;         
        else        
            return (maxSubArrSum(arr) + ((long)k - 2) * arrSum % M)%M;               
    }
    
    long maxSubArrSum(vector<int>arr) 
    { 
        long max_so_far = 0; 
        long max_ending_here = 0; 
  
        for (int i = 0; i < arr.size(); i++) 
        { 
            max_ending_here = max_ending_here + arr[i]; 
            max_ending_here %= M;
            if (max_ending_here < 0) 
                max_ending_here = 0; 
            if (max_so_far < max_ending_here) 
                max_so_far = max_ending_here;
        } 
        return max_so_far; 
    } 
};
::::::::::::::
Greedy/1191.K-Concatenation-Maximum-Sum/Readme.md
::::::::::::::
### 1191.K-Concatenation-Maximum-Sum

假设我们有一段maxSum Subarray长得像这个样子：```ATT...TTB```，其中A是arr的末尾的一段，B是arr的开头的一段，中间有若干个完整的arr（写作T）。那么我们一定可以推论出T>0（也就是原始的arr的数组和必须大于零）。否则的话，T<0显然是个累赘，拖累了```A+B```，肯定不会满足```ATT...TTB```是maxSum Subarray的假设（因为比不过```A+B```）。反过来说，如果T>0，那么maxSum Subarray也一定是长得是```ATT...TTB```的模式（中间有k-2个T）。那么怎么确定A和B呢？其实只要将arr重复两次，在这个新数组```arr2```里面，```AB```是一段尾首相接的subarray，很容易找出最大的maxsum subarry。

反之T<0的话，我们肯定不会让maxSum Subarray里面夹着任何完整的arr。所以maxSum Subarray就在```arr2```里面找就可以了。


[Leetcode Link](https://leetcode.com/problems/k-concatenation-maximum-sum)::::::::::::::
Greedy/1235.Maximum-Profit-in-Job-Scheduling/1235.Maximum-Profit-in-Job-Scheduling_v1.cpp
::::::::::::::
class Solution {
    static bool cmp(vector<int>&a, vector<int>&b)
    {
        return a[1] < b[1];
    }
public:
    int jobScheduling(vector<int>& startTime, vector<int>& endTime, vector<int>& profit) 
    {
        int n = startTime.size();
        vector<vector<int>>jobs;
        for (int i=0; i<n; i++)
            jobs.push_back({startTime[i],endTime[i],profit[i]});
        sort(jobs.begin(), jobs.end(), cmp);
        map<int,int>dp;
        dp[-1] = 0;

        int ret = 0;
        for (int i=0; i<n; i++)
        {            
            int ans = ret;
            auto iter = dp.upper_bound(jobs[i][0]);
            ans = max(ans, prev(iter,1)->second + jobs[i][2]);
            dp[jobs[i][1]] = ans;

            ret = max(ret, ans);
        }

        return ret;
    }
};
::::::::::::::
Greedy/1235.Maximum-Profit-in-Job-Scheduling/1235.Maximum-Profit-in-Job-Scheduling_v2.cpp
::::::::::::::
class Solution {
    static bool cmp(vector<int>&a, vector<int>&b)
    {
        return a[1] < b[1];
    }
public:
    int jobScheduling(vector<int>& startTime, vector<int>& endTime, vector<int>& profit) 
    {
        int n = startTime.size();
        vector<vector<int>>jobs;
        for (int i=0; i<n; i++)
            jobs.push_back({startTime[i],endTime[i],profit[i]});
        sort(jobs.begin(), jobs.end(), cmp);
        vector<pair<int,int>>dp;
        dp.push_back({-1,0});

        int ret = 0;
        for (int i=0; i<n; i++)
        {            
            int ans = ret;
            auto iter = upper_bound(dp.begin(), dp.end(), make_pair(jobs[i][0], INT_MAX));
            ans = max(ans, prev(iter,1)->second + jobs[i][2]);            
            dp.push_back({jobs[i][1], ans});

            ret = max(ret, ans);
        }

        return ret;
    }
};
::::::::::::::
Greedy/1235.Maximum-Profit-in-Job-Scheduling/Readme.md
::::::::::::::
### 1235.Maximum-Profit-in-Job-Scheduling

考虑到我们最终选取的区间必须是non-overlapping的，所以根据经验，我们按照endTime对区间进行排序。

假设我们按照如上排序后的顺序，遍历每个区间。我们会想，如果我们选择了第i个区间的话，那么我们就有机会更新这么一个记录```dp[endTime[i]]```，其中dp[t]表示截至t时刻的最大收益。显然，我们会有```dp[endTime[i]] = dp[startTime[i]]+profit[i]```.这像不像DP的思想？

当然，我们不可能在dp里存放每一个时刻的最大收益，我们只能离散化存放每一个endTime时刻的最大收益。也就是说，dp应该是一个哈希表。因此，可能dp记录里并没有startTime[i]，但我们只需要找到最后一个小于等于startTime[i]的时刻即可，记为```t```，对应的```dp[t]=val```。特别注意，我们试图记录```dp[endTime[i]] = val+profit[i]```的时候，前提条件是```val + profit[i]```一定要比dp里面最后时刻的收益还要大。也就是说，我们在dp里面只存放按收益递增的```time->profit```键值对。事实上，这也合情合理，如果t0<t1，且dp[t0]>dp[t1]的话，t1并没有必要塞入这个dp数组里面（既浪费了时间反而收益下降）。

于是我们的算法就呼之欲出了。对于当前的区间i，我们在dp数组（或者有序的map）里面考察在startTime[i]时刻之前的最大收益val，我们可以通过二分法得到。接下来，我们就有机会添加```dp[endTime[i]] = val+profit[i]```。注意，如果dp[endTime[i]]的最优解还有另外一个可能，就是不取第i个区间，这样的话dp[endTime[i]]=dp[endTime[i-1]]。

有了这样一个在时间和收益上都是递增的序列dp，我们就可以不断追加```dp[endTime[i]]```的记录，来创建更新的时刻的最大收益。


[Leetcode Link](https://leetcode.com/problems/maximum-profit-in-job-scheduling)
::::::::::::::
Greedy/1249.Minimum-Remove-to-Make-Valid-Parentheses/1249.Minimum-Remove-to-Make-Valid-Parentheses.cpp
::::::::::::::
class Solution {
public:
    string minRemoveToMakeValid(string s) 
    {
        stack<int>Stack;
        for (int i=0; i<s.size(); i++)
        {
            if (s[i]=='(')
            {
                Stack.push(i);
            }
            else if (s[i]==')')
            {
                if (Stack.empty())
                    s[i] = ' ';
                else
                    Stack.pop();
            }
        }
        while (!Stack.empty())
        {
            s[Stack.top()] = ' ';
            Stack.pop();
        }
        string t;
        for (auto ch:s)
            if (ch!=' ') t.push_back(ch);
        
        return t;

    }
};
::::::::::::::
Greedy/1249.Minimum-Remove-to-Make-Valid-Parentheses/Readme.md
::::::::::::::
### 1249.Minimum-Remove-to-Make-Valid-Parentheses

本题和 921.Minimum-Add-to-Make-Parentheses-Valid 本质相同，都是贪心的思想。只不过921只需要统计删除（或者增加）括号的个数，本题需要具体的把增删的位置指出来。

具体的说，依然是用一个变量count来表示unmatched left parenthesis。当统计到count<0的时候，意味着必须删除一个右括号，否则无论之后的字符串如何表现，当前的字符串永远不可能合法。那么删除哪个右括号呢？注意，其实可以有多个选择，但是本题只要输出一种，那么最简单的方法就是把当前的那个右括号删了。

当遍历完所有的字符，如果最后count>0，说明有未被匹配的左括号。此时意味着我们必须删除这些左括号。那么如何知道是哪些左括号未被匹配呢？显然，我们可以一开始使用栈来标记左括号的匹配情况，那么one pass之后栈里剩下的那些左括号就可以放心删除了。
::::::::::::::
Greedy/1253.Reconstruct-a-2-Row-Binary-Matrix/1253.Reconstruct-a-2-Row-Binary-Matrix.cpp
::::::::::::::
class Solution {
public:
    vector<vector<int>> reconstructMatrix(int upper, int lower, vector<int>& colsum) 
    {
        vector<int>a;
        vector<int>b;
        
        for (auto x: colsum)
        {
            if (x==2)
            {
                if (upper==0 || lower==0)
                    return {};
                a.push_back(1);
                b.push_back(1);
                upper--;
                lower--;
            }
            else if (x==0)
            {
                a.push_back(0);
                b.push_back(0);
            }
            else
            {
                if (upper>=lower && upper>0)
                {
                    a.push_back(1);
                    b.push_back(0);
                    upper--;
                }
                else if (lower>=upper && lower>0)
                {
                    a.push_back(0);
                    b.push_back(1);
                    lower--;
                }
                else
                    return {};
            }
        }
        
        if (upper!=0 || lower!=0)
            return {};
        else
            return {a,b};
    }
};
::::::::::::::
Greedy/1253.Reconstruct-a-2-Row-Binary-Matrix/Readme.md
::::::::::::::
### 1253.Reconstruct-a-2-Row-Binary-Matrix

容易知道，当colsum==0时，上下两行都要赋值0；当colsum==2时，上下两行都要赋值1.那么当colsum==1时，我们是否该任意给上一行或下一行赋值1呢？

这时有一个比较保守但有效的策略，那就是用upper和lower来统计上/下行分别还有多少个1还没有被使用。如果upper>lower，那么就优先给上一行赋值1，反之就优先给下一行赋值1.这样做是为了应对colsum==2的情况，保证上下行都尽量能存留有足够的1.举个例子，如果upper远多于lower，那么等lower降至0的时候，再碰到colsum==2的情况时就没有可行解了，之前全部的尝试都要作废。

如果采用了上述的保守的贪心策略，但最终还是遇到了colsum==2且lower为0的情况，那么说明了这个题就没有解，直接返回空就行了。

另外，本题有两个细节要注意。（1）当upper>=lower时，仍要检查upper是否大于0才可以给上一行赋值1. 反之同理。（2）当colsum全部走过一遍之后，仍需要保证此时upper==0 && lower==0 才能说明有解，也就是说初始状态下需要满足sum(colsum)==upper+lower。


[Leetcode Link](https://leetcode.com/problems/reconstruct-a-2-row-binary-matrix)::::::::::::::
Greedy/1272.Remove-Interval/1272.Remove-Interval.cpp
::::::::::::::
class Solution {
public:
    vector<vector<int>> removeInterval(vector<vector<int>>& intervals, vector<int>& toBeRemoved) 
    {
        vector<vector<int>>rets;
        for (auto v: intervals)
        {
            if (v[1]<=toBeRemoved[0] || v[0]>=toBeRemoved[1])
                rets.push_back(v);
            else
            {
                if (v[0] < toBeRemoved[0])
                    rets.push_back({v[0], min(v[1], toBeRemoved[0])});
                if (v[1] > toBeRemoved[1])
                    rets.push_back({max(v[0], toBeRemoved[1]), v[1]});
            }
        }
        return rets;
    }
};
::::::::::::::
Greedy/1272.Remove-Interval/Readme.md
::::::::::::::
### 1272.Remove-Interval

此题考查了对于两个区间相对关系的代码描述。假设有我们考察的区间是a，toBeRemoved的区间是b：
1. 如果a和b不相交：```if (a[1]<=b[0] || a[0]>=b[1]```，那么就将a加入结果。
2. 剩下的情况就是a和b相交。我们需要加入结果的是a在b前面的部分，和a在b后面的部分。前者需要```if (a[0]<b[0])```，然后加入```{a[0], min(a[1],b[0])}```；后者需要```if (a[1]>b[1])```，然后加入```{max(a[1],b[1]), a[1]}```；
::::::::::::::
Greedy/1288.Remove-Covered-Intervals/1288.Remove-Covered-Intervals.cpp
::::::::::::::
class Solution {
    static bool cmp(vector<int>&a, vector<int>&b)
    {
        if (a[0]!=b[0])
            return a[0]<b[0];
        else
            return a[1]>b[1];
    }
public:
    int removeCoveredIntervals(vector<vector<int>>& intervals) 
    {
        sort(intervals.begin(), intervals.end(), cmp);
        int i = 0;
        int count = 0;
        while (i<intervals.size())
        {
            count++;
            int j=i+1;
            while (j<intervals.size() && intervals[j][1]<=intervals[i][1])
                j++;
            i = j;
        }
        return count;
    }
};
::::::::::::::
Greedy/1288.Remove-Covered-Intervals/Readme.md
::::::::::::::
### 1288.Remove-Covered-Intervals

将所有的区间按照左端点排序，如果左端点相同的话，优先处理大区间。

我们顺序处理某个区间i，假设为[a,b]：后面的区间j的左端点一定都比a晚，如果j的右端点也比b早的话，那么j一定就是被包含在i里面的。我们可能会遇到若干个这样的j，但区间j会越来越靠右。直至发现j的右端点比b晚，说明j已经跑出了i的覆盖范围，那么我们就把j当作i，重复之前的操作。
::::::::::::::
Greedy/1326.Minimum-Number-of-Taps-to-Open-to-Water-a-Garden/1326.Minimum-Number-of-Taps-to-Open-to-Water-a-Garden.cpp
::::::::::::::
class Solution {
    static bool cmp(array<int,2>&a, array<int,2>&b)
    {
        if (a[0]!=b[0])
            return a[0] < b[0];
        else
            return a[1] > b[1];
    }
public:
    int minTaps(int n, vector<int>& ranges) 
    {
        vector<array<int,2>>intervals(n+1);
        for (int i=0; i<=n; i++)
            intervals[i] = {i-ranges[i], i+ranges[i]};
        sort(intervals.begin(), intervals.end(), cmp);

        if (intervals[0][0]>0) return -1;

        int i = 0;
        int far = 0;
        int count = 0;
        while (i<intervals.size())
        {                        
            count+=1;
            int nextFar = far;
            while (i<intervals.size() && intervals[i][0]<=far)
            {
                nextFar = max(nextFar, intervals[i][1]);
                i++;
            }            
            if (nextFar >= n)
                return count;
            if (nextFar == far)
                return -1;
            far = nextFar;
        }

        return -1;
    }
};
::::::::::::::
Greedy/1326.Minimum-Number-of-Taps-to-Open-to-Water-a-Garden/Readme.md
::::::::::::::
### 1326.Minimum-Number-of-Taps-to-Open-to-Water-a-Garden

此题的本质就是寻找数目最少的、互相重叠区间，使得最终能够覆盖[0,n]。这和```1024.Video-Stitching```非常类似。

我们将所有的区间按照左端点排列，如果左端点并列，那么优先选择范围大的区间。假设我们当前处理区间i，记作[a,b]，那么我们会查看i后面的、与i有交叠的区间，如果有多个，我们一定会从里面挑选右端点最远的那一个（记作区间j），因为j既能与i重叠、又能覆盖最远的地方，可以减少最终所选区间的数目。然后我们再考察区间j，重复之前的操作。

注意无解的情况有三种：1. 最右端的位置还没有推进到n，但是区间i之后已经没有任何其他区间能与之重叠；2. 如果考察完所有的区间，最右端的位置仍然无法推进到n，3. 第一个区间的左端点在0后面。
::::::::::::::
Greedy/1354.Construct-Target-Array-With-Multiple-Sums/1354.Construct-Target-Array-With-Multiple-Sums.cpp
::::::::::::::
class Solution {
public:
    bool isPossible(vector<int>& target) 
    {
        priority_queue<int>pq;
        for (auto x: target) pq.push(x);
        long long sum = 0;
        for (auto x: target) 
            sum += x;
        
        while (pq.top()!=1)
        {
            long long a = pq.top();
            pq.pop();
            long long others = sum - a;
            
            if (others == 0) return false;      
            if (a<=others) return false;
            long long b = a % others;
            if (b==0) b = others;
            
            sum = others+b;
            pq.push(b);
        }
        
        return true;        
    }
};
::::::::::::::
Greedy/1354.Construct-Target-Array-With-Multiple-Sums/Readme.md
::::::::::::::
### 1354.Construct-Target-Array-With-Multiple-Sums

本题的切入点是发现，每个回合得到的x只会越来越大。那么意味着我们在数组里设置的数也会越来越大。那么最后一轮完成构造target的时候，最后一个填入的数一定就是target里面的最大值a，这是一个已知量。那么假设最后一轮里，我们是把b替换成了a，那么b怎么求呢？
```
last round:   x x x x x a
last-1 round: x x x x x b
```
根据题意，最后一轮的操作里，a是通过```a = x+x+x+x+b```得到的，所以b其实就是a-others（其中others=x+x+x+x）。于是我们就可以把a替换成上一轮的b。

接着我们重复类似的操作，在当前的数组里找到最大的数字a，复原对应的b。直至最终所有的元素都是1或者发现计算出来的b不对劲（即b<=0）. 数据结构上用优先队列最为方便，每轮自动弹出数组里最大的元素。初步的代码如下
```cpp
while (pq.top()!=1)
{
    long long a = pq.top();
    long long others = sum - a;
    pq.pop();

    long long b = a - others;
    if (b<=0) return false;
    
    sum = others + b;
    pq.push(b);
}        
```

但是这段代码在处理这个case时遇到了TLE：```[1,1000000000]```. 我们发现如果依此还原每一步的话，这个数组的变化是：```[1,999999999] => [1,999999998] => [1,999999997] => ... ```朝最终答案前进的效率非常低。究其原因是每次a替换成b的时候，b明显仍然是整个数组里的最大值，如果将b放入优先队列中的话需要额外log(N)的操作来返回当前最大值，并不合算。

所以处理的手段是：如果我们能预判将a变成b后，重新放回优先队列的话让然是最大值的话，我们就不放入pq。因为我们发现，当a远远大于others时，每次变成b的过程，减去的都是固定不变的others。所以这些连续相同的减法，不如直接用除法更高效。所以改动后的代码是：
```cpp
while (pq.top()!=1)
{
    long long a = pq.top();
    long long others = sum - a;
    pq.pop();

    if (others ==0) return false;
    if (a - others <= 0) return false;
    long long b = a % others;
    
    sum = others + b;
    pq.push(b);            
}   
```        
但是以上还有一个bug。那就是b在取余运算之后的结果可能是零。但是题目中要求的所有元素的初始状态是1。这说明我们不能把b降到0。也就是说，如果a能被other整除，我们就只能把b降到others。
::::::::::::::
Greedy/1402.Reducing-Dishes/1402.Reducing-Dishes.cpp
::::::::::::::
class Solution {
public:
    int maxSatisfaction(vector<int>& satisfaction) 
    {
        int n = satisfaction.size();
        sort(satisfaction.begin(),satisfaction.end());
        reverse(satisfaction.begin(),satisfaction.end());
        
        int total = 0, presum = 0;
        int ret = INT_MIN;
        for (int i=0; i<n; i++)
        {
            presum += satisfaction[i];
            total += presum;
            ret = max(ret, total);
        }
        return max(0,ret);
        
    }
};
::::::::::::::
Greedy/1402.Reducing-Dishes/Readme.md
::::::::::::::
### 1402.Reducing-Dishes

两个突破点。首先我们肯定会把dishes按照满意度排序，满意度高的肯定放在后面做。其次，我们肯定会取若干个满意度最高的，关键就是取多少个而已。

于是我们就是要尝试取最高的1个，或者2个，或者3个,...,直至n个满意度最高的dishes，计算最后总得分，取最大值。

根据计算公式，显然每增加一道菜（按照满意度从高到底是第i个），总得分total就会增加的分值就是前i个菜的presum。
::::::::::::::
Greedy/1405.Longest-Happy-String/1405.Longest-Happy-String.cpp
::::::::::::::
class Solution {
public:
    string longestDiverseString(int a, int b, int c) 
    {
        priority_queue<pair<int,char>>pq;
        if (a!=0) pq.push({a,'a'});
        if (b!=0) pq.push({b,'b'});
        if (c!=0) pq.push({c,'c'});

        string ret;
        while (!pq.empty())
        {
            if (pq.size()==1) 
            {
                int k = min(2, pq.top().first);
                for (int i=0; i<k; i++)                    
                    ret.push_back(pq.top().second);
                return ret;
            }

            auto x = pq.top();
            pq.pop();
            auto y = pq.top();
            pq.pop();

            int k = min(1+x.first-y.first, 2);
            for (int i=0; i<k; i++)
                ret.push_back(x.second);
            ret.push_back(y.second);

            x.first-=k;
            y.first-=1;
            if (x.first!=0) pq.push(x);
            if (y.first!=0) pq.push(y);

            // cout<<ret<<endl;
        }
        return ret;
        
    }
};
::::::::::::::
Greedy/1405.Longest-Happy-String/Readme.md
::::::::::::::
### 1405.Longest-Happy-String

本题就是 984.String-Without-AAA-or-BBB 的升级版，只不过包含了三种字符。

数据结构不变：就是按照频次从大到小塞进优先队列。算法的核心思想：

1. 每个回合取频次最高的两种字符，即若干个A和一个B，目的是保证两个回合不会有相同的字符邻接在一起。

2. 取A的个数x取决于当前A的频次比B的频次多多少，最多取两个。即 ```x = min(2, freq(A)-freq(B))```. 目的是为了使得剩余的字符的频次尽量趋同。可以想象，如果剩下的字符频次都相同，那么只要不停输出abcabc...即可。

当队列里只有一种字符的时候，最多只能再输出该种字符的两个。

::::::::::::::
Greedy/1414.Find-the-Minimum-Number-of-Fibonacci-Numbers-Whose-Sum-Is-K/1414.Find-the-Minimum-Number-of-Fibonacci-Numbers-Whose-Sum-Is-K.cpp
::::::::::::::
typedef long long ll;
class Solution {
public:
    int findMinFibonacciNumbers(int k) 
    {
        vector<ll>a = {1,1};
        while (a.back() < k)
        {
            int n = a.size();
            a.push_back(a[n-1]+a[n-2]);
        }
        int ret = 0;
        while (k>0)
        {
            auto iter = upper_bound(a.begin(), a.end(), k) - 1;
            ret++;
            k-=*iter;
        }
        return ret;
    }
};
::::::::::::::
Greedy/1414.Find-the-Minimum-Number-of-Fibonacci-Numbers-Whose-Sum-Is-K/Readme.md
::::::::::::::
### 1414.Find-the-Minimum-Number-of-Fibonacci-Numbers-Whose-Sum-Is-K

直观上，我们构造出所有小于k的斐波那契数列的元素，然后依次贪心地从大到小选取即可（选完一个就从k里面减去它）。我们发现这个方法似乎总是成立的。

更严谨的证明可以见[这里](https://leetcode-cn.com/problems/find-the-minimum-number-of-fibonacci-numbers-whose-sum-is-k/solution/he-wei-k-de-zui-shao-fei-bo-na-qi-shu-zi-shu-mu-by/)
::::::::::::::
Greedy/1488.Avoid-Flood-in-The-City/1488.Avoid-Flood-in-The-City.cpp
::::::::::::::
class Solution {
public:
    vector<int> avoidFlood(vector<int>& rains) 
    {
        unordered_map<int,int>fill; // fill[x] is the last day that rain filled lake x        
        set<int>dryDays;         // the days that are dry, i.e. when we can drain
        vector<int>rets(rains.size(),1);
        
        for (int i=0; i<rains.size(); i++)
        {
            int x = rains[i];
            if (x==0)            
                dryDays.insert(i);            
            else
            {
                rets[i] = -1;
                if (fill.find(x)!=fill.end())
                {
                    auto iter = dryDays.lower_bound(fill[x]);
                    if (iter==dryDays.end()) return {};                    
                    rets[*iter] = x;  
                    dryDays.erase(*iter);                    
                }
                fill[x] = i;
            }            
        }        
        return rets;        
    }
};
::::::::::::::
Greedy/1488.Avoid-Flood-in-The-City/Readme.md
::::::::::::::
### 1488.Avoid-Flood-in-The-City

我们来分析一下贪心的策略会是什么。

我们如果在第i天遇到一个晴天，那么我们肯定会利用它来抽干某个湖。但是抽干哪个湖最合算呢？其实我们这时候是不确定的。如果某个湖在以后的日子里再也不会被下雨，那么我们在当前的晴天取抽水，并没有任何意义。所以我们只有在日后某个雨天时发现，某个湖已经充满、但是又要被下雨的时候，才会“回溯性”地决策在之前的某个晴天提前把这个湖抽干。因此，在晴天的时候，我们暂时不会做任何事情，只是默默把当前的日子加入一个集合dryDays。以后发现需要确定抽水日的时候，就从里面选。

我们如果在第i天遇到要对湖x下雨，我们必然会查看这个湖是否已经充满。
1. 如果尚未充满，我们就标记为充满```fill[x]=i```，但不着急做任何抽水的规划。
2. 如果湖x已经充满了，为了避免泛滥，我们一定要在第i天之前提前把湖x抽干。那么是哪一天最合适呢？首先，这一天一定是dryDays的集合中；其次一定要在fill[x]之后做（因为只有先充满了才能去抽干）。那么是否满足这两个条件的任意一天都可以呢？其实我们还希望越早越好。举个例子：
```       3   4   5   6   7   8   9
fillDays:     x       y       x   y
dryDays:          _       _
```
第8天的时候湖x可能会泛滥，所以我们必须在第5天或者第7天的时候把湖x抽干。但是如果我们选择在第7天取抽干湖x的话，当第9天y要泛滥的时候，我们就没有dry day去抽干湖y了。这就说明了，要抽干得趁早。在敲定了第5天抽干湖x之后，就把dryDays里去掉这一天。同时要更新fill[x]=8,即当天的下雨日。
::::::::::::::
Greedy/1505.Minimum-Possible-Integer-After-at-Most-K-Adjacent-Swaps-On-Digits/1505.Minimum-Possible-Integer-After-at-Most-K-Adjacent-Swaps-On-Digits.cpp
::::::::::::::
class Solution {
public:
    string minInteger(string num, int k) 
    {
        int n = num.size();
        vector<int>next(10,-1);
        vector<int>offset(10,0);
        for (int i=0; i<n; i++)
        {
            if (next[num[i]-'0']==-1)
                next[num[i]-'0'] = i;
        }

        vector<int>used(n, 0);
        string ret;
        auto ans = num;

        for (int i=0; i<num.size(); i++)
        {
            int j;
            for (j=0; j<10; j++)
            {
                if (next[j]==-1) continue;
                int d = next[j] + offset[j] - i;
                if (d <= k)
                {
                    k-=d;
                    break;
                }
            }
            ans[i] = num[next[j]];
            used[next[j]] = true;

            for (int k=0; k<10; k++)
            {
                if (next[k] < next[j])
                    offset[k]++;
            }

            int start = next[j];
            next[j] = -1;
            for (int k=start+1; k<n; k++)
            {
                if (used[k]==true)
                    offset[j]--;
                else if (num[k]==(j+'0'))
                {
                    next[j] = k;
                    break;
                }
            }            
        }
        return ans;
    }
};
::::::::::::::
Greedy/1505.Minimum-Possible-Integer-After-at-Most-K-Adjacent-Swaps-On-Digits/Readme.md
::::::::::::::
### 1505.Minimum-Possible-Integer-After-at-Most-K-Adjacent-Swaps-On-Digits

首先，我们要明确贪心的策略。我们要确定第i位的数字时，肯定是找它右边存在的（可以是它自己）、可以搬运过来的最小数字，来放在第i位，然后其余的数字往后顺移。每一步都依次类推。

为了避免我们在一个非常长的序列中遍历寻找这个“最小的数字”，一个比较常见的方法，就是根据题目的特点“只有10个数字种类”，提前把这个10个数字的排布都预处理，然后从小到大查看。事实上，我们不需要把每个数字的全部位置信息都找到，目前只需要找到数字j下一个出现的最近位置即可（后面会解释），我们标记为next[j]。

在一般情况下，我们如果在确定第i位数字的时候，假设通过贪心的策略找到可以搬运过来的右边的“最小数字”是j，那么我们需要swap的次数就是```next[j]-i```. 但是我们知道，这个计算式并不准确。这是因为：如果next[j]后面的某个数字在前面的操作中已经被移动到前面去了，那么相当于数字j的位置要后移。所以我们维护一个后移变量offset[j]来标记要后移多少。于是，真正需要swap的次数就是```next[j]+offset[j]-i```.

那么如何计算这个和维护这个offset数组呢？根据之前的描述，如果数字j需要前移到位置i，那么所有处在i和next[j]之前的数字都遇到了上面所说的情况。因此这些数字的offset都要加1. 实际上这个操作的代价很低，我们只需要遍历10个数字即可。
```
            for (int k=0; k<10; k++)
            {
                if (next[k] < next[j])
                    offset[k]++;
            }
```
注意到，offset[d]是配合next[d]来使用。即使i和next[j]之间某个数字d出现了多次，也不需要将offset[d]多次自增。

OK，现在我们已经把数字j从next[j]+offset[j]的位置搬到了i，那么我们需要更新next[j]。注意，其他数字的next都不需要变化，因为我们已经更新了必要的offset。如果找到新的next[j]呢？只要从之前的next[j]的位置往后无脑遍历就行，如果没有，那么next[j]标记为-1. 

此时最关键的一步是，对于数字j的offset已经失效了（记得offset[j]是配合next[j]使用的），针对这个新的next[j]，我们也需要更新offset[j]。这个怎么计算呢？我们之前说过，“新offset[j]”只能取决于有多少“新next[j]”右边的数字前移了。但是当前的offset[j]表示的是有多少“旧next[j]”右边的数字前移了。所以我们应该给新next[j]吐出一些offset来。这部分的数值是什么呢？就是处在新旧next[j]位置之间那些被前移的数字的个数。见下图，考察左边的j时，offset[j]=3；等到考察右边的j时，offset[j]=1。这中间的差值就是看两者之间有多少数字被前移了。
```
   j 4 3 X X j X 3 4
```
所以这就提醒我们，每次前移一个数字，都要在它所在的位置标记一下，方便我们在更新offset[j]的时候使用。这一部分的代码是：
```cpp
            int start = next[j];
            next[j] = -1;
            for (int k=start+1; k<n; k++)
            {
                if (used[k]==true)
                    offset[j]--;
                else if (num[k]==(j+'0'))
                {
                    next[j] = k;
                    break;
                }
            }          
```
这时我们需要理解一个事情。整个算法最外层的循环肯定是o(n)，上面的代码里面对于k的遍历看上去也是o(n)，总体的时间复杂度是不是o(n^2)。其实并不是。我们发现k的一次循环是从当前的j位置到下一个的j位置。如果以后的代码还会涉及到数字j，则这个k循环遍历的是从下一个j位置，到下下个j位置。所以无论i指向了数字j多少次，这个for循环总共只会完整地遍历一遍数组。考虑到只有10个数字，这个for循环只会完整地遍历数组10遍。所以说，并不是对于每次循环的i，上面的代码都会是跑o(n)级别。


总结一下算法：
1. 当前位置是i，我们在i的右边定位最小的、能够搬运到i的数字j，以及它的位置next[j]
2. 计算消耗swap的次数是next[j]+offset[j]-i，并在next[j]的位置标记used.
3. 对于所有处于i和next[j]之间的数字d，更新offset[d]+=1
4. 从next[j]往后找到下一个j所在的位置，更新next[j]，并统计两者之间used的个数m，更新offset[j]-=m.
::::::::::::::
Greedy/1520.Maximum-Number-of-Non-Overlapping-Substrings/1520.Maximum-Number-of-Non-Overlapping-Substrings.cpp
::::::::::::::
class Solution {
    static bool cmp(vector<int>&a, vector<int>&b)
    {
        return a[1]-a[0] < b[1]-b[0];
    }
public:
    vector<string> maxNumOfSubstrings(string s) 
    {
        vector<int>start(26,-1);
        vector<int>end(26,-1);
        for (int i=0; i<s.size(); i++) 
            if (start[s[i]-'a']==-1) start[s[i]-'a'] = i;
        for (int i=s.size()-1; i>=0; i--) 
            if (end[s[i]-'a']==-1) end[s[i]-'a'] = i;
        
        vector<vector<int>>intervals;
        for (int i=0; i<26; i++)
        {
            if (start[i]==-1) continue;
            int left = start[i], right = end[i];
            bool valid = true;
            for (int k=left; k<=right; k++)
            {
                if (start[s[k]-'a']==-1) continue;
                if (start[s[k]-'a'] < left)
                {
                    valid = false;
                    break;
                }
                right = max(right, end[s[k]-'a']);
            }
            if (valid) intervals.push_back({left, right});
        }
        
        sort(intervals.begin(), intervals.end(), cmp); 
        vector<int>flags(intervals.size(),1);

        for (int i=0; i<intervals.size(); i++)
        {
            if (flags[i]==0) continue;
            for (int j=i+1; j<intervals.size(); j++)
            {                
                if (flags[j]!=0 && intervals[i][0]>intervals[j][0] && intervals[i][1]<intervals[j][1])                
                    flags[j] = 0;                
            }
        }

        vector<string> ret ;
        for (int i=0; i<intervals.size(); i++)
            if (flags[i]) ret.push_back(s.substr(intervals[i][0], intervals[i][1]-intervals[i][0]+1));

        return ret;
    }
};
::::::::::::::
Greedy/1520.Maximum-Number-of-Non-Overlapping-Substrings/Readme.md
::::::::::::::
### 1520.Maximum-Number-of-Non-Overlapping-Substrings

考虑一个substring里面，如果出现了字母a，那么所有字母a必须出现在这个substring中，一个直接的想法是，这个substring必然要跨越a出现的所有位置。也就是说起始点必然是start['a']，截止点必然至少是end['a']（可能更靠后，下面会解释）。于是我们的注意力就集中在了26个substring上，他们就是以每个字母最早和最晚出现的位置为跨度的字符串。

但是显然并不是上面26种substring都是符合题目中第二个条件的。假设第一个a在第1个位置，最后一个a在第10个位置；但是同时有第一个b在第5个位置，最后一个b在第15个位置。所以当我们考虑以第一个a为起始的字符串时（left=1），此时[1,10]的区间内包含了字母b，所以我们不得不把区间的右端点后移，至少要移动到end['b']的位置。于是我们就一路往后遍历，不断拓展右边界，直到找到一个right，使得[left,right]所包含的所有字母的start/end都在这个区间内。

我们重复利用这个策略，就可以得到26种符合第二个条件的substring，他们的起始点分别是第一个a、第一个b、第一个c...所谓“符合第二个条件”就是题意中的 A substring that contains a certain character c must also contain all occurrences of c。注意，实现这个的时间复杂度是o(26N). 

接下来特别注意，这（最多）26种substring，要么互斥，要么互相嵌套，不可能出现部分相交的情况。（Why？假设有两个按照上述规则生成的合法区间ABC和BCD，而之所以BCD成立是因为BC本身必定不是合法的必须延伸到D，那么这与ABC本身已经合法相互矛盾。）对于互相嵌套的区间，根据题意 If there are multiple solutions with the same number of substrings, return the one with minimum total length. 我们再两两比较一下每对区间，将互相嵌套的大区间都排除即可。
::::::::::::::
Greedy/1525.Number-of-Good-Ways-to-Split-a-String/1525.Number-of-Good-Ways-to-Split-a-String.cpp
::::::::::::::
class Solution {
public:
    int numSplits(string s) 
    {
        int n = s.size();
        vector<int>left(n,0);
        vector<int>right(n,0);
        
        vector<int>count(26,0);
        int sum = 0;
        for (int i=0; i<s.size(); i++)
        {
            count[s[i]-'a']+=1;
            if (count[s[i]-'a']==1)
                sum+=1;
            left[i] = sum;
        }
        
        count.assign(26,0);
        sum = 0;
        for (int i=s.size()-1; i>=0; i--)
        {
            count[s[i]-'a']+=1;
            if (count[s[i]-'a']==1)
                sum+=1;
            right[i] = sum;
        }
        
        int ret = 0;
        for (int i=0; i<s.size()-1; i++)
        {
            if (left[i]==right[i+1])
                ret+=1;
        }
        return ret;
        

    }
};
::::::::::::::
Greedy/1525.Number-of-Good-Ways-to-Split-a-String/Readme.md
::::::::::::::
### 1525.Number-of-Good-Ways-to-Split-a-String

遍历p和q的分界点的位置i。我们可以提前用two pass计算出i左边的字符种类数left[i]，i右边的字符种类数right[i]。然后第三次遍历所有位置i，检查当```left[i]==right[i]```的时候，说明在此处划分字符串是符合要求的。
::::::::::::::
Greedy/1526.Minimum-Number-of-Increments-on-Subarrays-to-Form-a-Target-Array/1526.Minimum-Number-of-Increments-on-Subarrays-to-Form-a-Target-Array_Greedy.cpp
::::::::::::::
class Solution {
public:
    int minNumberOperations(vector<int>& target) 
    {
        int ret = 0, curHeight = 0;
        for (int i=0; i<target.size(); i++)
        {
            ret += max(0, target[i] - curHeight);
            curHeight = target[i];
        }
        return ret;
    }
};
::::::::::::::
Greedy/1526.Minimum-Number-of-Increments-on-Subarrays-to-Form-a-Target-Array/1526.Minimum-Number-of-Increments-on-Subarrays-to-Form-a-Target-Array_SegmentTree.cpp
::::::::::::::
class Solution {
    class SegTreeNode
    {
        public:
        SegTreeNode* left;
        SegTreeNode* right;
        int start, end;
        int info, pos;               
        SegTreeNode(int a, int b):start(a),end(b),info(0),pos(0),left(NULL),right(NULL){}
    };
    
    void init(SegTreeNode* node, int a, int b)  // init for range [a,b]
    {                        
        if (a==b)
        {
            node->info = target[a];
            node->pos = a;
            return;
        }
        int mid = (a+b)/2;
        if (node->left==NULL)
        {
            node->left = new SegTreeNode(a, mid);
            node->right = new SegTreeNode(mid+1, b);
        }
        init(node->left, a, mid);
        init(node->right, mid+1, b);
                
        if (node->left->info < node->right->info)
        {
            node->info = node->left->info;
            node->pos = node->left->pos;
        }
        else
        {
            node->info = node->right->info;
            node->pos = node->right->pos;
        }
    }
    
    pair<int,int> queryRangeMin(SegTreeNode* node, int a, int b)
    {        
        if (b < node->start || a > node->end )
        {
            return {INT_MAX, a}; // write your own logic
        }
        if (a <= node->start && b>=node->end)
        {
            return {node->info, node->pos};  // write your own logic
        }  
        
        auto L = queryRangeMin(node->left, a, b);
        auto R = queryRangeMin(node->right, a, b);
        
        if (L.first < R.first)
            return L;
        else
            return R;
    }    
    
    SegTreeNode* root;        
    vector<int> target;
    
public:
    int minNumberOperations(vector<int>& target) 
    {
        this->target = target;        
        int n = target.size();
        
        root = new SegTreeNode(0, n-1);
        init(root, 0, n-1);        
        
        return DFS(target, 0, 0, n-1);
    }
    
    int DFS(vector<int>& target, int base, int a, int b)
    {
        if (a>b) return 0;
        if (a==b) return target[a] - base;
                
        auto [val, pos] = queryRangeMin(root, a, b);        
        int sum = val - base;
        sum += DFS(target, val, a, pos-1);
        sum += DFS(target, val, pos+1, b);    
        return sum;
    }
};
::::::::::::::
Greedy/1526.Minimum-Number-of-Increments-on-Subarrays-to-Form-a-Target-Array/Readme.md
::::::::::::::
### 1526.Minimum-Number-of-Increments-on-Subarrays-to-Form-a-Target-Array

#### 解法1： 线段树
直观上说比较容易想到贪心的解决方案。第一步，我们肯定会挑选全局最小的元素target[i]，然后让整个数组都增加target[i]。此后任何操作都不可横跨整个数组。我们会选择递归处理[0:i-1]和[i+1:n-1]这两个区间。方法也类似，就是在[0:i-1]这个区间内找到最小的元素target[j]，让这段区间都增加至target[j]，既然我递归处理[0:j-1]和[j+1:i-1]这两个区间...

所以上述方法的难点在于快速挑选一段区间内的最小元素和它所在的位置。这种数据结构显然合适线段树来处理。我们构建segmentTree的数据结构，提供一个函数```[minVal, pos]=queryMin(start,end)```来满足需求。递归的代码就是：
```cpp
  void DFS(int a, int b, int cur)
    {
        if (a>b) return;
        auto x = queryTree(root, a, b);
        int val = x.first;
        int pos = x.second;
        if (val!=cur)
            ret += (val-cur);
        DFS(a, pos-1, val);
        DFS(pos+1, b, val);            
    }
```

#### 解法2： 贪心法
我们将target数组想象成连绵起伏的山峦。我们在上坡走的时候，每一步肯定都需要做“增加”的操作（相当于垒土造山）。但是在下坡走的时候实际上不需要任何操作，因为任何一个下坡的位置j，都可以找到一个对应的上坡位置i，可以认为在i位置通过“增加”操作成就了target[j]。举个例子：```1 3 4 2```。我们在处理j=3的时候，target[3]可以认为是在i=1的时候，对于区间[1:3]增加1而构造得到的。至于taget[1]=3本身，则可以认为是再通过一步对区间[1:2]增加1得到。这两个效果的叠加，等效于在i=1的位置，直接增加2，也就是target[1]相对于target[0]的增量。

同理，当我们走过“山谷”，重新上坡的时候，又要开始计数“增加”的操作。

::::::::::::::
Greedy/1535.Find-the-Winner-of-an-Array-Game/1535.Find-the-Winner-of-an-Array-Game.cpp
::::::::::::::
class Solution {
public:
    int getWinner(vector<int>& arr, int k) 
    {
        int curMax = arr[0];
        int times = 0;
        for (int i=1; i<arr.size(); i++)
        {
            if (arr[i]>curMax)
            {
                curMax = arr[i];
                times = 1;
            }
            else
            {
                times+=1;
            }
            if (times == k) return curMax;
        }
        return curMax;
    }
};
::::::::::::::
Greedy/1535.Find-the-Winner-of-an-Array-Game/Readme.md
::::::::::::::
### 1535.Find-the-Winner-of-an-Array-Game

本题模拟一个“打擂台”的机制。对于一个数A，如果它连续大于之后的K个数，那么它是winner。

如果数A在成为winner之前被数B压过，那么数A（以及被数A击败的数）是否要append到arr末尾来继续参与这场模拟呢？不需要。事实上没必要在考察完n个数之后继续模拟来找winner。因为我们在第一轮遍历这n个数的时候，必然会遇到一个全局的最大值Max，它之后的所有数（以及包括额外append到数组末尾的数）都不可能击败它。所以如果我们考察完n个数之后还没有确定winner，那么手头的最大值（就是全局最大值）就一定是winner，因为它一定会击败所有元素。

因此，我们只需要从头开始，模拟类似“打擂台”的机制，只要某个数连胜K场，就是winner。否则考察完n个数，手头的最大值（就是全局最大值）就是winner。

另外，如果K大于n的话，说明winner要击败所有元素（好几圈），那么同样说明winner一定就是全局最大值。
::::::::::::::
Greedy/1536.Minimum-Swaps-to-Arrange-a-Binary-Grid/1536.Minimum-Swaps-to-Arrange-a-Binary-Grid.cpp
::::::::::::::
class Solution {
public:
    int minSwaps(vector<vector<int>>& grid) 
    {
        int n = grid.size();
        vector<int>zeros(n);
        for (int i=0; i<n; i++)
        {
            int count = 0;
            for (int j=n-1; j>=0; j--)
            {
                if (grid[i][j]!=0)
                    break;
                count++;
            }
            zeros[i] = count;            
        }
        
        int count = 0;
        for (int i=0; i<n-1; i++)
        {
            int num = n-1-i;
            int j = i;
            for (; j<n; j++)
            {
                if (zeros[j]>=num)
                    break;
            }
            if (j==n) return -1;
            count += j-i;
            int temp = zeros[j];
            for (int k=j; k>i; k--)
                zeros[k] = zeros[k-1];
            zeros[i] = temp;
        }
        
        return count;
    }
};
::::::::::::::
Greedy/1536.Minimum-Swaps-to-Arrange-a-Binary-Grid/Readme.md
::::::::::::::
### 1536.Minimum-Swaps-to-Arrange-a-Binary-Grid

本题先进行一下转换。将每行末尾的零的个数统计一下，得到数组zeros，即zeros[i]表示第i行末尾的零的个数。我们的目标是将zeros通过adjacent swap操作，变成一个数组target，其中target[i]>=n-1-i. 求最小的操作数。

我们首先考虑target[0]，它的要求最高（需要有n-1个零）。我们考察所有的行，看看有哪些满足条件。加入有a和b两行满足条件，即zeros[a]>=n-1，zeros[b]>=n-1，那么我们应该选择将哪一行挪到第0行的位置上来呢？我们不妨举个例子：
```
X X X a X b X
```
如果我们选择将第b行提到最前面，那么需要操作5次得到
```
b X X X a X X   (1)
```
如果我们选择将第a行提到最前面，那么需要操作3次得到
```
a X X X X b X   (2)
```
别停，我们如果对(2)继续操作1次（将b前移一位）能得到
```
a X X X b X X   (3)
```
我们比较一下(1)和(3)。我们发现对于第0行的处理，两种方案都满足条件。唯一的区别是，第一种方案第4行是zeros[a]，第二种方案第4行是zeros[b]。但是由于zeros[a]和zeros[b]都是大于等于n-1的，而除了target[0]之外的target[i]的要求都不到n-1，所以这两行（a和b）对于以后的安排而言都是“溢价”的，即“价值”是没有区别的。但是第一种方案需要5次操作，第二种方案只需要4次操作。

所以我们得到一个贪心的结论：当我们处理target[i]时需要找某个zeros[j]>=n-1-i时，只要从i开始往后顺次查找第一个满足zeros[j]>=n-1-i的位置即可。然后将j所对应的行提前到第i行。然后处理target[i+1]，不断重复。



::::::::::::::
Greedy/1540.Can-Convert-String-in-K-Moves/1540.Can-Convert-String-in-K-Moves.cpp
::::::::::::::
class Solution {
public:
    bool canConvertString(string s, string t, int k) 
    {
        if (s.size()!=t.size()) return false;
        int n = s.size();
        vector<int>count(26);
        
        for (int i=0; i<n; i++)        
            count[(t[i]-s[i]+26)%26] += 1;                
        
        int ret = 0;
        for (int i=1; i<26; i++)        
        {
            if (count[i]>=1)
                ret = max(ret, (count[i]-1)*26+i);        
        }
        return ret<=k;
    }
};
::::::::::::::
Greedy/1540.Can-Convert-String-in-K-Moves/Readme.md
::::::::::::::
### 1540.Can-Convert-String-in-K-Moves

我们首先计算每个位置上字符需要自增的次数，也就是s[i]-t[i]之差。假设如果有两个位置都需要自增5，那么最终的方案是我们只能先给其中一个位置自增5（在第5次move时操作），另一个位置则通过自增5+26=31（在第31次move时操作））来实现转换。

所以我们的算法是，遍历每个位置，然后统计count[k] (k=1,2...,25)，表示需要自增k次的位置有几个。如果有若干个，那么它们分别需要在第k次、第k+26次、第k+52次...来实现。最终的答案就是所有位置里，需要操作的最晚的那一次。
::::::::::::::
Greedy/1541.Minimum-Insertions-to-Balance-a-Parentheses-String/1541.Minimum-Insertions-to-Balance-a-Parentheses-String.cpp
::::::::::::::
class Solution {
public:
    int minInsertions(string s) 
    {
        int count = 0;
        int ret = 0;
        for (int i=0; i<s.size(); i++)
        {
            if (s[i]=='(')
                count++;
            else
            {
                if (i+1<s.size() && s[i+1]==')')
                {
                    count--;
                    i++;
                }
                else
                {
                    count--;
                    ret++;
                }
            }
            if (count<0)
            {
                ret++;
                count=0;
            }
        }
        return ret + count*2;
    }
};
::::::::::::::
Greedy/1541.Minimum-Insertions-to-Balance-a-Parentheses-String/Readme.md
::::::::::::::
### 1541.Minimum-Insertions-to-Balance-a-Parentheses-String

本题和 ```921 Minimum Add to Make Parentheses Valid```本质一样。区别只在于一个左括号必须和两个连续的右括号匹配。我们仍然可以沿用贪心法的思想，用count来记录未被匹配的左括号的数目。变化在于：
1. 我们需要连续两个右括号，才能试图与之前的一个左括号对消。如果不存在连续的两个右括号，我们必须先手工增加一个右括号，即```ret++```，然后再试图匹配左括号消减count。
2. 如果最终有剩余未被匹配的左括号，我们需要增加两倍数目的右括号与之对应，即```ret+=count*2```.
::::::::::::::
Greedy/1564.Put-Boxes-Into-the-Warehouse-I/1564.Put-Boxes-Into-the-Warehouse-I.cpp
::::::::::::::
class Solution {
public:
    int maxBoxesInWarehouse(vector<int>& boxes, vector<int>& warehouse) 
    {
        sort(boxes.begin(), boxes.end());
        reverse(boxes.begin(), boxes.end());
        
        int count = 0;
        int j = 0;
        for (int box: boxes)
        {
            if (j==warehouse.size()) break;
            if (box <= warehouse[j])
            {
                j++;
                count++;
            }                
        }
        return count;
    }
};
::::::::::::::
Greedy/1564.Put-Boxes-Into-the-Warehouse-I/Readme.md
::::::::::::::
### 1564.Put-Boxes-Into-the-Warehouse-I

这是一道经典题，比较简单的贪心策略是：尽量将最外的仓库（即index较小的位置，它能支持最大的高度）留给高的盒子，否则会浪费空间。

具体的做法是：从左到右遍历cell。对于每个cell，从高到低寻找能fit的盒子，凡是不fit的盒子就都舍弃（他们以后肯定放不进任何cell），如果发现某个盒子能fit，就装进去。然后处理第二个cell，以此类推。
::::::::::::::
Greedy/1567.Maximum-Length-of-Subarray-With-Positive-Product/1567.Maximum-Length-of-Subarray-With-Positive-Product.cpp
::::::::::::::
class Solution {
public:
    int getMaxLen(vector<int>& nums) 
    {
        int ret = 0;

        for (int i=0; i<nums.size(); i++)
        {
            if (nums[i]==0) continue;
            int j = i;
            int count = 0;
            int firstNeg = -1;

            while (j<nums.size() && nums[j]!=0)
            {
                count += (nums[j]<0);
                if (count % 2 ==0)
                    ret = max(ret, j-i+1);
                else if (firstNeg!=-1)
                    ret = max(ret, j-firstNeg);

                if (firstNeg==-1 && nums[j]<0)
                    firstNeg = j;
                j++;
            }
            i = j;
        }
        return ret;
    }
};
::::::::::::::
Greedy/1567.Maximum-Length-of-Subarray-With-Positive-Product/Readme.md
::::::::::::::
### 1567.Maximum-Length-of-Subarray-With-Positive-Product

首先，这个subarray里面不能含有0元素。因此我们会将整个数组分拆为若干个被0间隔的区域，每个区域单独处理。

接下来在每一个区域里，我们想要找一段最长的subarray，使得里面包含的负数的个数必须是偶数（可以为0）。假设我们从区域的起点i开始遍历到j的位置，经过的负数有偶数个，那么[i:j]这个subarray就是符合条件的。反之，如果从起点i开始遍历到j的位置时，经过的负数有奇数个，那么我们必然会寻找第一次出现负数的位置（记做k），那么[k+1:j]这个subarray就是符合条件的。总之，如果以j为subarray的右边界，那么左边界只有两种情况：要么就是i，要么就是k+1，取决于到j为止时总共出现了多少次负数。

因为根据j来确定左边界可以用o(1)时间完成，所以本题的时间复杂度是o(N).
::::::::::::::
Greedy/1578.Minimum-Deletion-Cost-to-Avoid-Repeating-Letters/1578.Minimum-Deletion-Cost-to-Avoid-Repeating-Letters.cpp
::::::::::::::
class Solution {
public:
    int minCost(string s, vector<int>& cost) 
    {
        int ret = 0;
        for (int i=0; i<s.size();)
        {
            int j=i;
            int maxValue = 0;
            int sum = 0;
            while (j<s.size() && s[j]==s[i])
            {
                sum += cost[j];
                maxValue = max(maxValue, cost[j]);
                j++;
            }
            ret += sum - maxValue;
            i = j;
        }
        return ret;

    }
};
::::::::::::::
Greedy/1578.Minimum-Deletion-Cost-to-Avoid-Repeating-Letters/Readme.md
::::::::::::::
### 1578.Minimum-Deletion-Cost-to-Avoid-Repeating-Letters

本题其实只需贪心即可。在连续的相同字母中，只保留cost最大的一个，其余cost较小的都可以选择删除。
::::::::::::::
Greedy/1585.Check-If-String-Is-Transformable-With-Substring-Sort-Operations/1585.Check-If-String-Is-Transformable-With-Substring-Sort-Operations.cpp
::::::::::::::
class Solution {
public:
    bool isTransformable(string s, string t) 
    {
        int n = s.size();
        vector<deque<int>>pos(10);
        
        for (int i=0; i<n; i++)
        {            
            pos[s[i]-'0'].push_back(i);
        }

        for (int i=0; i<n; i++)
        {
            int num = t[i]-'0';            
            if (pos[num].empty()) return false;
            int idx = pos[num].front();
                        
            for (int digit = 0; digit < num; digit++)
                if (!pos[digit].empty() && pos[digit].front() < idx)
                    return false;
            
            pos[num].pop_front();
        }
        
        return true;        
    }
};
::::::::::::::
Greedy/1585.Check-If-String-Is-Transformable-With-Substring-Sort-Operations/Readme.md
::::::::::::::
### 1585.Check-If-String-Is-Transformable-With-Substring-Sort-Operations

对于一个区间，操作之后最小的数字会跑到区间的最前面；如果把区间缩小一点，操作之后最小的数字依然会跑到这个区间的最前面。可见区间的大小，其实就是影响着最小数字的“迁移程度”。因此我们总结出，本题的操作，本质上就是“冒泡”：允许任何一个数字可以和它前面比它大的数字交换，并且能够连续操作，前移到所能到达的任何位置。

分析下面这个例子
```
   0 1 2 3 4 5 6 7
s: X X X 5 X X X X 
t: 5 X X X X X X X 
```
对于目标串t的第一个5会对应着s中的哪一个5呢？显然易见，我们会从s里面找出现的第一个5的位置和它配对，也就是idx=3位置。那么s[3]要挪到[0]的位置需要满足什么条件呢？那就是s[3]前面的数字不能有小于5的，否则s[3]这个数字就无法顺利挪到第一个位置。

这就提示我们预处理所有的10种数字，将它们出现的idx按照顺序放在pos[digit]里面。此时我们只要查看pos[0]~pos[4]这些数字的第一次出现的位置，如果这个位置早于3，那么就违反了上面的要求，s[3]无法迁移到第一个位置。

我们再接下来看一位：
```
   0 1 2 3 4 5 6 7
s: X X X 5 X 6 X X 
t: 5 6 X X X X X X 
```
对于目标串t的第二位上的6，假设对应的s[5]上的6。根据之前的推理，钥匙s[5]能推进到第二位，所有小于6的数字都不能出现在idx=5的左边阻挡它的前进，除非是之前处理过的那个s[3]=5，因为它已经被迁移到了t[0]的位置，不影响s[5]=6的前进。所以我们只需要将pos[5]记载的第一个位置3提前移出，查看此时pos[0]~pos[5]这些数字的第一次出现的位置。如果这些位置都大于5，就不会阻挡s[5]=6的前进，否则就无法实现目标。

所以这种算法的时间复杂度是O(N*C)，其中C就是10.

本题有一个条件更宽松的原题：https://codeforces.com/contest/1187/problem/D 其中没有数字只有10种的限制。那么上述的方法就会退化成o(N^2)。我们可以用BIT或者线段树来改进。

还是基于之前的结论：遍历t[j]，找到对应的s[i]，想要s[i]顺利到j的位置，需要所有小于s[i]的数字的idx不能早于i。所以我们可以给这些数字（枚举所有小于s[i]的数字、不包括已经处理过的）都更新一个leftLimit的限制。随着不断处理s[i]，这个数字的leftLimit会不断更新，趋势上会越来越严格（即越来越靠右）。如果发现对于某个s[i]而言，我们期望它移到的位置j要早于它被赋予的leftLimit，就注定s[i]无法实现移动，就返回false。

这看上去依然是o(N^2)的方法。但可以优化的地方在于，我们将所有的数字排序之后，更新所有小于s[i]的数字的leftLimit，这是一个区间操作。可以用线段树或者BIT来化简到log(N)的时间复杂度。
::::::::::::::
Greedy/1653.Minimum-Deletions-to-Make-String-Balanced/1653.Minimum-Deletions-to-Make-String-Balanced.cpp
::::::::::::::
class Solution {
public:
    int minimumDeletions(string s) 
    {
        int n = s.size();

        vector<int>pre(n);        
        pre[0] = (s[0]=='b');
        for (int i=1; i<n; i++)
            pre[i] = pre[i-1] + (s[i]=='b');
        
        vector<int>suf(n);
        suf[n-1] = (s[n-1]=='a');
        for (int i=n-2; i>=0; i--)
            suf[i] = suf[i+1] + (s[i]=='a');
        
        int ret = min(pre[n-1], suf[0]);
        for (int i=0; i<n-1; i++)
            ret = min(ret, pre[i] + suf[i+1]);
        
        return ret;
    }
};
::::::::::::::
Greedy/1653.Minimum-Deletions-to-Make-String-Balanced/Readme.md
::::::::::::::
### 1653.Minimum-Deletions-to-Make-String-Balanced

注意到最终变换后的形式是"aaaa....bbbbb"，关键点就是这个ab的分界处。所以我们遍历这个分界点：假设最终状态是[0:i]都变成'a'，[i+1:n-1]都变成'b'，那么所需要的操作数，就是[0:i]中'b'的个数加上[i+1:n-1]中'a'的个数。对于这两个量，我们可以提前two pass预处理以前缀和/后缀和数组的形式存下来，即```ret[i] = pre[i]+suf[i+1]```。

本题有两个corner cases，分别是把所有的字母变成a或者b，对应的是pre[n-1]和suf[0]，这需要单独考察。
::::::::::::::
Greedy/1657.Determine-if-Two-Strings-Are-Close/1657.Determine-if-Two-Strings-Are-Close.cpp
::::::::::::::
class Solution {
public:
    bool closeStrings(string word1, string word2) 
    {
        unordered_set<char>Set1;
        unordered_set<char>Set2;

        vector<int>a(26,0);
        vector<int>b(26,0);
        for (auto ch:word1)
        {
            a[ch-'a']+=1;
            Set1.insert(ch);
        }            
        for (auto ch:word2)
        {
            b[ch-'a']+=1;
            Set2.insert(ch);
        }
            
        sort(a.begin(), a.end());
        sort(b.begin(), b.end());
        return a==b && Set1==Set2;        
    }
};
::::::::::::::
Greedy/1657.Determine-if-Two-Strings-Are-Close/Readme.md
::::::::::::::
### 1657.Determine-if-Two-Strings-Are-Close

第一条规则说明单纯的乱序不影响判断两个字符串是否close。只要两个字符串排序后是一样的，那么就是close。

第二条规则说明两个问题：首先两个字符串必须包含相同种类的字母，因为规则二本身无法创造出新的字母。如果两个字符串的字母种类不同，那么规则二是无法使得他们一致的（即使是乱序）。其次，同一个字符串中不同种类的字符可以互换彼此的频次，因此必然要求这两个字符串的字母频次分布也一致。因此一个close的必要条件就是将两个字符串的频次数组都分别排序，查验它们是否相同。
::::::::::::::
Greedy/1664.Ways-to-Make-a-Fair-Array/1664.Ways-to-Make-a-Fair-Array.cpp
::::::::::::::
class Solution {
public:
    int waysToMakeFair(vector<int>& nums) 
    {
        int n = nums.size();
        vector<int>leftEven(n+1);
        vector<int>leftOdd(n+1);
        int rightEven = 0, rightOdd = 0;
        nums.insert(nums.begin(),0);
        for (int i=1; i<=n; i++)
        {
            if (i%2==0)
                rightEven+=nums[i];
            else
                rightOdd+=nums[i];
            leftEven[i] = rightEven;
            leftOdd[i] = rightOdd;
        }
        
        rightEven = 0, rightOdd = 0;
        int ret = 0;
        for (int i=n; i>=1; i--)
        {
            if (leftEven[i-1]+rightOdd == leftOdd[i-1]+rightEven)
                ret++;
                
            if (i%2==0)
                rightEven+=nums[i];
            else
                rightOdd+=nums[i];            
        }
        return ret;
        
    }
};
::::::::::::::
Greedy/1664.Ways-to-Make-a-Fair-Array/Readme.md
::::::::::::::
### 1664.Ways-to-Make-a-Fair-Array

本题的入手点很直观，就是遍历删除的位置i。我们可以提前计算出左边的奇数位数字之和leftOdd[i-1]、左边的偶数位数字之和leftEven[i-1]、右边的奇数位数字之和rightOdd[i+1]、右边的偶数位数字之和rightEven[i+1]。因为删除掉第i位之后，rightOdd[i+1]其实对应的数字都变成了偶数位，而rightEven[i+1]对应的数字都变成了奇数位。所以删去第i位后，我们判断全体奇数位之和是否等于偶数位之和时，判据应该是```leftEven[i-1]+rightOdd[i+1]==leftOdd[i-1]+rightEven[i+1]```.
::::::::::::::
Greedy/1665.Minimum-Initial-Energy-to-Finish-Tasks/1665.Minimum-Initial-Energy-to-Finish-Tasks.cpp
::::::::::::::
class Solution {
    static bool cmp(vector<int>&a, vector<int>&b)
    {
        if (a[1]-a[0] == b[1]-b[0])
            return a[1]<b[1];
        else
            return a[1]-a[0]<b[1]-b[0];
    }
public:
    int minimumEffort(vector<vector<int>>& tasks) 
    {
        sort(tasks.begin(), tasks.end(), cmp);        
        int start = 0;
        for (auto x: tasks)
        {            
            start = max(start+x[0], x[1]);     
        }
        return start;        
    }
};
::::::::::::::
Greedy/1665.Minimum-Initial-Energy-to-Finish-Tasks/Readme.md
::::::::::::::
### 1665.Minimum-Initial-Energy-to-Finish-Tasks

我们令每个任务的actual cost属性为a，mimimum energy to start属性为m。我们先考虑：最优解T必然大于等于所有任务的a属性之和。所以即使任务次序任意打乱，总能保证做每个任务时都能有足够的energy被消耗。但是属性m要求某些任务必须在存留能量很高的时候才能被启动。所以一个比较自然的贪心想法就是将所有的任务按照属性b排序，优先做属性m较大的任务，这样可以最大程度保证它能启动。

举个例子，如果按照属性b的次序排序样例2：[1,3],[2,4],[8,9],[10,11],[10,12]。我们从最终状态能量为0开始，逆推最初所需要的能量。我们可以写出这样的计算式：
```cpp
int ret = 0;
for (int i=0; i<n; i++)
  ret = max(ret+tasks[i][0], tasks[i][1])``` //前者是考虑完成该任务需要消耗的能量，后者是考虑启动该任务前的能量下限
```
但结果发现结果是33，并非是最优的32. 那么32是怎么得到的呢？实际的最优操作顺序是（从后往前）：[8,9],[10,11],[10,12],[2,4],[1,3]

我们思考一下为什么需要把[1,3]的属性a和m都很小，但为什么会作为最先启动的任务？我们很容易发现它的m-a其实是所有任务里最大的。这是不是暗示了我们需要把任务按照m-a来排序呢？我们来实验一下：假设任务1(a1,m1)和任务2(a2,m2)，有m2-a2>m1-a1，我们来看一下分别用两种策略所得到的倒推最小初始能量的效果区别：
1. 倒推时先1后2之后的初始能量：T1 = max(max(a1, m1) + a2, m2) = max(max(a1+a2, m1+a2), m2) 
2. 倒推时先2后1之后的初始能量：T2 = max(max(a2, m2) + a1, m1) = max(max(a2+a1, m2+a1), m1)

因为m2-a2>m1-a1，所以m1+a2<m2+a1，所以一定有 max(a1+a2, m1+a2) < max(a2+a1, m2+a1)。 至此我们整理一下
```
前提: m2-a2>m1-a1
令: x1 = max(a1+a2, m1+a2)   (1)
    x2 = max(a2+a1, m2+a1)   (2)
则: T1 = max(x1, m2)         (3)
    T2 = max(x2, m1)         (4)
结论: 比较(1)(2)得 x1 < x2    (5)
      由(2)得 x2 > m2        (6)
```
如果m2 < m1，那么由(3)(4)显然得到T1 < T2. 

如果m2 > m1，那么有(6)得到 x2 > m2 > m1，所以 T2 = max(x2, m1) = x2。因已知 x2>x1 (5) 并且 x2>m2 (6)，所以 T2 = x2 > T1.

总之无论如何都有T1<T2，方案1更优。所以我们有结论：如果两个任务相邻，我们肯定会把m-a较小的认为放在倒推序列的前面。把这个结项想象成冒泡排序的规则，通过它我们就可以得到一个序列，使得通过倒推法得到的初始能量最小。

PS：有一种“直观”的解释，为什么要根据 m - a排序？因为做这件任务之前，至少有能量m，减去a的消耗，那么做完之后一定保证剩余能量至少有m-a。我们自然希望做完任务之后的剩余能量越大越好，这样好做下一个任务。所以我们自然就会优先取做那些“保证剩余能量”更大的任务。
::::::::::::::
Greedy/1671.Minimum-Number-of-Removals-to-Make-Mountain-Array/1671.Minimum-Number-of-Removals-to-Make-Mountain-Array_v1.cpp
::::::::::::::
class Solution {
public:
    int minimumMountainRemovals(vector<int>& nums) 
    {
        int n = nums.size();
        vector<int>left(n,1);
        vector<int>right(n,1);
        
        for (int i=0; i<n; i++)            
            for (int j=0; j<i; j++)
            {
                if (nums[j]<nums[i])
                    left[i] = max(left[i], left[j]+1);                
            }
        
        for (int i=n; i>=0; i--)            
            for (int j=i+1; j<n; j++)
            {
                if (nums[j]<nums[i])
                    right[i] = max(right[i], right[j]+1);                
            }
        
        int count = 0;
        for (int i=0; i<n; i++)
        {
            if (left[i]>=2 && right[i]>=2)
                count = max(count, left[i]+right[i]-1);
        }
        
        return n-count;
    }
};
::::::::::::::
Greedy/1671.Minimum-Number-of-Removals-to-Make-Mountain-Array/1671.Minimum-Number-of-Removals-to-Make-Mountain-Array_v2.cpp
::::::::::::::
class Solution {
public:
    int minimumMountainRemovals(vector<int>& nums) 
    {
        int n = nums.size();
        vector<int>left(n);
        vector<int>right(n);
        vector<int>arr;
        
        for (int i=0; i<n; i++)
        {
            if (arr.size()==0 || nums[i]>arr.back())
            {
                arr.push_back(nums[i]);
                left[i] = arr.size();
            }                
            else
            {
                auto iter = lower_bound(arr.begin(), arr.end(), nums[i]);
                *iter = nums[i];
                left[i] = iter-arr.begin()+1;
            }
        }
        for (auto x: left) cout<<x<<" "; cout<<endl;

        arr.clear();
        for (int i=n-1; i>=0; i--)
        {
            if (arr.size()==0 || nums[i]>arr.back())
            {
                arr.push_back(nums[i]);
                right[i] = arr.size();
            }                
            else
            {
                auto iter = lower_bound(arr.begin(), arr.end(), nums[i]);
                *iter = nums[i];
                right[i] = iter-arr.begin()+1;
            }
        }
        
        int count = 0;
        for (int i=0; i<n; i++)
        {
            if (left[i]>=2 && right[i]>=2)
                count = max(count, left[i]+right[i]-1);
        }
        return n-count;

    }
};
::::::::::::::
Greedy/1671.Minimum-Number-of-Removals-to-Make-Mountain-Array/Readme.md
::::::::::::::
### 1671.Minimum-Number-of-Removals-to-Make-Mountain-Array

我们遍历每个元素nums[i]，思考如果它作为peak，那么能够得到多长的mountain array。显然，对于peak的左侧，我们需要寻找一个从左往右的、截止在nums[i]的最长递增序列（LIS）；同理，对于peak的右侧，我们需要寻找一个从右往左的、截止在nums[i]的最长递增序列。

我们知道经典的LIS算法，可以用o(N^2)或者o(NlogN)的复杂度，计算数组里面（截止至）每个元素的LIS的长度。我们预处理得到这样的leftLIS[i]和rightLIS[i]之后，那么以nums[i]为peak的mountain array的长度就是leftLIS[i]+rightLIS[i]-1.

特别需要注意的是，本题要求合法的mountain array必须满足leftLIS和rightLIS的长度都要至少是2.
::::::::::::::
Greedy/1686.Stone-Game-VI/1686.Stone-Game-VI.cpp
::::::::::::::
class Solution {
public:
    int stoneGameVI(vector<int>& aliceValues, vector<int>& bobValues) 
    {
        int n = aliceValues.size();
        vector<pair<int,int>>tmp(n);
        for (int i=0; i<n; i++)
        {
            tmp[i] = {aliceValues[i]+bobValues[i],i};
        }
        sort(tmp.begin(), tmp.end());
        reverse(tmp.begin(), tmp.end());
               
        int x = 0, y = 0;
        for (int i=0; i<n; i++)
        {
            if (i%2==0)
                x += aliceValues[tmp[i].second];                                
            else            
                y += bobValues[tmp[i].second];            
        }
        
        if (x>y)
            return 1;
        else if (x==y)
            return 0;
        else
            return -1;
        
    }
};
::::::::::::::
Greedy/1686.Stone-Game-VI/Readme.md
::::::::::::::
### 1686.Stone-Game-VI

对于Alice而言，什么才是最优的决策吗？是优先选择自己能得到的最大值吗？并不是，通过这个例子就可以看出来：
```
Alice: 1 2
Bob:   3 1
```
如果Alice优先选择第二个元素的话，那么Bob选择第一个元素反而会有更高的总分。于是我们显然发现，对于Alice而言，每一步的决策不仅要使自己的得分高，而且需要使对手的得分低。对于Alice而言，如果选择了第二个元素，那么Alice得了2分，Bob失去了一个得1分的机会，这一反一正差距是3分。同理，对于Bob而言，如果选择了第一个元素，那么自己得了3分，Alice失去了一个得1分的机会，这一反一正就是4分。

所以，不管对哪个选手而言，一个元素的价值其实体现在了这个一反一正上。即使我自己得的分少，如果能让你失去了得高分的机会，也是一个成功的策略。

所以本题的算法很简单，将所有元素按照AliceValues[i]+BobValues[i]的大下排列。然后Alice和Bob轮流选取，对它们而言就是最优的决策。
::::::::::::::
Greedy/1702.Maximum-Binary-String-After-Change/1702.Maximum-Binary-String-After-Change.cpp
::::::::::::::
class Solution {
public:
    string maximumBinaryString(string binary) 
    {
        int n = binary.size();
        int m = 0;        
        for (auto ch:binary)
        {
            if (ch=='0')
                m++;
        }
        if (m<=1)  return binary;
        
        string ret;      
        int i = 0;  
        while (i<binary.size() && binary[i]=='1')
        {
            ret+="1";
            i++;
        }                    
        for (int i=0; i<m-1; i++)
            ret+="1";
        ret+="0";
        while (ret.size() < n)
            ret+="1";
    
        return ret;        
    }
};
::::::::::::::
Greedy/1702.Maximum-Binary-String-After-Change/Readme.md
::::::::::::::
### 1702.Maximum-Binary-String-After-Change

将字符串最大化的最高效的一步操作，就是将最高位的0变成1.而我们能用的规则就是操作1："00"->"10"。但是这一步需要0后面有个额外的0才能实现。那么0后面紧接着的如果是个1怎么办呢？这时候观察操作2，它的本质就是将0往前移动。这说明如果只要字符串的后面还有0，就可以将它提上来凑成两个连续的0，利用规则1，将此时最高位的0变成1.

接下来，此时最高位的0就是之前被提上来的0。想要将它也变成1的话，也需要同样的步骤：将字符串后面的0提前，凑成连续的两个0，再把最高位置成1.

可以想见，如果原先的字符串里有m个0的话，那么从最高位的0开始，连续m-1个位置都会重复上面的操作。最终留下第m个位置上是0，这是整个字符串目前为止仅剩的一个0，我们再也无法做其他操作使其变大了。
::::::::::::::
Greedy/1713.Minimum-Operations-to-Make-a-Subsequence/1713.Minimum-Operations-to-Make-a-Subsequence.cpp
::::::::::::::
class Solution {
public:
    int minOperations(vector<int>& target, vector<int>& arr) 
    {
        unordered_map<int,int>Map;
        for (int i=0; i<target.size(); i++)
            Map[target[i]] = i;
        
        vector<int>q;
        for (int i=0; i<arr.size(); i++)
        {
            if (Map.find(arr[i])==Map.end())
                continue;
            int x = Map[arr[i]];
            if (q.empty() || q.back() < x)
                q.push_back(x);
            else
            {
                auto iter = lower_bound(q.begin(), q.end(), x);
                *iter = x;
            }
        }
        return target.size() - q.size();        
    }
};
::::::::::::::
Greedy/1713.Minimum-Operations-to-Make-a-Subsequence/Readme.md
::::::::::::::
### 1713.Minimum-Operations-to-Make-a-Subsequence

首先我们的目标是希望尽量多地在arr里面用到target已经存在的元素，并且这些元素在两个数组中都是subsequence（出现的先后顺序相同）。于是我们立刻就感觉本质就是求两个数组的longest common subsequence。这段LCS是arr所能利用的最大信息量，剩下的必须靠额外的插入了。

传统的LCS的DP算法需要o(MN)，这已经是最优的算法了，但在这里会超时，为什么呢？我们注意到题目中强调了target的每个元素是unique的。这个条件很不寻常。此时我们如果把target的元素抽象成[a,b,c,d,e...]，一切就柳暗花明了。我们其实需要在arr中找的就是尽量长的递增字母序列！这就是longest increasing subsequence的问题，可以用o(NlogN)的复杂度来解决。

所以此题的算法是，将target里面的所有元素顺次映射成1,2,3...，然后将target在arr里面的元素也都替换成对应的1,2,3...其他没有在target里出现的数字都忽略。于是我们可以计算target和arr的LIS。最终的答案就是target的长度减去LIS的长度。
::::::::::::::
Greedy/1717.Maximum-Score-From-Removing-Substrings/1717.Maximum-Score-From-Removing-Substrings.cpp
::::::::::::::
class Solution {
public:
    int maximumGain(string s, int x, int y) 
    {
        if (x<y) 
        {
            reverse(s.begin(), s.end());
            swap(x,y);
        }
        int ret = 0;
        string t;
        for (auto ch:s)
        {
            t.push_back(ch);
            while (t.size()>=2 && t.substr(t.size()-2)=="ab")
            {
                t.pop_back();
                t.pop_back();
                ret += x;
            }
        }
        string w;
        for (auto ch:t)
        {
            w.push_back(ch);
            while (w.size()>=2 && w.substr(w.size()-2)=="ba")
            {
                w.pop_back();
                w.pop_back();
                ret += y;
            }
        }
        return ret;

    }
};
::::::::::::::
Greedy/1717.Maximum-Score-From-Removing-Substrings/Readme.md
::::::::::::::
### 1717.Maximum-Score-From-Removing-Substrings

此题就是一个简单的贪心法。如果ab的收益比ba大，那么从头到尾我们就尽量删除ab。一遍走完之后，剩下的就一定只是bbbaaa的形式，那么我们就只需要再走一遍删ba了。

如果ba的收益比ab大，我们有一个比较巧妙的处理方法。就是将s逆序，并把x和y对换。这样我们依然重用上面的代码，第一遍删ab，第二遍删ba。
::::::::::::::
Greedy/1727.Largest-Submatrix-With-Rearrangements/1727.Largest-Submatrix-With-Rearrangements.cpp
::::::::::::::
class Solution {
public:
    int largestSubmatrix(vector<vector<int>>& matrix) 
    {
        int m = matrix.size();
        int n = matrix[0].size();
        vector<int>a(n,0);
        int ret = 0;
        for (int i=0; i<m; i++)
        {
            for (int j=0; j<n; j++)
            {
                if (matrix[i][j]==1)
                    a[j] = a[j]+1;
                else
                    a[j] = 0;                    
            }
            auto b = a;
            sort(b.begin(), b.end());
            reverse(b.begin(), b.end());
            int h = INT_MAX;
            for (int j=0; j<n; j++)
            {
                h = min(h, b[j]);
                ret = max(ret, h*(j+1));
            }
        }
        return ret;        
    }
};
::::::::::::::
Greedy/1727.Largest-Submatrix-With-Rearrangements/Readme.md
::::::::::::::
### 1727.Largest-Submatrix-With-Rearrangements

此题和```085.Maximal-Rectangle```的框架很相似，就是枚举一个维度，然后将问题划归为另一个以为问题来求解。

我们遍历每行row，考虑如果以i-th row为底边，我们所能构建的最大矩形是什么？此时我们眼中所看到的就是以i-th row为底边的一个histogram，和LC85不同的是，我们可以调整histogram中各条bar的顺序，来拼凑最大的矩形。为了更高效地构建矩形，我们显然会贪心地将高度相近的bar放在一起，也就是将这些bar按照高度从大到小排序。随着矩形的底边越长，代价就是高度越矮。我们横向遍历一遍后，就可以找到最大的矩形面积（宽乘以高）。

本题的答案就是遍历所有底边后，全局最大的矩形。
::::::::::::::
Greedy/1744.Can-You-Eat-Your-Favorite-Candy-on-Your-Favorite-Day/1744.Can-You-Eat-Your-Favorite-Candy-on-Your-Favorite-Day.cpp
::::::::::::::
typedef long long ll;
class Solution {
public:
    vector<bool> canEat(vector<int>& candiesCount, vector<vector<int>>& queries) 
    {
        int n = candiesCount.size();
        candiesCount.insert(candiesCount.begin(),0);
        vector<ll>presum(n+1);
        for (int i=1; i<=n; i++)
            presum[i] = presum[i-1]+candiesCount[i];
        
        vector<bool>rets;
        for (auto q: queries)
        {
            ll type = q[0]+1;
            ll day = q[1]+1;
            ll cap = q[2];
                                    
            if (1*(day-1) >= presum[type])            
                rets.push_back(false);                            
            else if (day*cap <= presum[type-1])            
                rets.push_back(false);                            
            else
                rets.push_back(true);            
        }
        return rets;        
    }
};
::::::::::::::
Greedy/1744.Can-You-Eat-Your-Favorite-Candy-on-Your-Favorite-Day/Readme.md
::::::::::::::
### 1744.Can-You-Eat-Your-Favorite-Candy-on-Your-Favorite-Day

本题就是简单的贪心法。我们令每个query对应的天数为d，糖的种类为t，每日吃糖的极限是cap。

如果我们慢到极限，每天只吃一颗糖，经过d-1天时就已经把前t种的糖都吃掉了，那么在第d天肯定就吃不到第t种糖。

反之，如果我们每天吃到极限cap，经过d天后时，仍然还没有吃到第t种糖（最多只吃完了前t-1种糖），那么也宣告失败。

其余情况下，我们都可以调节每天吃糖的数量在1\~cap之间，使得在第d天的时候有机会吃到第t种糖。
::::::::::::::
Greedy/1751.Maximum-Number-of-Events-That-Can-Be-Attended-II/1751.Maximum-Number-of-Events-That-Can-Be-Attended-II.cpp
::::::::::::::
class Solution {    
    static bool cmp(vector<int>&a, vector<int>&b)
    {
        return a[1] < b[1];
    }
public:
    int maxValue(vector<vector<int>>& events, int k) 
    {        
        sort(events.begin(), events.end(), cmp);
        int m = events.size();
        auto dp = vector<vector<int>>(m+1, vector<int>(k+1,INT_MIN/2));
        
        events.insert(events.begin(), events[0]);
        vector<int>endTime({0});
        
        int ret = 0;        
        for (int i=0; i<=m; i++)
            dp[i][0] = 0;
        
        for (int i=1; i<=m; i++)
        {
            auto iter = lower_bound(endTime.begin(), endTime.end(), events[i][0]);
            int t = iter-endTime.begin()-1;
            
            for (int j=1; j<=k; j++)
            {
                dp[i][j] = max(dp[i-1][j], dp[t][j-1]+events[i][2]);                                
                ret = max(ret, dp[i][j]);
            }
            endTime.push_back(events[i][1]);
        }
        
        return ret;        
    }
};
::::::::::::::
Greedy/1751.Maximum-Number-of-Events-That-Can-Be-Attended-II/Readme.md
::::::::::::::
### 1751.Maximum-Number-of-Events-That-Can-Be-Attended-II

本题和```1235.Maximum-Profit-in-Job-Scheduling```非常相似。差别是dp状态多了一个维度来表示可以取多少个区间。

我们首先要将所有events按照endTime排序。令dp[i][j]表示前i个events里面我们取j个events能得到的最大收益。计算dp[i][j]时有两种决策：
1. 我们不选择events[i]，那么dp[i][j]就等于在前i-1个events里面取j个的最大收益，即dp[i][j]=dp[i-1][j]
2. 我们选择events[i]作为第j个选中的项目，那么我们需要考虑第j-1个项目在哪里？显然这个项目的endTime必须必events[i][0]要小。于是我们可以用二分法，在所有endTimes里找到截止时间恰好早于events[i][0]的项目t，于是dp[i][j]就转化为考察在前t个项目里选取j-1个的最大收益，然后再加上events[i][2]本身。

最终的答案就是max(dp[m][x])，其中m是events的总数。注意答案不一定是dp[m][k]，因为强制取k件不重叠的区间，不见得是最大的利润。
::::::::::::::
Greedy/1769.Minimum-Number-of-Operations-to-Move-All-Balls-to-Each-Box/1769.Minimum-Number-of-Operations-to-Move-All-Balls-to-Each-Box.cpp
::::::::::::::
class Solution {
public:
    vector<int> minOperations(string boxes) 
    {
        int n = boxes.size();
        vector<int>leftMoves(n);
        vector<int>rightMoves(n);
        int left = 0;
        for (int i = 1; i<n; i++)
        {
            left += (boxes[i-1]=='1');
            leftMoves[i] = leftMoves[i-1] + left*1;
        }
        int right = 0;
        for (int i = n-2; i>=0; i--)
        {
            right += (boxes[i+1]=='1');
            rightMoves[i] = rightMoves[i+1] + right*1;
        }
        vector<int>rets(n);
        for (int i=0; i<n; i++)
            rets[i] = leftMoves[i]+rightMoves[i];
        return rets;
    }
};
::::::::::::::
Greedy/1769.Minimum-Number-of-Operations-to-Move-All-Balls-to-Each-Box/Readme.md
::::::::::::::
### 1769.Minimum-Number-of-Operations-to-Move-All-Balls-to-Each-Box

本题的最优解可以用o(N)的复杂度实现。

我们令leftMoves[i]表示将i元素左边所有的盒子搬运过来需要的moves。我们有递推关系：```leftMoves[i] = leftMoves[i-1]+left[i]```，其中left[i]表示i元素左边盒子的数目。理解为两步走：先将i-1左边所有的盒子搬到i-1的位置上，然后将这些盒子都再搬一步到i的位置上。left[i]的递推关系也很明显：```left[i] = left[i-1]+ (boxes[i-1]=='1')```

同理我们也可以计算rightMoves[i]。那么最终的答案就是```rets[i] = leftMoves[i]+rightMoves[i]```.
::::::::::::::
Greedy/1788.Maximize-the-Beauty-of-the-Garden/1788.Maximize-the-Beauty-of-the-Garden.cpp
::::::::::::::
class Solution {
public:
    int maximumBeauty(vector<int>& flowers) 
    {
        unordered_map<int,vector<int>>Map;
        for (int i=0; i<flowers.size(); i++)
        {
            Map[flowers[i]].push_back(i);
        }
        
        int n = flowers.size();
        vector<int>presum(n);
        int sum = 0;
        for (int i=0; i<n; i++)
        {
            sum += (flowers[i]<0? 0:flowers[i]);
            presum[i] = sum;
        }
        
        int ret = INT_MIN;
        for (auto x: Map)
        {
            if (x.second.size()==1) continue;
            int beauty = x.first;            
            int a = x.second[0]+1, b = x.second.back()-1;            
            ret = max(ret, presum[b] - (a==0?0:presum[a-1]) + 2*beauty);
        }
        return ret;        
    }
};
::::::::::::::
Greedy/1788.Maximize-the-Beauty-of-the-Garden/Readme.md
::::::::::::::
### 1788.Maximize-the-Beauty-of-the-Garden

显然，我们会用hash表来记录每种花的所有位置。比如，令某种花的第一个位置a和最后一个位置b作为两端，那么我们就只能保留区间[a:b]里的花。

那么本题是否就只是求一个区间和那么简单呢？其实不然，因为本题中的元素值可以是负数。显然[a+1:b-1]这个范围内的所有负数元素都是不合算的，我们也应当将其移除。特别注意，如果a和b两处的花也是负数，我们却不能移除，因为我们约定要以该花为两端。所以这种方案的总价值是：[a+1:b-1]区间内的所有非负数之和，再加上a和b两处的元素。

如何求一个区间内的所有非负数之和呢？我们依然还是会用到前缀和的思想，但是处理的技巧是，在累加前缀和的时候，我们将所有的负数都变成0来处理。这样，用两处前缀和之差来计算区间和的时候，自动就忽略了所有的负数元素。
::::::::::::::
Greedy/1798.Maximum-Number-of-Consecutive-Values-You-Can-Make/1798.Maximum-Number-of-Consecutive-Values-You-Can-Make.cpp
::::::::::::::
class Solution {
public:
    int getMaximumConsecutive(vector<int>& coins) 
    {
        sort(coins.begin(), coins.end());
        
        int curMax = 0;
        
        for (auto c: coins)
        {
            if (c>curMax+1) break;
            curMax+=c;
            
        }
        return curMax+1;
        
    }
};
::::::::::::::
Greedy/1798.Maximum-Number-of-Consecutive-Values-You-Can-Make/1798.Maximum-Number-of-Consecutive-Values-You-Can-Make_TLE.cpp
::::::::::::::
class Solution {
public:
    int getMaximumConsecutive(vector<int>& coins) 
    {
        sort(coins.begin(), coins.end());
        
        unordered_set<int>Set;
        Set.insert(0);
        int next = 1;
        
        for (auto c: coins)
        {
            if (next < c)
                return next;            
                
            vector<int>temp({c});
            for (auto t: Set)
                temp.push_back(t+c);
            for (auto x: temp)
                Set.insert(x);
            
            while (Set.find(next)!=Set.end())
                next++;            
        }
        return next;        
    }
};
::::::::::::::
Greedy/1798.Maximum-Number-of-Consecutive-Values-You-Can-Make/Readme.md
::::::::::::::
### 1798.Maximum-Number-of-Consecutive-Values-You-Can-Make

#### 解法1：动态规划
比较常规的想法是，维护一个集合Set来记录我们构造什么样的面值。我们按照从小到大的顺序挨个考察coins，对于当前的c，能够带来什么样的新面值呢？显然就是Set里面的每个元素（包括空元素）分别加上c。

我们这个时候再看一下这个Set，如果此时集合里下一个待构造的面值next小于c的话，那么这个面值以后肯定就再也无法构造。因为之后我们遇到的单个硬币都会比next更大，不会带来任何帮助。

这个解法中，集合需要存储可以构造的所有面值，这个数量可能会非常大。比如说k个硬币，任意组合的面值都不重合的话，那么就会有2^k种面值。当考察第k+1个硬币带来的集合更新时，很可能会TLE。

#### 解法2：贪心
本题的突破口其实是，要注意到，每次这个集合的元素其实都应该是保证连续的！

假设当前集合能够构造从0到curMax的连续面值。那么显然加入新硬币c之后，就能够构造从c到curMax+c的连续面值。如果[0,curMax]和[c,curMax+c]这两段区间是交叠的，那么新的curMax就是curMax+c。如果这两段区间不交叠，即```curmax+1 < c```（注意+1），那么说明curMax+1无法构造。注意，此后的新硬币面值都将大于c，那么也意味着大于```curMax+1```。说明以后任何新硬币都不会给构造curMax+1带来帮助。此时能构造的连续面值就是[0, curMax].
::::::::::::::
Greedy/1818.Minimum-Absolute-Sum-Difference/1818.Minimum-Absolute-Sum-Difference.cpp
::::::::::::::
class Solution {
public:
    int minAbsoluteSumDiff(vector<int>& nums1, vector<int>& nums2) 
    {
        auto arr = nums1;
        sort(arr.begin(), arr.end());
        int n = nums2.size();
        int maxDecrease = 0;
        
        for (int i=0; i<n; i++)
        {
            auto iter = lower_bound(arr.begin(), arr.end(), nums2[i]);
            int a = INT_MAX/2, b = INT_MAX/2;
            if (iter!=arr.end())
                a = *iter;
            if (iter!=arr.begin())
                b = *prev(iter);
            
            int diff = min(abs(a-nums2[i]), abs(b-nums2[i]));
            
            int origin = abs(nums1[i]-nums2[i]);            
            maxDecrease = max(maxDecrease, origin - diff);            
        }
        
        long ret = 0;
        long M = 1e9+7;
        for (int i=0; i<n; i++)
        {
            ret = ret + abs((long)nums1[i] - (long)nums2[i]);
            ret %= M;
        }
        ret -= maxDecrease;
        ret = (ret+M)%M;
        
        return ret;
    }
};
::::::::::::::
Greedy/1818.Minimum-Absolute-Sum-Difference/Readme.md
::::::::::::::
### 1818.Minimum-Absolute-Sum-Difference

注意此题不能只贪心的找差值最大的那对。必须对于每一对数字都查验是否能否通过操作得到一个更小的差值。例如对于{nums1[i],nums2[i]}，我们在对nums1排序后的数组arr里找到最接近nums2[i]的一个数x，计算减少量```d = |nums1[i] - nums2[i]| - |x - nums2[i]|```.

最终找到全局最大的减少量d。
::::::::::::::
Greedy/1840.Maximum-Building-Height/1840.Maximum-Building-Height.cpp
::::::::::::::
class Solution {    
public:
    int maxBuilding(int n, vector<vector<int>>& restrictions) 
    {           
        
        restrictions.push_back({1,0});
        sort(restrictions.begin(), restrictions.end());
        
        int m = restrictions.size();
        vector<int>h(m);
        
        for (int i=1; i<m; i++)
        {
            h[i] = min(restrictions[i][1], h[i-1] + restrictions[i][0] - restrictions[i-1][0]);
        }
        
        for (int i=m-2; i>=1; i--)
        {
            h[i] = min(h[i], h[i+1] + restrictions[i+1][0] - restrictions[i][0]);
        }
        
        int ret = 0;
        for (int i=1; i<m; i++)
        {
            int y = ((h[i-1]-h[i]) - (restrictions[i-1][0]-restrictions[i][0]))/2;
            ret = max(ret, h[i]+y);
        }
        
        ret = max(ret, h[m-1] + n - restrictions[m-1][0]);
        
        return ret;
    }
};
::::::::::::::
Greedy/1840.Maximum-Building-Height/Readme.md
::::::::::::::
### 1840.Maximum-Building-Height

对于没有限制的地段，我们可以任意发挥，暂时不考虑。我们只考虑有限制的这些楼，我们记这些楼的位置是pos[i]（即restrictions[i][0]），高度限制是limit[i]（即restrictions[i][1]），我们打算盖的高度是h[i]。

我们先假想每个楼都可以盖到最高，即```h[i] = limit[i]```。但这是不可能的，因为还有一个约束是实际相邻两幢楼之间差距不超过1. 因为我们说过暂不考虑没有高度限制的地段，所以这个约束本质是说，任意两幢有限高的楼之间，需要满足h[i]与h[i-1]的高度差不能超过```pos[i]-pos[i-1]```. 注意这是必要条件，不满足的话就无法保证“实际相邻两幢楼之间差距不超过1”。

至此，我们可以借鉴```LC135.Candy```的思路，因为我们已知h[1]=0，那么可以先从左往右扫一遍，根据h[i-1]来制约h[i]。即```h[i] = min(limit[i], h[i-1]+pos[i]-pos[i-1])```. 扫一遍之后保证了h数组里，每个楼都不会比它左边“不合理地高”。也就是说，如果h[i]比h[i-1]高，也不会违反高度差的约束。

接下来我们再从右往左扫一遍，根据h[i+1]来进一步限制h[i]，即```h[i] = min(h[i], h[i+1]+pos[i+1]-pos[i])```. 扫一遍之后保证了h数组里，每个楼都不会比它右边“不合理地高”。也就是说，如果h[i]比h[i+1]高，也不会违反高度差的约束。

这两遍操作的本质是什么呢？本质是：对于h数组中任意相邻的两幢楼，如果存在高度差，那么这个高度差是合理的！（也就是h[i]与h[i-1]的高度差不能超过```pos[i]-pos[i-1]```）。也就是说，此时的h数组是符合条件的安排。

我们再看一下，这两遍pass本身都是必要条件，即每个h[i]都不允许更高。但是最终我们神奇地发现，这个结果又是充分的。这说明我们得到了h[i]的最优解（即允许的最大值）。

现在我们已经优化了所有的h[i]，那么如何处理每个h[i]之间的那些没有高度限制的楼呢？很显然，我们会将h[i]往右不断增1，同时h[i+1]往左不断增1，查看这个peak会有多高。注意，我们保证了h[i]和h[i+1]的高度差是不超过pos[i+1]-pos[i]的，所以这个peak是一定存在的。我们可以这么计算，令peak距离h[i]是x，距离h[i+1]是y，则
```
h[i]+x = h[i+1]+y
pos[i]+x = pos[i+1]-y
```
可以知道这个peak的高度等于 ```h[i]+x = h[i+1]+y = ((h[i]-h[i+1]) - (pos[i]-pos[i+1))/2 ```

我们把每个间隔的peak都算出来取最大值。特别注意，h数组的最后一个楼往后，还有楼可以继续不停高度增一，记得补上```h[m]+n-pos[m]```.
::::::::::::::
Greedy/1846.Maximum-Element-After-Decreasing-and-Rearranging/1846.Maximum-Element-After-Decreasing-and-Rearranging.cpp
::::::::::::::
class Solution {
public:
    int maximumElementAfterDecrementingAndRearranging(vector<int>& arr) 
    {
        sort(arr.begin(), arr.end());
        arr[0] = 1;
        
        for (int i=1; i<arr.size(); i++)
        {
            if (arr[i]>arr[i-1]+1)
            {
                arr[i] = arr[i-1]+1;                
            }
                
        }
        
        for (int i=arr.size()-2; i>=0; i--)
        {
            if (arr[i]>arr[i+1]+1)
            {
                arr[i] = arr[i+1]+1;
            }
        }
        
        int ret = 0;
        for (auto x: arr)
            ret = max(ret, x);
        return ret;
    }
};
::::::::::::::
Greedy/1846.Maximum-Element-After-Decreasing-and-Rearranging/Readme.md
::::::::::::::
### 1846.Maximum-Element-After-Decreasing-and-Rearranging

观察到arr[0]必须是1，这是一个非常小的数。因为约束关系，arr[1]最大不能超过2，意味着极有可能我们必须将某个数削减之后才能安放到arr[1]。为了尽量保留较大的数字，我们一定会arrange，选择此时最小的元素放在index=1这个位置，这样就算这个数被decrease也不心疼。所以以此类推，提示我们首先需要将arr按照从小到大排序。

接下来的操作和```LC 135```和```LC 1840```很相似的做法。我们先从左往右遍历，为了尽量减少decrease，我们希望arr[i]尽量取大，但是不能超过arr[i-1]+1，由此切割一下各个元素的上限. 然后再从右往左遍历，同理，为了尽量减少decrease，我们希望arr[i]尽量取大，但是不能超过arr[i+1]+1，由此再切割一下各个元素的上限. 

这两步操作之后，每个arr[i]都贴在上限，这是必要条件，不能再大了，否则就肯定不满足要求了。那么此时的arr是否已经满足要求了呢？是的。我们已经保证了每个arr都不会比邻居多1，所以这是充分的。最终答案就是在此时的arr里面挑个最大的。
::::::::::::::
Greedy/1850.Minimum-Adjacent-Swaps-to-Reach-the-Kth-Smallest-Number/1850.Minimum-Adjacent-Swaps-to-Reach-the-Kth-Smallest-Number.cpp
::::::::::::::
class Solution {
public:
    int getMinSwaps(string num, int k) 
    {
        auto num0 = num;
        for (int i=0; i<k; i++)
        {
            std::next_permutation(num.begin(), num.end());
        }
        
        int ret = 0;
        for (int i=0; i<num.size(); i++)
        {
            int count = 0;
            for (int j=0; j<num0.size(); j++)
            {
                if (num0[j]==num[i])
                {
                    num0[j] = '#';
                    break;
                }                    
                if (num0[j]=='#')
                    continue;
                count++;
            }
            ret += count;
        }
        return ret;
    }
};
::::::::::::::
Greedy/1850.Minimum-Adjacent-Swaps-to-Reach-the-Kth-Smallest-Number/Readme.md
::::::::::::::
### 1850.Minimum-Adjacent-Swaps-to-Reach-the-Kth-Smallest-Number

很明显，本题分为两部分。

第一部分是求一个字符串的K-th next permuation. 可以调用```LC31 next permuation```的代码连续K次，或者用C++自带的next permuation. 这部分的时间是o(NK).

第二部分是求一个新字符串与原字符串相比，需要多少次adjacent swap。这本质就是求逆序对的问题。举个例子，问多少次adjacent swap能够使得字符串35241变得有序？对于1而言，它前面有4个字符比它大，所以需要交换4次使得1排到最前面；对于2而言，它前面有3个字符比它大，所以要交换3次能排到除1外的最前面；对于3而言，它前面没有字符比它大，它不需要主动交换，只需等着被动swap就能排到最终的第3个位置...由此我们发现，总共需要交换的次数就是逆序对的个数。逆序对指的是，```i<j && nums[i]>nums[j]```. 求解逆序对其实就是```LC 493.Reverse-Pairs```，有o(NlogN)的算法。

在本题中，我们根据新字符串重新定义各个字符之间的“有序”。这样从旧字符串变换成为新字符串的过程，就可以等同于上述的过程，也就是转化为求逆序对。注意，对于相同的字符，我们始终保持它们之前的相对顺序。很显然，对于相同字母，我们永远不会做swap.

考虑到本题中字符的个数N不超过1e3，暴力的冒泡贪心l(N^2)也是可以做的。具体方法是：对于new[i]，我们从old[0]开始找起、直到找到第一个old[j]==new[i]，那么从0到j的过程中所遇到的尚未匹配的字符个数，就是需要的adjacent swap次数。注意对于匹配好的new[j]，我们立即将其替换为'#'作为标记。比如说
```
old: abcd
new: bcda
step 1: old-> a#cd  +1
step 2: old-> a##d  +1
step 3: old-> a###  +1
step 4: old-> ####  +0
```
所以总共3次swap将old变成new。
::::::::::::::
Greedy/1888.Minimum-Number-of-Flips-to-Make-the-Binary-String-Alternating/1888.Minimum-Number-of-Flips-to-Make-the-Binary-String-Alternating.cpp
::::::::::::::
class Solution {
public:
    int minFlips(string s) 
    {
        int n = s.size();
        
        vector<int>left0(n);
        vector<int>left1(n);
        vector<int>right0(n);
        vector<int>right1(n);
        
        int sumLeft0 = 0, sumLeft1 = 0;
        for (int i=0; i<n; i++)
        {
            if (i%2==0 && s[i]=='1' || i%2==1 && s[i]=='0')
                sumLeft0++;
            if (i%2==0 && s[i]=='0' || i%2==1 && s[i]=='1')
                sumLeft1++;
            left0[i] = sumLeft0;
            left1[i] = sumLeft1;
        }
        
        int sumRight0 = 0, sumRight1 = 0;
        for (int i=n-1; i>=0; i--)
        {
            int j = n-1-i;
            if (j%2==0 && s[i]=='1' || j%2==1 && s[i]=='0')
                sumRight0++;
            if (j%2==0 && s[i]=='0' || j%2==1 && s[i]=='1')
                sumRight1++;
            right0[i] = sumRight0;
            right1[i] = sumRight1;
        }
        
        int ret = n;
        ret = min(ret, sumLeft0);
        ret = min(ret, sumLeft1);
        ret = min(ret, sumRight0);
        ret = min(ret, sumRight1);
        
        for (int i=0; i<n-1; i++)
        {
            ret = min(ret, left0[i]+right1[i+1]);
            ret = min(ret, left1[i]+right0[i+1]);
        }
        
        return ret;
    }
};
::::::::::::::
Greedy/1888.Minimum-Number-of-Flips-to-Make-the-Binary-String-Alternating/Readme.md
::::::::::::::
### 1888.Minimum-Number-of-Flips-to-Make-the-Binary-String-Alternating

首先，flip和rotate两个操作彼此之间不会有任何影响。比如你有a次flip，b次rotate，那么打乱顺序去实现这a+b次操作，结果都完全一样。所以我们不妨考虑先做flip，再做rotate。言下之意，先做flip，然后将序列前端的某一段翻转之后拼在序列后端。

如果flip操作完之后已经是交替序列了，那么就不需要rotate。那么rotate能带来什么好处呢？唯一的好处就是类似这种情况：
```
0101 1010101
```
前后半段都是交替序列，但整体并不是交替序列，因为中间有两个连续的1.此时用flip再做调整显然是低效的。我们发现，如果我们将前面那段转移到后面去，就解决了这个问题。当然，能翻转的先决条件是，前端的头是0，后段的尾是1. 类似的，如果前段的头是1，后段的尾是0的话，也可以做这样的rotate，省下flip的操作。

这样来看，我们只要将前后两个序列各自弄成交替序列就行了。

那么如何确定这个分界点呢？自然想到会枚举一下这个位置。加入分界点在i和i+1的地方，这时候我们考虑的是：前段从左往右的0101序列，后段从右往左的1010序列，然后可以在这个地方断开rotate。或者前段从左往右的1010序列，后段从右往左的0101列，然后也可以在这点断开rotate。我们容易知道，可以用one pass计算从左往右0101序列延伸到每个位置时的flip操作数，同理也可以提前预处理从左往右1010序列延伸到每个位置时的flip操作数、从右往做0101序列延伸到每个位置时的flip操作数、从右往做1010序列延伸到每个位置时的flip操作数。

最终的答案就是枚举端点位置i，考察```left0[i]+right1[i+1]```和```left1[i]+right0[i+1]```的较小值。

::::::::::::::
Greedy/1911.Maximum-Alternating-Subsequence-Sum/1911.Maximum-Alternating-Subsequence-Sum_dp.cpp
::::::::::::::
class Solution {
public:
    long long maxAlternatingSum(vector<int>& nums) 
    {        
        long long dp_even = 0;
        long long dp_odd = 0;
        
        for (int i=0; i<nums.size(); i++)
        {
            long long dp_even_2 = dp_even;
            long long dp_odd_2 = dp_odd;
            
            dp_even = max(dp_even_2, dp_odd_2 + nums[i]);
            dp_odd = max(dp_odd_2, dp_even_2 - nums[i]);
        }
        
        return dp_even;
    }
};
::::::::::::::
Greedy/1911.Maximum-Alternating-Subsequence-Sum/1911.Maximum-Alternating-Subsequence-Sum_greedy.cpp
::::::::::::::
typedef long long ll;
class Solution {
public:
    long long maxAlternatingSum(vector<int>& nums) 
    {
        ll ret = 0;
        int i = 0;
        while (i<nums.size())
        {
            if (i+1<nums.size() && nums[i]>nums[i+1])            
                ret+= nums[i] - nums[i+1];
            i++;
        }

        ret += nums.back();

        return ret;
    }
};
::::::::::::::
Greedy/1911.Maximum-Alternating-Subsequence-Sum/Readme.md
::::::::::::::
### 1911.Maximum-Alternating-Subsequence-Sum

#### 解法1：贪心
此题的本质就是```122. Best Time to Buy and Sell Stock II```. 数组的元素想象成每天的股价，你必须买一支（挑选的第偶数个数）、卖一支（挑选的第奇数个数）这样交替操作。问最终的最大收益是多少。显然对于122题而言，尽量榨取每一天的利润、规避每一天的亏损，就是最优的贪心策略。只要明天比今天的价格高，那么我就今天买，明天卖；如果明天比今天的价格低，那么我今天就不买。

对于本题，同理查看每一个相邻对。比如nums[1]>nums[2]，那么我们就增加利润nums[1]-nums[2]. 如果nums[2]>nums[3]，那么我们就增加利润nums[2]-nums[3]. 我们发现这两步操作，前者是将nums[2]当做奇数项，后者是将nums[2]当做偶数项，看似矛盾，但本质就是抵消了nums[2]，只挑选了nums[1]和nums[3]，同时将这两段gap的利润都拿到了。

特别注意的是，无论nums个数的奇偶性，我们最终无法给最后一个元素nums[n-1]找相邻对。所以我们必然将其直接加入结果（不需要和一个减损项配对）。注意这只是形式上的。举个例子，```4,3,2,1```，虽然我们计算的收益是(4-3)+(3-2)+(2-1)+1，但本质我们选中的其实是4和1，其中1是被当做了奇数项。再比如```1 2 3 4```，(1,2), (2,3), (3,4)都是亏损的，我们不会考虑，最终我们计算的收益只有是4，形式上它被当做了偶数项。

#### 解法2：DP
令dp1[i]表示截止到i为止、最后一项是even的序列的收益。令dp2[i]表示截止到i为止、最后一项是odd的序列的收益。注意元素i本身可以不作为序列中的一部分。

转移方程是：
```
dp1[i] = max(dp1[i-1], dp2[i-1]+A[i]);
dp2[i] = max(dp2[i-1], dp2[i-1]-A[i]);
```
最后返回dp1[n-1]即可。
::::::::::::::
Greedy/1963.minimum-number-of-swaps-to-make-the-string-balanced/1963.minimum-number-of-swaps-to-make-the-string-balanced.cpp
::::::::::::::
class Solution {
public:
    int minSwaps(string s) 
    {
        int count=0;
        int unmatch = 0;
        for (auto ch: s)
        {
            if (ch=='[')
                count++;
            else
                count--;
            if (count < 0)
            {
                unmatch++;
                count = 0;
            }
        }
        return (unmatch+1)/2;
    }
};
::::::::::::::
Greedy/1963.minimum-number-of-swaps-to-make-the-string-balanced/Readme.md
::::::::::::::
### 1963.minimum-number-of-swaps-to-make-the-string-balanced

本题的关键点是要想到，如果把所有能就近配对的括号都消去的话，剩余的括号必然是形如```]]]][[[[[```的模式。这些位于两边的括号是无论如何都无法在原字符串里被匹配的。

对于连续n个右括号+连续n个左括号，需要多少次swap能够让他们配对呢？我们不妨多尝试几个例子：
```
][: => [] 1 swap
]][[: => [][] 1 swap
]]][[[: => []][[] => [][][] 2 swaps
]]]][[[[: => []]][[[] => [][][][] 2 swaps
```
所以我们可以总结出规律来，只需要(n+1)/2次交换。

::::::::::::::
Greedy/1964.Find-the-Longest-Valid-Obstacle-Course-at-Each-Position/1964.Find-the-Longest-Valid-Obstacle-Course-at-Each-Position.cpp
::::::::::::::
class Solution {
public:
    vector<int> longestObstacleCourseAtEachPosition(vector<int>& obstacles) 
    {
        vector<int>a;
        vector<int>rets;
        for (auto x: obstacles)
        {
            if (a.empty() || a.back()<= x)
            {
                a.push_back(x);
                rets.push_back(a.size());
            }
            else
            {
                auto iter = upper_bound(a.begin(), a.end(), x);
                *iter = x;
                rets.push_back(iter - a.begin() + 1);
            }                
        }
        return rets;        
    }
};
::::::::::::::
Greedy/1964.Find-the-Longest-Valid-Obstacle-Course-at-Each-Position/Readme.md
::::::::::::::
###  1964.Find-the-Longest-Valid-Obstacle-Course-at-Each-Position

本题的本质其实就是求最长（非严格）递增子序列。类似于```LC.300```，我们有NlogN的贪心解法。算法的核心是用数组来维护一个递增的数组arr。如果新元素x比数组的最后一个元素还大，那么显然以x结尾的LIS就是```arr.size()+1```. 

如果新元素x不能添加在最后怎么办，我们找到arr里面第一个大于x的位置i，把arr[i]替换为x。显然以x结尾的LIS的长度就是i。那么问题来了，我们为什么要做“替换”呢？首先，替换之后arr依然是递增的序列。其次，这个arr整体“变矮”了，无论之后的新元素x是什么，对于它而言都更容易构造更长的LIS。
::::::::::::::
Greedy/1982.Find-Array-Given-Subset-Sums/1982.Find-Array-Given-Subset-Sums.cpp
::::::::::::::
class Solution {
public:
    vector<int> recoverArray(int n, vector<int>& sums) 
    {
        vector<int>rets;
        if (dfs(sums, n, rets))
            return rets;
        return {};
    }

    bool dfs(vector<int>sum, int n, vector<int>&rets)
    {
        if (n==1)
        {        
            if (sum[0]!=0 && sum[1]!=0)    
                return false;
            else
            {
                rets.push_back(sum[1]==0? sum[0]:sum[1]);            
                return true;    
            }            
        } 

        int k = sum.size();
        std::nth_element(sum.begin(), sum.begin()+k-1, sum.end());
        std::nth_element(sum.begin(), sum.begin()+k-2, sum.end());

        int x = sum[k-1]-sum[k-2];
        multiset<int>Set1(sum.begin(), sum.end());
        vector<int>sum1;
        for (int i=0; i<k/2; i++)
        {
            int num = *Set1.rbegin();
            if (Set1.find(num-x)==Set1.end())
                break;
            Set1.erase(Set1.lower_bound(num));    
            Set1.erase(Set1.lower_bound(num-x));
            sum1.push_back(num-x);
        }
        if (sum1.size()==k/2)
        {
            rets.push_back(x);
            if (dfs(sum1, n-1, rets))
                return true;
            rets.pop_back();
        }

        x = -x;
        multiset<int>Set2(sum.begin(), sum.end());
        vector<int>sum2;
        for (int i=0; i<k/2; i++)
        {
            int num = *Set2.begin();
            if (Set2.find(num-x)==Set2.end())
                break;
            Set2.erase(Set2.lower_bound(num-x));
            Set2.erase(Set2.lower_bound(num));
            sum2.push_back(num-x);
        }
        if (sum2.size()==k/2)
        {
            rets.push_back(x);
            if (dfs(sum2, n-1, rets))
                return true;
            rets.pop_back();
        }

        return false;
    }
};
::::::::::::::
Greedy/1982.Find-Array-Given-Subset-Sums/1982.Find-Array-Given-Subset-Sums_v2.cpp
::::::::::::::
class Solution {
public:
    vector<int> recoverArray(int n, vector<int>& sums) 
    {
        vector<int>rets;
        if (dfs(sums, n, rets))
            return rets;       
        return {};
    }
    
    vector<int>split1(vector<int>&sums, int x)
    {        
        int k = sums.size();
        vector<int>visited(k);
        vector<int>rets;
        int i = k-1, j = k-1;
        for (int t=0; t<k/2; t++)
        {
            while (i>=0 && visited[i])
                i--;
            if (i<0) return {};
            visited[i] = 1;
            
            while (j>=0 && (visited[j]||sums[j]!=sums[i]-x))
                j--;
            if (j<0) return {};
            visited[j] = 1;
            
            rets.push_back(sums[j]);
        }
        return rets;
    }      
    
    vector<int>split2(vector<int>&sums, int x)
    {
        int k = sums.size();
        vector<int>visited(k);
        vector<int>rets;
        int i = 0, j = 0;
        for (int t=0; t<k/2; t++)
        {
            while (i<k && visited[i])
                i++;
            if (i>=k) return {};
            visited[i] = 1;
            
            while (j<k && (visited[j]||sums[j]!=sums[i]-x))
                j++;
            if (j>=k) return {};
            visited[j] = 1;
            
            rets.push_back(sums[j]);
        }
        return rets;
    }    
    
    
    bool dfs(vector<int>sums, int n, vector<int>&rets)
    {
        if (n==1)
        {
            if (sums[0]!=0 && sums[1]!=0)
                return false;
            else
            {
                rets.push_back(sums[0]==0? sums[1]:sums[0]);
                return true;
            }
        }
        
        int k = sums.size();
        sort(sums.begin(), sums.end());
        
        // suppose x is the minimum positive number
        int x = sums[k-1]-sums[k-2]; 
        vector<int>sums1 = split1(sums, x);
        if (sums1.size()==k/2)
        {
            rets.push_back(x);
            if (dfs(sums1, n-1, rets))
                return true;
            rets.pop_back();
        }
        
        // suppose x is the maximum negative number
        x = -(sums[k-1]-sums[k-2]);
        vector<int>sums2 = split2(sums, x);
        if (sums2.size()==k/2)
        {
            rets.push_back(x);
            if (dfs(sums2, n-1, rets))
                return true;
            rets.pop_back();
        }    
                
        return false;        
    }    
};
::::::::::::::
Greedy/1982.Find-Array-Given-Subset-Sums/Readme.md
::::::::::::::
### 1982.Find-Array-Given-Subset-Sums

我们先考虑比较简单的情况，所有的数字都是正数。那么显然sums里面的最小值一定是0. 并且sums的第二小的值x一定是这个数组中的最小元素。有了这个x，我们就可以把sums拆解成两部分：一部分是原数组元素（假设有n个）扣除x之后的所有子集和，共有2^(n-1)个；另一部分是前者的每个元素加上x，同样也有2^(n-1)个。这样两部分的并集就是原数组所有元素的subset sums。我们利用这个方法可以不停地剥离出最小元素，继而递归处理sums砍半之后的第一部分（因为没有了x的影响）。直至把原数组的所有元素都重构出来。

那么如何做到上述的拆解呢？我们先找sums里面的最大值a，它必然是所有元素的和，属于第二部分。相对应的，第一部分里必然会有一个a-x。于是我们可以将a和a-x都从sums里删除，同时将a-x放入待递归处理的sums2. 之后不断重复之前的操作，从大到小遍历sums里剩余的值，共进行```2^n/2```轮。最后我们得到的sums2就是sums的一半，sum2所包含的所有子集和都已经剔除了x的影响。之后递归处理sums2即可。

OK，我们接下来考虑数字元素有正有负的情况。我们有没有机会确认其中一个元素呢？我们可以想到sums里面的最大值a，此时对应的应该是所有正数元素之和。那么sums里面的次大值b，对应的是什么呢？其实有两种可能，一种从所有正数元素之和里刨掉最小的那个，也有可能是把所有正数元素之和再加上最接近0的一个负数。不管哪种情况，我们令x=a-b，都有可能对应着原数组里的一个元素。如果是前者，那么x本身就是。如果是后者，那么-x就是。于是这里就出现了递归的分叉，我们可以将x作为一个原始元素将sums做分解，也可以将-x作为一个原始元素将sums做分解。对于分解成功的方案，我们就可以继续递归处理从sums砍半得到的sums2.

注意，当我们根据-x做sums的分解时，因为(-x)是负数，方法略有不同。此时sums里面的最小值a才是包含了(-x)的子集和，对应的a+x才是剔除了(-x)的子集和。所以我们需要从小到大遍历sums的元素。

递归的边界条件是当n=1时，sums里有两个元素。其中一个元素必须是0，另一个元素就是返回值（原始元素）。

#### 关于重构的具体方法
根据前面的分析，我们会遇到这样一个问题。已知一系列数字{nums[i]}，和该系列数字与某正数x的和{nums[i]+x}，将这两者混合在一起记做arr之后，如何将原先的{nums[i]}解析出来？

第一种方法是用multiset，每一个回合可以实时取出arr里面的最大值，它必然对应了某个nums[j]+x，于是我们就可以知道了nums[j]是谁。这样我们就可以把nums[j]和nums[j]+x都从multiset里面直接删除。然后递归处理。

另一种方法是用双指针。将arr排序之后从高到低遍历。对于任何一个未访问过的元素arr[i]，必然对应着另一个arr[j]+x。于是我们就可以把arr[i]和arr[j]标记出来。然后再剩下的arr元素里递归处理。注意到，i与j都一定是单调递减遍历的。这个技巧和2007和2122是一样的。
::::::::::::::
Greedy/1996.The-Number-of-Weak-Characters-in-the-Game/1996.The-Number-of-Weak-Characters-in-the-Game.cpp
::::::::::::::
class Solution {
    static bool cmp(vector<int>&a, vector<int>&b)
    {
        if (a[0]!=b[0])
            return a[0]<b[0];
        else
            return a[1]>b[1];
    }
public:
    int numberOfWeakCharacters(vector<vector<int>>& properties) 
    {
        sort(properties.begin(), properties.end(), cmp);
        stack<int>Stack;
        int ret = 0;
        for (int i=0; i<properties.size(); i++)
        {
            while (!Stack.empty() && Stack.top() < properties[i][1])
            {
                Stack.pop();
                ret++;
            }
            Stack.push(properties[i][1]);
        }
        return ret;
    }
};
::::::::::::::
Greedy/1996.The-Number-of-Weak-Characters-in-the-Game/Readme.md
::::::::::::::
### 1996.The-Number-of-Weak-Characters-in-the-Game

对于这种涉及两种属性的题目，常见的思想就是固定一个属性，探索另外一个属性。

对于本题，所谓“固定一个属性”，就是指将所有人按照攻击力排序。这样的话，靠前的人自然地就会比靠后的人的武力值更低（暂不考虑属性值相同的情况），这样就简化了我们的任务。我们只需要在这个序列中查看有多少靠前的人的防御值也比靠后的人低即可。我们可以用一个栈，维护一个递减的防御力。如果新元素的防御力高，那么栈顶元素都是弱角色（因为攻击力和防御力都不及后来的新元素），可以不断退栈直至防御力不输给新元素。可以想象，只有递增的攻击力（排序）同时搭配递减的防御力（栈），才能保证序列的增长和元素的共存。否则就需要栈的弹出。

本题有一个特殊的情况需要处理，就是相同攻击力的元素，怎么保证低防御力的被高防御力的所消灭。这里用到了和```354.Russian Doll Envelopes```一样的技巧，将相同攻击力的人按照防御力从大到小排列。这样这些人逐个加入栈的时候，就不会触发弹栈操作。
::::::::::::::
Greedy/2007.Find-Original-Array-From-Doubled-Array/2007.Find-Original-Array-From-Doubled-Array_v1.cpp
::::::::::::::
class Solution {
public:
    vector<int> findOriginalArray(vector<int>& changed) 
    {        
        int n = changed.size();
        if (n%2!=0) return {};
        
        multiset<int>Set(changed.begin(), changed.end());
        vector<int>rets;
        for (int t=0; t<n/2; t++)
        {
            int mx = *prev(Set.end());
            if (mx%2!=0)
                return {};
            if (Set.find(mx/2)==Set.end())
                return {};
            Set.erase(Set.lower_bound(mx));
            Set.erase(Set.lower_bound(mx/2));
            rets.push_back(mx/2);
        }
        return rets;
    }
};
::::::::::::::
Greedy/2007.Find-Original-Array-From-Doubled-Array/2007.Find-Original-Array-From-Doubled-Array_v2.cpp
::::::::::::::
class Solution {
public:
    vector<int> findOriginalArray(vector<int>& changed) 
    {
        int n =changed.size();
        if (n%2!=0)  return {};
        
        sort(changed.begin(), changed.end());
        
        vector<int>rets;
        int left = 0, right = 0;
        vector<int>used(n);
        for (int i=0; i<n/2; i++)
        {
            while (left < n && used[left])
                left++;
            if (left==n) return {};
            rets.push_back(changed[left]);
            used[left] = 1;
            while (right < n && (used[right]||changed[right]!=changed[left]*2))
                right++;
            if (right==n) return {};            
            used[right] = 1;
        }
        
        return rets;        
    }
};

::::::::::::::
Greedy/2007.Find-Original-Array-From-Doubled-Array/Readme.md
::::::::::::::
### 2007.Find-Original-Array-From-Doubled-Array

很显然，changed里面的最大值，一定是original里面的最大值的两倍。这样，我们就把这两个数确定，并且从changed里面剔除。这样此时changed里面的最大值，就是original里面的第二大的值。我们同样可以把这两个元素从changed里面剔除，直至把所有元素都确定。

如果我们在这个过程中，发现changed里面的最大值x与x/2不同时存在于changed里面，说明无解。

#### 解法1：multiset
上述的思想可以粗暴地用multiset来实现。每个回合，直接从multiset里面删除最大的元素x，然后再删除其中数值为x/2的元素。这样的时间复杂度是NlogN.

#### 解法2：双指针
更高效的解法是双指针。将changed排序之后，我们设置left和right两个指针。对于changed[left]而言，我们一定是单调递增地移动right，试图寻找满足```changed[right]==changed[left]*2```的位置。找到这对之后，将used[left]和used[right]都标记为1，这样在后续的寻找中，无论left和right都不能指向已经用过的位置。

双指针遍历的过程中，我们期望恰好找到n/2对。任何时候，left或right越界了，说明我们无法找到下一个合适的配对，就返回空集。
::::::::::::::
Greedy/2008.Maximum-Earnings-From-Taxi/2008.Maximum-Earnings-From-Taxi_v1.cpp
::::::::::::::
using LL = long long;
class Solution {
public:
    long long maxTaxiEarnings(int n, vector<vector<int>>& rides) 
    {
        vector<LL>dp(n+1);
        unordered_map<int, vector<pair<int,int>>>Map; // endTime -> {startTime, gain}
        for (auto ride: rides)
            Map[ride[1]].push_back({ride[0], ride[1]-ride[0]+ride[2]});
        
        for (int i=1; i<=n; i++)
        {
            dp[i] = dp[i-1];
            for (auto ride: Map[i])
            {
                int start = ride.first, gain = ride.second;
                dp[i] = max(dp[i], dp[start] + ride.second);
            }           
        }
        return dp[n];
    }
};
::::::::::::::
Greedy/2008.Maximum-Earnings-From-Taxi/2008.Maximum-Earnings-From-Taxi_v2.cpp
::::::::::::::
using LL = long long;
class Solution {
    static bool cmp(vector<int>&a, vector<int>&b)
    {
        return a[1]<b[1];
    }
public:
    long long maxTaxiEarnings(int n, vector<vector<int>>& rides) 
    {        
        int m = rides.size();
        rides.push_back({0,0,0});        
        vector<LL>dp(m+1);
        sort(rides.begin(), rides.end(), cmp);
        
        vector<int>times;
        for (auto r: rides) times.push_back(r[1]);
        
        for (int i=1; i<=m; i++)
        {
            dp[i] = dp[i-1];
            int start = rides[i][0];
            auto iter = upper_bound(times.begin(), times.end(), start);
            if (iter!=times.begin())
            {
                int j = prev(iter)-times.begin();
                dp[i] = max(dp[i], dp[j]+rides[i][1]-rides[i][0]+rides[i][2]);
            }
                
        }
        return dp[m];
    }
};
::::::::::::::
Greedy/2008.Maximum-Earnings-From-Taxi/Readme.md
::::::::::::::
### 2008.Maximum-Earnings-From-Taxi

此题和```1235.Maximum-Profit-in-Job-Scheduling```一模一样。

#### 解法1：
考虑到地点的数目不超过1e5，所以我们可以设计dp[i]表示达到地点i所能得到的最大收益。dp[i]的来源有两种可能：第一种就是出租车从位置i-1空载而来，那么dp[i]=dp[i-1]。第二种就是有乘客在位置i下车，那么我们会额外获取一笔利润，这笔钱取决于这趟载客的行程。假设这趟载客的行程是从位置j开往i、收益为gain，那么我们关心的就会是在位置j时的最大收益dp[j]，因此位置i的最大收益就是```dp[i] = dp[j]+gain```。

注意可能会有多个生意都在i下客，即有多个可能的j，所以dp[i]会取最大值。最终答案就是返回最后一个地点的dp[n-1].

#### 解法2：
如果n的个数远远超过1e5，dp[i]设计为关于位置的函数就会造成MLE. 事实上我们并不关心所有位置的最大收益。只有在每个订单下客的位置我们才可能会有新的收益，所有我们只关心那些下客点的位置。

我们将所有的生意按照下客位置排序。我们依然可以用类似的思想，但是dp[i]对应的是到达rides[i][1]位置的最大收益。在这个位置的最大收益同样有两种可能：从上一个下客位置空载而来，即```dp[i]=dp[i-1]```。或者我们接手了一笔生意从位置rides[i][0]开到了rides[i][1]。于是我们关心的是在这笔生意的上客地点```start = rides[i][0]```时的最大收益是多少。由于start不见得恰好是一个下客位置，所以我们可能需要往前推，定位到rides里最后一个不晚于start的下客地点j。那么就可以更新```dp[i] = dp[j]+gain```.

最终答案就是返回最后一笔生意的下客地点的dp[m-1].
::::::::::::::
Greedy/2054.Two-Best-Non-Overlapping-Events/2054.Two-Best-Non-Overlapping-Events.cpp
::::::::::::::
class Solution {
    static bool cmp(vector<int>&a, vector<int>&b)
    {
        return a[1] < b[1];
    }

public:
    int maxTwoEvents(vector<vector<int>>& events) 
    {
        int n = events.size();
        sort(events.begin(), events.end(), cmp);
        
        vector<int>rollingMax(n);
        int m = 0;
        for (int i=0; i<n; i++)
        {
            m = max(m, events[i][2]);
            rollingMax[i] = m;
        }
        
        vector<int>endTimes;
        int ret = 0;
        
        for (int i=0; i<n; i++)
        {
            int a = events[i][0]-1, b = events[i][1], v = events[i][2];
            ret = max(ret, v);
            
            auto iter = upper_bound(endTimes.begin(), endTimes.end(), a);
            if (iter!=endTimes.begin())
            {
                iter = prev(iter);
                int idx = iter - endTimes.begin();
                ret = max(ret, rollingMax[idx] + v);
            }
            
            endTimes.push_back(b);
        }
        
        return ret;        
    }
};
::::::::::::::
Greedy/2054.Two-Best-Non-Overlapping-Events/Readme.md
::::::::::::::
### 2054.Two-Best-Non-Overlapping-Events

本题就是```1235. Maximum Profit in Job Scheduling```的简化版。在1235中，要求所有non-overlapping的区间的最大权重和。本题中，只需要求两个non-overlapping的区间的最大权重和。

思路差不多。将所有的区间按照endTime排序。我们考察第i个区间[a,b,v]的时候，需要考虑在a时刻之前的那些完整区间里，我们可以收获的“单个区间”的最大收益。为了方便的得到这个数据，我们设计dp数组，里面放入一系列的{time, value}，表示截止到time为止的完整区间里最大的一个value值。于是我们可以利用二分，在dp里找到最后一个小于等于a的时间戳，它所对应value值加上第i个区间本身的v，就是一对可行的解。依次类推，每处理一个区间，我们都利用这个方法找它之前的最大值与之配对。由此我们做到了所有可能配对不重不漏的枚举。

注意，处理完第i个区间后，我们需要将第i个区间的信息也加入dp数组。因为随着时间的推移，dp必然是递增的。所以当我们考虑所有前i个区间的最大值时，必然就是在dp的最后一个值与v之间取较大值vv。然后将{b,v}加入dp数组。
::::::::::::::
Greedy/2055.Plates-Between-Candles/2055.Plates-Between-Candles.cpp
::::::::::::::
class Solution {
public:
    vector<int> platesBetweenCandles(string s, vector<vector<int>>& queries) 
    {
        int n = s.size();
        vector<int>presum(n);
        int count = 0;
        for (int i=0; i<n; i++)
        {
            count += (s[i]=='*');
            presum[i] = count;
        }
        
        vector<int>last(n);
        int t = -1;
        for (int i=0; i<n; i++)
        {            
            if (s[i]=='|')
                t = i;
            last[i] = t;
        }
        
        vector<int>next(n);
        t = n;
        for (int i=n-1; i>=0; i--)
        {
            if (s[i]=='|')
                t = i;
            next[i] = t;            
        }
        
        vector<int>rets;
        for (auto q: queries)
        {
            int a = q[0], b = q[1];
            int x = next[a], y = last[b];
            
            if (x<=y && x>=a && y<=b)
                rets.push_back(presum[y] - presum[x]);
            else
                rets.push_back(0);
        }
        
        return rets;
    }
};
::::::::::::::
Greedy/2055.Plates-Between-Candles/Readme.md
::::::::::::::
### 2055.Plates-Between-Candles

很显然，对于给定的区间[a,b]里，我希望知道a右边最近的蜡烛位置x，和b左边最近的蜡烛位置y。显然，我们可以用状态机的思想提前准备好next和last数组。next[i]表示i的下一个（可以是自身）出现蜡烛的位置；last[i]表示i的前一个（可以是自身）出现蜡烛的位置。这些都可以用o(n)实现。

知道了x和y，想求区间[x,y]内的盘子数量，显然用前缀和最方便。
::::::::::::::
Greedy/2086.Minimum-Number-of-Buckets-Required-to-Collect-Rainwater-from-Houses/2086.Minimum-Number-of-Buckets-Required-to-Collect-Rainwater-from-Houses.cpp
::::::::::::::
class Solution {
public:
    int minimumBuckets(string street) 
    {
        int n = street.size();
        int ret = 0;
        
        for (int i=0; i<n; i++)
        {
            if (street[i]!='H') continue;
            
            if (i-1>=0 && street[i-1]=='#')
            {
                continue;
            }
            else if (i+1<n && street[i+1]=='.')
            {
                street[i+1] = '#';
                ret++;
            }
            else if (i-1>=0 && street[i-1]=='.')
            {
                street[i-1] = '#';
                ret++;
            }            
            else
            {
                return -1;
            }            
        }
        
        return ret;        
    }
};
::::::::::::::
Greedy/2086.Minimum-Number-of-Buckets-Required-to-Collect-Rainwater-from-Houses/Readme.md
::::::::::::::
### 2086.Minimum-Number-of-Buckets-Required-to-Collect-Rainwater-from-Houses

本题有纯粹的贪心策略。但凡遇到H，我们可定优先在右边放篮子，这样放置的篮子就可以最大程度地被后面的H所分享。当然，如果右边不能放置篮子的话，那么也只有在左边放了。

正确的逻辑顺序是：
1. 查看左边是否已经放置了篮子。有的话则skip
2. 查看右边是否可以放置篮子，是的话，就标记篮子
3. 查看左边是否可以放置篮子，是的话，就标记篮子
4. 此时说明左右都无法放置篮子，返回-1
::::::::::::::
Greedy/2111.Minimum-Operations-to-Make-the-Array-K-Increasing/2111.Minimum-Operations-to-Make-the-Array-K-Increasing.cpp
::::::::::::::
class Solution {
public:
    int kIncreasing(vector<int>& arr, int k) 
    {
        int ret = 0;
        int n = arr.size();
        
        for (int t=0; t<k; t++)
        {
            vector<int>nums;
            for (int i=t; i<n; i+=k)
                nums.push_back(arr[i]);
            ret += nums.size() - lengthOfLIS(nums);            
        }
        
        return ret;
    }
    
    int lengthOfLIS(vector<int>& nums) 
    {
        int n = nums.size();              
        vector<int>q(n, INT_MAX);
        for (int i=0; i<n; i++)
        {
            auto iter = upper_bound(q.begin(),q.end(),nums[i]);
            *iter = nums[i];
        }
        for (int i = n - 1; i >= 0; i--)
        {
            if (q[i] != INT_MAX)
                return i + 1;  
        }
        return 0;    
    }
};
::::::::::::::
Greedy/2111.Minimum-Operations-to-Make-the-Array-K-Increasing/Readme.md
::::::::::::::
### 2111.Minimum-Operations-to-Make-the-Array-K-Increasing

此题的本质就是在每个k间隔的系列里找到最长递增子序列的长度，其余未被选定的元素只需要使之与相邻的元素相同即可。这样这些未被选中的元素就对应着最少需要修改的数目。

这里的一个细节是：本题的LIS允许相同的元素。所以贪心法的时候需要用upper_bound。

此外有一个followup：如果要求构造所有元素为正、且严格的递增序列怎么办？这里会出现的一个问题是，找到LIS之后，其他元素的改动可能无法实现。比如[1,1,2]，最长严格递增序列是[1,2]，但是你无法只修改一个数字得到合法的解。方法是，将所有的元素都减去其下标(1,2,3...)，然后去除掉负数，在其中找LIS（更确切的说是非递减序列）。在这个例子中，变换后的数组是[0,-1,-1]。所以其LIS的长度其实只有1. 去掉负数的那些元素k无论如何都无法成为一个严格递增序列里面的成员，原因是它之前的元素个数太少，即使第一个元素从1开始以公差1递增，到该元素时也超过了k本身。
::::::::::::::
Greedy/2116.Check-if-a-Parentheses-String-Can-Be-Valid/2116.Check-if-a-Parentheses-String-Can-Be-Valid_v1.cpp
::::::::::::::
class Solution {
public:
    bool canBeValid(string s, string locked) 
    {
        int n = s.size();
        if (n%2!=0) return false;
        
        if (!checkRight(s, locked)) return false;
        if (!checkLeft(s, locked)) return false;
        return true;
        
    }

    bool checkRight(string s, string locked)
    {
        int unmatched = 0;
        int count = 0;
        
        for (int i = 0; i<s.size(); i++)
        {
            if (s[i]=='(')
                unmatched++;
            else
                unmatched--;

            if (locked[i]=='0' && s[i]==')')            
                count++;
            
            if (unmatched < 0)
            {
                if (count==0) return false;
                unmatched += 2;
                count--;
            }
        }
        return true;
    }
    
    bool checkLeft(string s, string locked)
    {
        int unmatched = 0;
        int count = 0;
        
        for (int i = s.size()-1; i>=0; i--)
        {
            if (s[i]==')')
                unmatched++;
            else
                unmatched--;

            if (locked[i]=='0' && s[i]=='(')            
                count++;
            
            if (unmatched < 0)
            {
                if (count==0) return false;
                unmatched += 2;
                count--;
            }
        }
        return true;
    }
};
::::::::::::::
Greedy/2116.Check-if-a-Parentheses-String-Can-Be-Valid/2116.Check-if-a-Parentheses-String-Can-Be-Valid_v2.cpp
::::::::::::::
class Solution {
public:
    bool canBeValid(string s, string locked) 
    {
        if (s.size() % 2 != 0) return false;
        int upper = 0, lower = 0;
        for (int i=0; i<s.size(); i++)
        {
            if (locked[i]=='1')
            {
                if (s[i]=='(')
                {
                    upper += 1;
                    lower += 1;
                }                    
                else
                {
                    upper -= 1;
                    lower -= 1;
                }
            }
            else
            {
                upper += 1;
                lower -= 1;
            }            

            if (lower < 0)
                lower += 2;

            if (upper < 0) return false;            
        }        
        
        return lower == 0;        
    }
};
::::::::::::::
Greedy/2116.Check-if-a-Parentheses-String-Can-Be-Valid/Readme.md
::::::::::::::
### 2116.Check-if-a-Parentheses-String-Can-Be-Valid

#### 解法1：Two Pass
我们用count来表示未被匹配的左括号的数目。然后我们从左往右遍历每一个字符。显然，遇到左括号的时候count加一，遇到右括号的时候count减一。如果某一时刻发现count小于0了，说明有一个右括号注定在它之前找不到左括号与之匹配，那么为了“挽救”，我们只有唯一的对策：在之前某一个允许改动的地方将右括号改为左括号。这样的后果是count+=2。可见我们在遍历的过程中需要另外一个计数器，就是记录有多少个unlocked的右括号（以便于做所述的改动）。如果我们从左往右遍历完，count始终为正，那么说明所有的右括号（扣除那些必须改为左括号的右括号）都一定有与之配对的左括号。

同理，从左往右遍历，查看是否所有的左括号（扣除那些必须改为右括号的左括号）都一定有与之配对的右括号。如果Two Pass的check都通过的话，那么就可以返回true。

那么满足以上两个条件是否就是返回true的充要条件呢？事实上确实如此，你找不出反例。

#### 解法2：One Pass
本题其实就是LC 678的follow up。我们把那些unlocked的字符看成是星号，但是只允许替换成左括号或者右括号（不能设置为空）。

我们设置upper表示最多可能有多少个未被匹配的左括号，lower表示最少可能有多少个未被匹配的左括号。upper和lower的区别就在于对于那些待定字符如何处理：如果我们无脑设为'('的话，upper就会增1，如果无脑设为')'的话，那么lower就会减1. 另外，如果遇到那些locked的字符，那么upper和lower的增减就是一致的。

变化出现在如果发现lower<0的时候，那说明我们设置')'的策略过于激进，不能无脑地将所有待定字符设置为右括号。所以我们必须“让出”一个被变为右括号的星号，转而让其变为左括号。注意，这样一正一反的修正，lower就会增2.

判定的条件是：在遍历的过程中，如果任何时候发现upper<0，那么说明即使激进的设置左括号也不够用（与右括号匹配），就可以返回false。此外，最终为了表示平衡，lower必须为0. 如果lower大于0，说明“激进地加右括号”的策略也无法匹配所有的左括号，自然也是无解。
::::::::::::::
Greedy/2122.Recover-the-Original-Array/2122.Recover-the-Original-Array.cpp
::::::::::::::
using LL = long long;
class Solution {
public:
    vector<int> recoverArray(vector<int>& nums) 
    {
        int n = nums.size()/2;
        sort(nums.begin(), nums.end());
        
        for (int i=1; i<=n; i++)
        {
            if (nums[i]==nums[0]) continue;
            if ((nums[i]+nums[0])%2==1) continue;
            int mn = (nums[i]+nums[0])/2;
            int k = (nums[i]-nums[0])/2;

            int left = 0, right = 1;
            int flag = 1;
            vector<int>visited(2*n);
            vector<int>rets;
            for (int t=0; t<n; t++)
            {
                while (visited[left]) left++;
                if (left==2*n)
                {
                    flag = 0;
                    break;
                }
                visited[left] = 1;
                while (right<2*n && (visited[right]==1 || nums[right]!=nums[left]+2*k))
                    right++;
                if (right<2*n)
                    visited[right] = 1;
                else
                {
                    flag = 0;
                    break;
                }                
                rets.push_back(nums[left]+k);    
            }
            if (flag)
                return rets;
        }
        return {};        
    }
};
::::::::::::::
Greedy/2122.Recover-the-Original-Array/Readme.md
::::::::::::::
### 2122.Recover-the-Original-Array

我们将nums排序后，可以肯定的是，最小值一定是原先original里面的最小值mn减去k。那么如何能够知道mn或者k呢？自然我们想到original里面一定还存在mn+k，如果我们遍历元素并假设它是mn+k，那么我们就可以得到k，于是整个original的元素就可以试图从小到大依次确定下来（和LC 2007差不多的思想）；如果不成功就换一个元素作为mn+k。所以此题用o(N^2)可解。

更具体地，如果我们知道了k，可以用双指针的解法来确定original。将nums排序之后，我们设置left和right两个指针。对于nums[left]而言，我们一定是单调递增地移动right，试图寻找满足```nums[right]==nums[left]+2k```的位置。找到这对之后，将used[left]和used[right]都标记为1，这样在后续的寻找中，无论left和right都不能指向已经用过的位置。

双指针遍历的过程中，我们期望恰好找到n对。任何时候，left或right越界了，说明我们无法找到下一个合适的配对，就返回空集。
::::::::::::::
Greedy/2136.Earliest-Possible-Day-of-Full-Bloom/2136.Earliest-Possible-Day-of-Full-Bloom_v1.cpp
::::::::::::::
class Solution {
public:
    int earliestFullBloom(vector<int>& plantTime, vector<int>& growTime) 
    {
        int n = plantTime.size();
        vector<vector<int>>time(n);
        for (int i=0; i<n; i++)
        {
            time[i] = {plantTime[i], -growTime[i]};            
        }
        sort(time.begin(), time.end(), [](vector<int>&a, vector<int>&b){return a[1]<b[1];});
        
        int left = 1, right = INT_MAX/2;
        while (left < right)
        {
            int mid = left+(right-left)/2;
            if (checkOK(mid, time))
                right = mid;
            else
                left = mid+1;
        }
        return left;        
    }
    
    bool checkOK(int T, vector<vector<int>>&time)
    {
        int n = time.size();
        int days = 0;
        
        for (int i=0; i<n; i++)
        {
            days += time[i][0];
            
            if (days > T+time[i][1])
            {
                return false;
            }
        }        
        return true;      
    }
};
::::::::::::::
Greedy/2136.Earliest-Possible-Day-of-Full-Bloom/2136.Earliest-Possible-Day-of-Full-Bloom_v2.cpp
::::::::::::::
class Solution {
public:
    int earliestFullBloom(vector<int>& plantTime, vector<int>& growTime) 
    {
        int n = plantTime.size();
        vector<vector<int>>time(n);
        for (int i=0; i<n; i++)
        {
            time[i] = {plantTime[i], growTime[i]};            
        }
        sort(time.begin(), time.end(), [](vector<int>&a, vector<int>&b){return a[1]>b[1];});
        
        int ret = 0;
        int days = 0;
        for (int i=0; i<n; i++)
        {
            days+=time[i][0];
            ret = max(ret, days+time[i][1]);
        }
        return ret;
    }
};
::::::::::::::
Greedy/2136.Earliest-Possible-Day-of-Full-Bloom/Readme.md
::::::::::::::
### 2136.Earliest-Possible-Day-of-Full-Bloom

假设最后的统一开花日是T，那么growTime越长的花所留给我们的种植时间越短，我们必须优先把此花搞定。所以按照种植完成的deadline从早到晚排序，这就是我们的最优策略。

有了种植的顺序，我们依次遍历每个花，就有了各自的种植完成时刻。然后比较每朵花“种植完成时刻+growTime”，最大值就是最终的统一开花日期。
::::::::::::::
Greedy/2163.Minimum-Difference-in-Sums-After-Removal-of-Elements/2163.Minimum-Difference-in-Sums-After-Removal-of-Elements.cpp
::::::::::::::
using LL = long long;
class Solution {
public:
    long long minimumDifference(vector<int>& nums) 
    {
        int n = nums.size()/3;
        
        vector<LL>leftMin(3*n); 
        priority_queue<int>pq;
        LL sum = 0;
        for (int i=0; i<3*n; i++)
        {
            pq.push(nums[i]);
            sum += nums[i];
            if (pq.size() > n)
            {
                sum -= pq.top();
                pq.pop();
            }
            leftMin[i] = sum;            
        }
        
        vector<LL>rightMax(3*n);
        priority_queue<int, vector<int>, greater<>>pq2;
        sum = 0;
        for (int i=3*n-1; i>=0; i--)
        {
            pq2.push(nums[i]);
            sum += nums[i];
            if (pq2.size() > n)
            {
                sum -= pq2.top();
                pq2.pop();
            }
            rightMax[i] = sum;            
        }
        
        LL ret = LLONG_MAX;
        for (int i=n-1; i<2*n; i++)
            ret = min(ret, leftMin[i]-rightMax[i+1]);
            
        return ret;        
    }
};

::::::::::::::
Greedy/2163.Minimum-Difference-in-Sums-After-Removal-of-Elements/Readme.md
::::::::::::::
### 2163.Minimum-Difference-in-Sums-After-Removal-of-Elements

因为删除n个元素之后，剩余的2n个元素会自然地分成前后两个部分，所以我们很自然地会考察这两个部分的分界点在哪里。假设分界点在位置k，那么sum_first怎么选？自然就是nums[0:k]里面和最小的n个元素；sum_second怎么选？自然就是nums[k+1:n-1]里面和最大的n个元素。

于是问题转化为，如何高效地在前k个元素里找和最小的n个元素？显然我们就找最小的n个元素即可。从做往右遍历的时候，用一个优先队列始终保存n个最小的元素，就可以得到k左边最小的n个元素的和，记做leftMin[k]。同理我们可以用NlogN的时候，从右往左遍历，得到rightMax[k]，表示k右边最大的n个元素的和。

本题的答案就是找一个全局最小的```leftMin[k]-rightMax[k+1]```.
::::::::::::::
Greedy/2167.Minimum-Time-to-Remove-All-Cars-Containing-Illegal-Goods/2167.Minimum-Time-to-Remove-All-Cars-Containing-Illegal-Goods_v1.cpp
::::::::::::::
class Solution {
public:
    int minimumTime(string s) 
    {
        int n = s.size();
        vector<int>pre(n);
                
        vector<int>left(n);
        left[0] = s[0]=='0'?0:1;
        for (int i=1; i<n; i++)
        {
            if (s[i]=='0')
                left[i] = left[i-1];
            else
                left[i] = min(2+left[i-1], i+1);
        }
                
        vector<int>right(n);
        right[n-1] = s[n-1]=='0'?0:1;
        for (int i=n-2; i>=0; i--)
        {
            if (s[i]=='0')
                right[i] = right[i+1];
            else
                right[i] = min(2+right[i+1], n-i);
        }
        
        int ret = min(left[n-1], right[0]);
        for (int i=1; i<n-1; i++)
            ret = min(ret, left[i]+right[i+1]);
                        
        return ret;
    }
};
::::::::::::::
Greedy/2167.Minimum-Time-to-Remove-All-Cars-Containing-Illegal-Goods/2167.Minimum-Time-to-Remove-All-Cars-Containing-Illegal-Goods_v2.cpp
::::::::::::::
class Solution {
public:
    int minimumTime(string s) 
    {
        int n = s.size();
        
        vector<int>pre(n);        
        pre[0] = (s[0]=='1');
        for (int i=1; i<n; i++)
            pre[i] = pre[i-1]+(s[i]=='1');
        
        vector<int>arr(n);
        for (int i=0; i<n; i++)
            arr[i] = 2*pre[i] - i;
        
        int ret = n;        
        int preMax = 1;
        for (int i=0; i<n; i++)
        {
            ret = min(ret, arr[i]-preMax+n);
            preMax = max(preMax, arr[i]);
        }            
        
        return ret;
    }
};
::::::::::::::
Greedy/2167.Minimum-Time-to-Remove-All-Cars-Containing-Illegal-Goods/Readme.md
::::::::::::::
### 2167.Minimum-Time-to-Remove-All-Cars-Containing-Illegal-Goods

#### 解法1
我们可以知道，左边有一部分元素是用法则一处理，右边有一部分元素是用法则二处理，中间有一部分是用法则三处理。这里就涉及到了三部分的两个边界，这意味着我们可能要用N^2的复杂度来遍历这些边界并计算代价。本题有一个巧妙的解法，就是令dp1[i]表示[0:i]这些元素用法则一、三处理（即删除元素1）需要的最少代价；同理令dp2[i]表示[i:n-1]这些元素用法则二、三处理需要的最少代价。这样我们只需要遍历一个边界即可。

对于dp1[i]，我们需要根据s[i]是否是1来做不一样的决策. 如果s[i]本身是0，那么0不需要删除也就不需要增加额外的代价，故有```dp1[i]=dp1[i-1]```. 

如果s[i]是1，那么我们有两种方法：
  1. 如果元素i是按照法则一删除，那么意味着[0:i]都是逐个从左往右删除的，故有```dp1[i]=i+1```. 
  2. 如果元素i是按照法则三删除，那么删除s[i]本身需要付出2的代价，在此之前，我们就可以复用dp1[i-1]，因为我们并不关心在元素i之前具体使用什么法则实现dp[i-1]的，无论法则一还是三，都不影响我用法则三来删除s[i]。    

综上，我们有```dp1[i] = min(i+1, dp[i-1]+2)```

同理我们可以得到dp2[i]，那么最终答案就是找全局最大的```dp`[i]+dp2[i+1]```.

#### 解法2
本题就是要找两个分界点i和j，使得[0:i-1]这部分按照法则1删除，代价就是i; [j+1:n-1]这部分按照法则2删除，代价就是n-j-1; 中间部分按照法则3删除，代价是[i:j]之间的元素1的个数乘以2。

于是我们可以将本题转化为求解最小化的```i + 2*(presum[j]-presum[i-1]) + n-j-1```，其中presum[k]表示[0:k]区间内有多少个元素1. 

将上式再转化一下，即```min {(2*presum[j]-j) - (2*presum[i-1]-(i-1)) + n}```. 很显然，我们构造新的数列```nums[i]=2*presum[i]-i```，即求```min (arr[j] - arr[i-1]) + n, where i<j```。注意特别地，i是可以取0的， 故arr[-1]需要取值为```2*presum[-1]+1 = 1```. 因此我们要在arr数组的最前端额外加上1. 

另外，需要思考一下，如果全程只是法则1或者2，那么上述分析的[i:j]区间不存在，这意味着我们必须从左到右依次删去全部，故ret要有一个初始值就是n。
::::::::::::::
Greedy/2170.Minimum-Operations-to-Make-the-Array-Alternating/2170.Minimum-Operations-to-Make-the-Array-Alternating.cpp
::::::::::::::
class Solution {
    static bool cmp(pair<int,int>&a,pair<int,int>&b)
    {
        return a.second > b.second;
    }
public:
    int minimumOperations(vector<int>& nums) 
    {
        int n = nums.size();
        if (n==1) return 0;
        
        unordered_map<int,int>Map1;
        unordered_map<int,int>Map2;
        int count1 = 0, count2 = 0;
        for (int i=0; i<n; i+=2)
        {
            Map1[nums[i]]++;
            count1++;
        }
        for (int i=1; i<n; i+=2)
        {
            Map2[nums[i]]++;
            count2++;
        }
        
        vector<pair<int,int>>temp1(Map1.begin(), Map1.end());        
        vector<pair<int,int>>temp2(Map2.begin(), Map2.end());
        sort(temp1.begin(), temp1.end(), cmp);
        sort(temp2.begin(), temp2.end(), cmp);
        
        if (temp1.size()==1) temp1.push_back({0,0});
        if (temp2.size()==1) temp2.push_back({0,0});
                
        if (temp1[0].first!=temp2[0].first)
            return n - temp1[0].second - temp2[0].second;
        else
        {
            int x = count1 - temp1[0].second + count2 - temp2[1].second;
            int y = count1 - temp1[1].second + count2 - temp2[0].second;
            return min(x,y);
        }
    }
};
::::::::::::::
Greedy/2170.Minimum-Operations-to-Make-the-Array-Alternating/Readme.md
::::::::::::::
### 2170.Minimum-Operations-to-Make-the-Array-Alternating

我们将所有偶数位的数字和所有奇数位的数字分别进行频率统计，保存至数组Map1和Map2，并且按照频率从大到小排序。

如果Map1和Map2分别词频最高的数字不相同，那么意味着最优方案就是保留这两种数字。如果Map1和Map2分别词频最高的数字相同，那么要么保留Map1最高频的数字+Map2次高频的数字，或者保留Map1次高频的数字+Map2最高频的数字。

特别注意，Map1和Map2保存的数字种类可能只有1种，需要特别处理。
::::::::::::::
Greedy/2171.Removing-Minimum-Number-of-Magic-Beans/2171.Removing-Minimum-Number-of-Magic-Beans.cpp
::::::::::::::
using LL = long long;
class Solution {
public:
    long long minimumRemoval(vector<int>& beans) 
    {
        sort(beans.rbegin(), beans.rend());
        LL total = accumulate(beans.begin(), beans.end(), 0LL);

        LL ret = LLONG_MAX;
        for (int i=0; i<beans.size(); i++)
        {            
            ret = min(ret, total - (LL)beans[i]*(i+1));
        }
        return ret;        
    }
};
::::::::::::::
Greedy/2171.Removing-Minimum-Number-of-Magic-Beans/Readme.md
::::::::::::::
### 2171.Removing-Minimum-Number-of-Magic-Beans

本题的关键是我们要有直觉，最终所有袋子的统一的豆子数目，一定等于原始袋子里某一袋的数目。这可以用反证法说明。我们将所有的豆子按照从大到小的顺序排列，假设最优解对应的最终每袋豆子数是k，介于beans[i]和beans[i+1]之间，那么我们必然要把第i+1袋到最后一袋的豆子都拿走，同时将前i袋里每袋豆子都降至数目k。显然，这不会是最优解，因为我们如果将答案k上调为为beans[i]，依然把第i+1袋到最后一袋的豆子都拿走，但前i袋豆子需要拿走的数目会变少。所以最终的k一定是某个beans[i]。

我们将beans从大到小排列之后，可以遍历一遍每个beans[i]查验如果它是最终解，那么需要移动的豆子总数包括两部分：前i袋需要移走```sum[0:i] - beans[i]*(i+1)```，后i袋需要全部拿走```sum[i+1:n-1]```。因此本题就是寻找```sum[0:n-1] - beans[i]*(i+1)```全局最小值所对应的i。

::::::::::::::
Greedy/2182.Construct-String-With-Repeat-Limit/2182.Construct-String-With-Repeat-Limit.cpp
::::::::::::::
class Solution {
public:
    string repeatLimitedString(string s, int repeatLimit) 
    {
        unordered_map<char,int>Map;
        for (auto ch: s)
            Map[ch]++;
        
        priority_queue<pair<char,int>>pq;
        
        for (auto x:Map)
            pq.push(x);
        
        string ret;
        while (!pq.empty())
        {
            auto x = pq.top();
            pq.pop();
            
            if (x.second <= repeatLimit)
            {
                for (int i=0; i<x.second; i++)
                    ret.push_back(x.first);
                continue;
            }
            
            int k = min(x.second, repeatLimit);
            for (int i=0; i<k; i++)
                ret.push_back(x.first);            
            x.second -= k;
                        
            if (pq.empty()) return ret;
            
            auto y = pq.top();
            pq.pop();
            ret.push_back(y.first);
            y.second -= 1;
            
            if (x.second!=0)
                pq.push(x);
            if (y.second!=0)
                pq.push(y);
        }
        
        return ret;        
    }
};
::::::::::::::
Greedy/2182.Construct-String-With-Repeat-Limit/Readme.md
::::::::::::::
### 2182.Construct-String-With-Repeat-Limit

非常直观的贪心策略。所有的字母统计频次之后，按照字典序从大到小放入pq里。有这么几种情况：
1. 最大的字母少于或者等于repeatLimit个，那么就将其全部取出。
2. 最大的字母有多于repeatLimit个，那么就取出repeatLimit个，同时再取次大的字母一个。将最大和次大字母再塞入pq中（如果还有的话）。
3. 最大的字母有多于repeatLimit个，那么就取出repeatLimit个，此时pq里没有次大的字母，就直接返回。
::::::::::::::
Greedy/2193.Minimum-Number-of-Moves-to-Make-Palindrome/2193.Minimum-Number-of-Moves-to-Make-Palindrome_v1.cpp
::::::::::::::
class Solution {
public:
    int minMovesToMakePalindrome(string s) 
    {
        int n = s.size();
        int ret = 0;
        int count = 0; // how many left-pair characters have been processed
        
        for (int i=0; i<n/2; i++)
        {            
            int j = n-1-count;
            while (s[j]!=s[i]) j--;
            if (i==j)
            {
                int k = n/2-j;
                ret += k;
            }
            else
            {
                int k = n-1-count-j;
                ret += k;
                while (k--)
                {
                    swap(s[j], s[j+1]);
                    j++;
                }         
                count++;
            }
        }
        
        return ret;
    }
};
::::::::::::::
Greedy/2193.Minimum-Number-of-Moves-to-Make-Palindrome/2193.Minimum-Number-of-Moves-to-Make-Palindrome_v2.cpp
::::::::::::::
class Solution {
    int temp[50001];
public:
    int minMovesToMakePalindrome(string s) 
    {
        int n = s.size();
        int count = 0; // how many left-pair characters have been processed
        int ret = 0;
        
        unordered_map<char, deque<int>>dq;
        for (int i=0; i<n; i++)
            dq[s[i]].push_back(i);
        
        vector<int>arr;
        for (int i=0; i<n; i++)
        {
            if (dq[s[i]].empty())
                continue;
            else if (dq[s[i]].size()==1)
            {
                ret += i + (n/2-count) - n/2;
                dq[s[i]].pop_back();
            }
            else
            {
                arr.push_back(dq[s[i]].back());
                dq[s[i]].pop_front();
                dq[s[i]].pop_back();
                ret += i-count;
                count++;                
            }
        }
        
        reverse(arr.begin(), arr.end());
        return ret + reversePairs(arr);
    }
    
    int reversePairs(vector<int>& nums) 
    {
        int n = nums.size();
        vector<int>sorted = nums;        
        return helper(nums, sorted, 0, n-1);        
    }

    int helper(vector<int>& nums, vector<int>& sorted, int a, int b)
    {
        if (a>=b) return 0;
        int ret = 0;
        int mid = a+(b-a)/2;
        ret += helper(nums, sorted, a, mid);
        ret += helper(nums, sorted, mid+1, b);

        for (int j=mid+1; j<=b; j++)
        {
            auto iter = upper_bound(sorted.begin()+a, sorted.begin()+mid+1, (long)nums[j]);
            ret += sorted.begin()+mid+1 - iter;
        }
        sort(sorted.begin()+a, sorted.begin()+b+1);
        return ret;
    }
};
::::::::::::::
Greedy/2193.Minimum-Number-of-Moves-to-Make-Palindrome/Readme.md
::::::::::::::
### 2193.Minimum-Number-of-Moves-to-Make-Palindrome

#### 解法1：贪心加暴力模拟
这道题存在着一个非常直观的贪心策略，我们从左往右遍历每个字符s[i]，找到与它能够组成回文对称的那个s[j]，那么将其从j移动到与s[i]回文对称的位置（在总长度是偶数的条件下就是n-1-i）即可。如果暴力地用swap来模拟这个过程，那么就是o(N^2)的复杂度：遍历i是o(N)，对于每个i，用o(N)找到j，并且将j移动到n-1-i。

那么这个贪心策略如何证明呢？也就是说，如果当前字符串最左边是x，那么为什么我们贪心地就把一对x调整到最外层，而不是把其他的一对y调整到最外层呢？我们不失一般性地描述出x和y可能的位置位置关系：
1. ```x ... y... y ... x .....``` 很明显，我们必然先搬动这对x到外侧，再搬动这对y到x的内侧
2. ```x ..(a).. y..(b).. x ..(c).. y ..(d)..``` 我们用abcde表示每段区间的长度。    
    (1) 策略1是将x搬动到外侧，那么需要 0 + (c+d+1)，再搬动y到x的内侧，需要(a) + (d)    
    (2) 策略2是将y搬动到外侧，那么需要 (a+1) + (d)，再搬动x到y的内侧，需要 0 + (c+d)    
    我们惊奇地发现上面两种策略的总和都是 2d+a+d+1
3. ```x ..(a).. x..(b).. y ..(c).. y ..(d)..``` 
    (1) 策略1是将x搬动到外侧，那么需要 (0) + (b+c+d+2)，再搬动y到x的内侧，需要 (a+b) + (d)
    (2) 策略2是将y搬动到外侧，那么需要 (a+b+2) + (d)，再搬动x到y的内侧，需要(0) + (b+c+d)    
    我们惊奇地发现上面两种策略的总和都是 2d+a+b+c+2
    
所以我们得出结论，无论什么情况下，我们只需要把最左边的x固定，将另一个对称的x放到左右边，就是当前的最佳策略。处理完之后就可以剥除最外面一对，递归处理剩下的字符串即可。

补充：为什么我们要关注次外层？这里的逻辑是，我们如果想证明“把x放在最外层”比“把y放在最外层”的操作更优，我们除了要计算x和y的移动次数之外，还必须保证两种操作结束之后剩下的字符串状态是一样的，这样才是公平的比较。单纯地把x移到最外层、或单纯地把y移到最外层，遗留的字符串状态大概率还是不一样，我们也就无法得知后续操作谁更有优势。在视频的分析中，无论我们选哪个y，x都更比y更适合作为最外层，那么显然x就是做为最外层的最优解。

OK，以上我们只是考虑了总长度是偶数的情况。如果回文串长度是奇数，那么在上述“递归处理”的过程中，我们会遇到这样一种情况：此时字符串的最左边是一个仅出现一次的字符（记做w）。那么我们要对w做什么处理呢？答案是我们应该直接忽略掉它，先处理下一个。也就是说，只有在处理完剩下的所有配对之后，再去考察w需要位移几次（就是n/2与w所在index之差）。比如说waabb，正解是忽略w，先调整得到wabba，再将w插入abba的中央，总的交换次数是4. 如果我们试图先将w放入中央得到aawbb，那么再使得aabb对称的话，总的交换次数就需要2+3。

#### 解法2：贪心加统计逆序对
上面的贪心解法配合的是暴力移动。事实上我们有“虚拟移动”的方法来提高效率。

根据前面的分析，最优的做法其实分三步：1. 将所有配对字符的左半边，按照其出场顺序移动到字符串的左侧。2. 如果总长度是奇数，那么将落单的字符移动到n/2的位置。3. 此时剩余的字符（即所有配对字符的右半边）仍然是按照出场顺序排列的，但是都已经挪到了字符串的右侧，此时我们只需要将这个乱序的substring进行操作，使得顺序变得和左侧（更确切地说是与左侧的倒序）一致即可。

举个例子，假设在第1步里第一个遇到的是字符a，与之配对的另一个a的位置是7；第二个遇到的是字符b，与之配对的另一个b的位置是5；第三个遇到的是字符c，与之配对的另一个c的位置是9. 那么说明在原始串579这些位置的字符，我们希望通过adjacent swap的操作最终变为957的顺序。因为最右侧的7对应着与a配对，中间的5对应着与b配对，左边的9对应着与c配对。

那么需要多少次adjacent swap使得579变成957呢？这个问题等价于将一个乱序957变成顺序579. 这是一个经典题，答案是统计所有逆序对的个数。在这里(9,5)和(9,7)是逆序对（即前者大于后者），所以我们只需要两次交换就可以将957->579. 而求逆序对，就是LC.493的原题。

别忘了第1步和第2步我们也需要统计交换的次数。我们需要用count来统计在第一步的过程中已经处理了多少个left-pair的字符，那么我们在遇到一个新的left-pair字符时（记当前位置是i），那么意味着我们要将它从位置i移动到位置count，所以需要i-count次操作。

如果我们在位置i遇到了前述的落单字符w，那么它需要移动多少次呢？注意，我们本质上是需要把所有left-pair都处理完（即第一步）之后再计算w的移动次数。第一步处理完之后，意味着会有n/2-count个left-pair字符会移动到w前面，这意味着它的位置其实是被挤到后面去了，实际是i+(n/2-count)。然后我们需要将w放置在w/2的地方，所以移动步数是```i+(n/2-count) - n/2 = i-count```.

::::::::::::::
Greedy/2202.Maximize-the-Topmost-Element-After-K-Moves/2202.Maximize-the-Topmost-Element-After-K-Moves.cpp
::::::::::::::
class Solution {
public:
    int maximumTop(vector<int>& nums, int K) 
    {
        int n = nums.size();        
        int ret = INT_MIN;
        for (int i=1; i<=n; i++)
        {
            int k = K;
            if (k<i-1) continue;
            k -= (i-1);
            int flag = 0;

            if (k==0)
                flag = 1;
            else if (k==1)
                flag = 0;
            else if (k%2==0)
                flag = 1;
            else if (k%2==1 && i<n)
                flag = 1;
            else if (k%2==1 && i>1)
                flag = 1;

            if (flag) ret = max(ret, nums[i-1]);
        }
        return ret==INT_MIN? -1:ret;
    }
};
::::::::::::::
Greedy/2202.Maximize-the-Topmost-Element-After-K-Moves/Readme.md
::::::::::::::
### 2202.Maximize-the-Topmost-Element-After-K-Moves

我们逐个元素考虑，对于第i个元素（以1-index记），它能否被K次操作之后排在队列的首位？

首先，我们为了将第i个元素放在首位，我们必须把前i-1个元素拿掉。这i-1次的remove操作是可以提前做而不影响最终结果的。注意，push的操作不能提前做，因为必须要先有removed的元素才能使得push操作有意义；反之，remove的操作不依赖于push，可以放心地提前。

将k自减i-1后，我们的目标元素就已经在队列首位了。此时假设我们还有k次操作要做，那么就分情况讨论。

1. k==0，那么无需操作，现状就是期待的效果
2. k==1，那么此时我们无论是remove还是push，都无法再让第i个元素出现在队列首位了。
3. 如果k是偶数，那么显然，我们可以通过反复remove和push队首元素，使得第i个元素始终保持在队列首位。
4. 如果k是奇数，其实也有办法。那就是先remove当前的两个元素、再push回第i个元素。然后再反复remove和push第i个元素，消耗偶数次的操作。注意，这个方法的前提是存在第i+1个元素。
5. 类似于4有一种容易被忽略的想法。那就是先remove第i个元素，再依次push会第i-1个元素和第i个元素。然后再反复remove和push第i元素，消耗偶数次的操作。注意这个方法不需要存在第i+1个元素，但需要存在第i-1个元素。

以上几种情况能保证第i个元素能通过操作后被放置在队列首位。我们在所有符合条件的元素里找最大值即可。
::::::::::::::
Greedy/2216.Minimum-Deletions-to-Make-Array-Beautiful/2216.Minimum-Deletions-to-Make-Array-Beautiful.cpp
::::::::::::::
class Solution {
public:
    int minDeletion(vector<int>& nums) 
    {
        int n = nums.size();
        int ret = 0;
        
        int i = 0;        
        
        while (i<n)
        {            
            int j = i+1;
            while (j<n && nums[j]==nums[i])
            {
                ret++;
                j++;
            }
            
            if (j<n)
            {
                i = j+1;
            }
            else
            {
                ret++;
                break;
            }                
        }
        
        return ret;        
    }
};
::::::::::::::
Greedy/2216.Minimum-Deletions-to-Make-Array-Beautiful/Readme.md
::::::::::::::
### 2216.Minimum-Deletions-to-Make-Array-Beautiful

此题容易想到一种贪心策略，就是从左往右，每两个作为一个pair，依次尝试构建相邻的互异元素。如果发现有一对元素是相同的，那就删去（任意）其中一个，将剩下的一个尝试与右边的元素继续配对，以此构造一对相邻的互异元素。直至整个序列都被处理完。

那么这种贪心策略是否正确呢？事实上，当我们第一次遇到一对相邻的相同元素时，其实有两种策略。举个例子```... X Y | 2 2 | Z W ... ```

第一种方法，就是如上所说，我们删掉一个2，然后尝试将剩下的2与右边的Z配对，变成```... X Y | 2 Z W ... ```

第二种方法，就是如上所说，我们删掉前面的Y（或者其他任何在2之前的元素），这样会将这对2拆开，试图将第一个2与之前的元素X配对，第二个2与之后的元素配对，这样就变成了```... X 2 | 2 Z W ... ```

很显然，这两种方案产生的后半部分（即```2ZW...```）是完全一样的。而对于前半部分，第一种方法里X和Y已经是互异的了（因为我们约定这一对2是第一次遇到的一对相邻的相同元素）；但第二种方法引入了一个不确定的因素，即X与2是否互异我们不得而知，有可能需要更多的操作来使得前半部分满足条件。所以总的来说第二种方法是不合算的。
