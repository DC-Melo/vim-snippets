priority -50

###########################################################################
#                            TEXTMATE SNIPPETS                            #
###########################################################################
snippet listNodeDefination "list node python" b
class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None
$0
endsnippet

snippet treeNodeDefination "tree node python" b
class Node(object):
  def __init__(self,item):
    self.item = item
    self.left = None
    self.right = None
$0
endsnippet
snippet classInit "init class with parameter" b
# class definition
class ${1:Myclass}:
    # define property
    ${2:name}= ''
    ${3:age}= 0
	# define private property, could not access outside
    __${4:weight}= 0
    # define construction
    def __init__(self,n,a,w):
        self.$2= n
        self.$3= a
        self.__$4 = w
    def speak(self):
        print("%s say: i am %d old" %(self.$2,self.$3))

# new instantiate 
p = $1('runoob',10,30)
p.speak()
$0
endsnippet

snippet withopen "with open system argv[1]" b
with open(sys.argv[1],'r',encoding='utf-8-sig') as f:
	all_line_list = f.readlines()
$0
endsnippet

snippet readFileChunks "read file by chunks" b
def read_in_chunks ( filePath , chunk_size = 1024*1024):
    """
    Lazy function (generator) to read a file piece by piece.
    Default chunk size: 1M
    You can set your own chunk size
    """
    file_object = open (filePath)
    while True :
        chunk_data = file_object.read(chunk_size)
        if not chunk_data :
        break
        yield chunk_data


for chunk in read_in_chunks('/path/to/file'):
    process (chunk)
$0
endsnippet

snippet translatePyScript "translate python script" b
from urllib import request, parse
import json
import sys
def fanyi(content):
    req_url = 'http://fanyi.youdao.com/translate'
    head_data = {}
    head_data['Referer'] = 'http://fanyi.youdao.com/'
    head_data['User-Agent'] = 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36X-Requested-With: XMLHttpRequest'
    form_data = {}
    form_data['i'] = content
    form_data['doctype'] = 'json'
    data = parse.urlencode(form_data).encode('utf-8')
    req = request.Request(req_url, data, head_data)
    response = request.urlopen(req)
    html = response.read().decode('utf-8')
    translate_results = json.loads(html)
    translate_results = translate_results['translateResult'][0][0]['tgt']
    # print(translate_results)
    return translate_results
 
if __name__ == '__main__':
    with open(sys.argv[1], "r") as f: #.txt的位置
        lines = f.readlines()
    for line in lines:
        eng=fanyi(line)
        print(eng)
    f.close()
$0
endsnippet


snippet printWords2Cloud "print words files to cloud" b
#pip install jieba
#pip install wordcloud
#pip install scipy
#pip install matplotlib
import sys
import jieba
from wordcloud import WordCloud,ImageColorGenerator
import matplotlib.pyplot as plt
from scipy.misc import imread

print("word file name:",sys.argv[2])
data = open(sys.argv[1],"r",encoding='utf-8').read()
cutData = jieba.cut(data, cut_all=True)
# jieba.cut 方法接受三个输入参数: 需要分词的字符串；cut_all 参数用来控制是否采用全模式；HMM 参数用来控制是否使用 HMM 模型。
word = " ".join(cutData)#把分词链接起来，加空格因为英文靠空格分词

print("picture file name:",sys.argv[1])
bg_pic = imread(sys.argv[2])#读取图片
wordcloud = WordCloud(mask=bg_pic,background_color='white',font_path="/home/dc/.local/share/fonts/微软雅黑Bold.ttf",max_words=1000,max_font_size=150,scale=1).generate(word)
image_colors = ImageColorGenerator(bg_pic)#从背景图片生成颜色值
plt.imshow(wordcloud)#使图片颜色跟字体颜色一样，合并一起

plt.axis("off")#关闭显示坐标
#plt.show()
wordcloud.to_file(sys.argv[3])#保存到文件
$0
endsnippet

snippet decoratorFormwork "decorator Formwork" b
def decorator(para):
    """TODO: Docstring for decorator.
    :arg1: TODO
    :returns: TODO
    """
	def function(func):
		"""TODO: Docstring for decorator.
		:arg1: TODO
		:returns: TODO
		"""
		def wraper( *args, **kwargs,):
			"""TODO: Docstring for wraper.
			:returns: TODO
			"""
			print("start...")
			func( *args, **kwargs,)
			print("end...")
		return wraper
	return function


def function(arg1):
    print('function runing'+arg1)

function= decorator("decPara")(function)
function("funPara")

$0
endsnippet

snippet iteratorFormwork "iterator Formwork" b
#!/usr/bin/env python
# coding=utf-8
class Fib:

    """Docstring for Fib. """

    def __init__(self,n):
        """TODO: to be defined. """
        self.prev = 0
        self.cur = 1
        self.n = n
    def __iter__(self):
        return self

    def __next__(self):
        if self.n > 0:
           self.prev, self.cur = self.cur, self.cur + self.prev
           self.n -= 1
           return self.cur
        else:
            raise StopIteration()

myclass = Fib(10)
myiter = iter(myclass)
for x in myiter:
	print(x)

$0
endsnippet

snippet generatorFormwork "Generator Formwork" b
#!/usr/bin/env python
# coding=utf-8
import sys
def fibonacci(n): 
    """TODO: Docstring for fibonacci.

    :arg1: TODO
    :returns: TODO

    """
    a, b, counter = 0, 1, 0
    while True:
        if (counter > n):
            return
        yield a
        a, b = b, a + b
        counter += 1

f = fibonacci(10) # f is a iterater
while True:
    try:
        print(next(f), end=" ")
    except StopIteration:
        sys.exit()
$0
endsnippet

snippet mapFormwork "map Python" b
def f(x):
    return x * x
r = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])
print(list(r))
$0
endsnippet

snippet reduceFormwork "reduce Python" b
# reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)
from functools import reduce
def add(x, y):
    return x + y
reduce(add, [1, 3, 5, 7, 9])
$0
endsnippet


snippet filterFormwork "filter Python" b
def is_odd(n):
    return n % 2 == 1

list(filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15]))
$0
endsnippet

snippet sortFormwork "sort Python" b
L = [('Bob', 75), ('Adam', 92), ('Bart', 66), ('Lisa', 88)]
def by_name(t):
    pass

L2 = sorted(L, key=by_name)
print(L2)


from operator import itemgetter

L = ['bob', 'about', 'Zoo', 'Credit']

print(sorted(L))
print(sorted(L, key=str.lower))

students = [('Bob', 75), ('Adam', 92), ('Bart', 66), ('Lisa', 88)]

print(sorted(students, key=itemgetter(0)))
print(sorted(students, key=lambda t: t[1]))
print(sorted(students, key=itemgetter(1), reverse=True))
$0
endsnippet

snippet zipFormwork "zip Formwork" b
a = [1,2,3]
b = [4,5,6]
c = [4,5,6,7,8]
zipped = zip(a,b)     # 返回一个对象
zipped
list(zipped)  # list() 转换为列表
list(zip(a,c))              # 元素个数与最短的列表一致
a1, a2 = zip(*zip(a,b))          # 与 zip 相反，zip(*) 可理解为解压，返回二维矩阵式
list(a1)
list(a2)

$0
endsnippet
snippet lambdaFormwork "lambda Formwork" b
list(map(lambda x: x * x, [1, 2, 3, 4, 5, 6, 7, 8, 9]))
$0
endsnippet

snippet listComprehensions "list Comprehensions" b
${1:list_result} = [${2:item} for $2 in ${3:array} if $2 == 'a']
$0
endsnippet

snippet multipleprocess "multiple process " b
def run_proc(name):
    print('Run child process %s (%s)...' % (name, os.getpid()))

print('Parent process %s.' % os.getpid())
p = Process(target=run_proc, args=('test',))
print('Child process will start.')
p.start()
p.join()
print('Child process end.')
$0
endsnippet

snippet multipleThreadModule "multiple Thread module threading.Thread " b
#!/usr/bin/python3

import threading
import time

exitFlag = 0

class myThread (threading.Thread):
    def __init__(self, threadID, name, delay):
        threading.Thread.__init__(self)
        self.threadID = threadID
        self.name = name
        self.delay = delay
    def run(self):
        print ("开始线程：" + self.name)
        print_time(self.name, self.delay, 5)
        print ("退出线程：" + self.name)

def print_time(threadName, delay, counter):
    while counter:
        if exitFlag:
            threadName.exit()
        time.sleep(delay)
        print ("%s: %s" % (threadName, time.ctime(time.time())))
        counter -= 1

# 创建新线程
thread1 = myThread(1, "Thread-1", 1)
thread2 = myThread(2, "Thread-2", 2)

# 开启新线程
thread1.start()
thread2.start()
thread1.join()
thread2.join()
print ("退出主线程")
$0
endsnippet
snippet multipleThreadFunction "multiple  Thread function " b
#!/usr/bin/python3

import _thread
import time

# 为线程定义一个函数
def print_time( threadName, delay):
   count = 0
   while count < 5:
      time.sleep(delay)
      count += 1
      print ("%s: %s" % ( threadName, time.ctime(time.time()) ))

# 创建两个线程
try:
   _thread.start_new_thread( print_time, ("Thread-1", 2, ) )
   _thread.start_new_thread( print_time, ("Thread-2", 4, ) )
except:
   print ("Error: 无法启动线程")

while 1:
   pass
$0
endsnippet

snippet multipleThreadLock "mltiple Thread lock" b
#!/usr/bin/python3

import threading
import time

class myThread (threading.Thread):
    def __init__(self, threadID, name, delay):
        threading.Thread.__init__(self)
        self.threadID = threadID
        self.name = name
        self.delay = delay
    def run(self):
        print ("开启线程： " + self.name)
        # 获取锁，用于线程同步
        threadLock.acquire()
        print_time(self.name, self.delay, 3)
        # 释放锁，开启下一个线程
        threadLock.release()

def print_time(threadName, delay, counter):
    while counter:
        time.sleep(delay)
        print ("%s: %s" % (threadName, time.ctime(time.time())))
        counter -= 1

threadLock = threading.Lock()
threads = []

# 创建新线程
thread1 = myThread(1, "Thread-1", 1)
thread2 = myThread(2, "Thread-2", 2)

# 开启新线程
thread1.start()
thread2.start()

# 添加线程到线程列表
threads.append(thread1)
threads.append(thread2)

# 等待所有线程完成
for t in threads:
    t.join()
print ("退出主线程")
$0
endsnippet

snippet multipleThreadLock "mltiple Thread lock" b
#!/usr/bin/python3

import queue
import threading
import time

exitFlag = 0

class myThread (threading.Thread):
    def __init__(self, threadID, name, q):
        threading.Thread.__init__(self)
        self.threadID = threadID
        self.name = name
        self.q = q
    def run(self):
        print ("开启线程：" + self.name)
        process_data(self.name, self.q)
        print ("退出线程：" + self.name)

def process_data(threadName, q):
    while not exitFlag:
        queueLock.acquire()
        if not workQueue.empty():
            data = q.get()
            queueLock.release()
            print ("%s processing %s" % (threadName, data))
        else:
            queueLock.release()
        time.sleep(1)

threadList = ["Thread-1", "Thread-2", "Thread-3"]
nameList = ["One", "Two", "Three", "Four", "Five"]
queueLock = threading.Lock()
workQueue = queue.Queue(10)
threads = []
threadID = 1

# 创建新线程
for tName in threadList:
    thread = myThread(threadID, tName, workQueue)
    thread.start()
    threads.append(thread)
    threadID += 1

# 填充队列
queueLock.acquire()
for word in nameList:
    workQueue.put(word)
queueLock.release()

# 等待队列清空
while not workQueue.empty():
    pass

# 通知线程是时候退出
exitFlag = 1

# 等待所有线程完成
for t in threads:
    t.join()
print ("退出主线程")
$0
endsnippet

snippet socketServer "http socket server" b
#!/usr/bin/python3
# 文件名：server.py

# 导入 socket、sys 模块
import socket
import sys

# 创建 socket 对象
serversocket = socket.socket(
            socket.AF_INET, socket.SOCK_STREAM)

# 获取本地主机名
host = socket.gethostname()

port = 9999

# 绑定端口号
serversocket.bind((host, port))

# 设置最大连接数，超过后排队
serversocket.listen(5)

while True:
    # 建立客户端连接
    clientsocket,addr = serversocket.accept()

    print("连接地址: %s" % str(addr))

    msg='欢迎访问菜鸟教程！'+ "\r\n"
    clientsocket.send(msg.encode('utf-8'))
    clientsocket.close()
$0
endsnippet
snippet socketClient "http socket client" b
#!/usr/bin/python3
# 文件名：client.py

# 导入 socket、sys 模块
import socket
import sys

# 创建 socket 对象
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

# 获取本地主机名
host = socket.gethostname()

# 设置端口号
port = 9999

# 连接服务，指定主机和端口
s.connect((host, port))

# 接收小于 1024 字节的数据
msg = s.recv(1024)

s.close()

print (msg.decode('utf-8'))
$0
endsnippet
snippet wordCloud2Img "snip Test Python" b
import sys
import jieba
from wordcloud import WordCloud,ImageColorGenerator
import matplotlib.pyplot as plt
from scipy.misc import imread

print("word file name:",sys.argv[2])
data = open(sys.argv[1],"r",encoding='utf-8').read()
cutData = jieba.cut(data, cut_all=True)
# jieba.cut 方法接受三个输入参数: 需要分词的字符串；cut_all 参数用来控制是否采用全模式；HMM 参数用来控制是否使用 HMM 模型。
word = " ".join(cutData)#把分词链接起来，加空格因为英文靠空格分词

print("picture file name:",sys.argv[1])
bg_pic = imread(sys.argv[2])#读取图片
wordcloud = WordCloud(mask=bg_pic,background_color='white',font_path="/home/dc/.local/share/fonts/微软雅黑Bold.ttf",max_words=1000,max_font_size=150,scale=1).generate(word)
image_colors = ImageColorGenerator(bg_pic)#从背景图片生成颜色值
plt.imshow(wordcloud)#使图片颜色跟字体颜色一样，合并一起

plt.axis("off")#关闭显示坐标
#plt.show()
wordcloud.to_file(sys.argv[3])#保存到文件
$0
endsnippet

snippet snipTestPython "snip Test Python" b
snip Test Python
$0
endsnippet
snippet sortBucket "bucket sort " b
def bucketSort(li):
    max_num = max(li)
    bucket = [0] * (max_num + 1)
    for i in li:
        bucket[i] += 1

    bucket2 = list()
    for i in range(len(bucket)):
        if bucket[i]:
            for j in range(bucket[i]):
                bucket2.append(i)
    print(bucket2)


bucketSort([9, 8, 9, 7, 6, 5, 7])
$0
endsnippet
# vim:ft=snippets:
# ::::::::::::::
# ./02/bubbleSort.py
# ::::::::::::::
snippet sortBubble "bubbleSort" b
#!/usr/bin/env python3
#-*- coding:utf-8 -*-

from randomList import randomList
import timeit

iList = randomList(20)

def bubbleSort(iList):
    '''冒泡排序 '''
    if len(iList) <= 1:
        return iList
    for i in range(1, len(iList)):
        for j in range(0, len(iList)-i): 
            if iList[j] >= iList[j+1]: #比较相邻两数的大小
                iList[j], iList[j+1] = iList[j+1], iList[j] #将大数交换到靠后的位置
        # print("第 %d 轮排序结果:" %i, end="")
        # print(iList)
    return iList

if __name__ == "__main__":
    print(iList)
    print(bubbleSort(iList))
    print(timeit.timeit("bubbleSort(iList)", "from __main__ import bubbleSort,iList", number=100))

$0
endsnippet
# ::::::::::::::
# ./02/countingSort.py
# ::::::::::::::
snippet sortCounting "countingSort" b
#!/usr/bin/env python3
#-*- coding:utf-8 -*-

from randomList import randomList
import timeit

iList = randomList(20)

def countingSort(iList):
    if len(iList) <= 1:
        return iList
    iLen = len(iList)
    rList = [None]*iLen
    for i in range(iLen):
        small = 0 #比基数小的
        same = 0 #与基数相等的
        for j in range(iLen):
            if iList[j] < iList[i]:
                small += 1
            elif iList[j] == iList[i]: #相同的数
                same += 1
        for k in range(small, small+same):
            rList[k] = iList[i]
    return rList

if __name__ == "__main__":
    print(iList)
    print(countingSort(iList))
    print(timeit.timeit("countingSort(iList)", "from __main__ import countingSort,iList", number=100))

$0
endsnippet
# ::::::::::::::
# ./02/heapSort.py
# ::::::::::::::
snippet sortHeap "heapSort" b
#!/usr/bin/env python3
#-*- coding:utf-8 -*-



from randomList import randomList
import timeit

iList = randomList(20)


def heapSort(iList):
    pass


if __name__ == "__main__":
    print(iList)
    print(heapSortSort(iList))
    print(timeit.timeit("heapSort(iList)", "from __main__ import heapSort,iList", number=100))

$0
endsnippet
# ::::::::::::::
# ./02/insertionSort.py
# ::::::::::::::
snippet sortInsertion "insertionSort" b
#!/usr/bin/env python3
#-*- coding:utf-8 -*-

from randomList import randomList
import timeit

iList = randomList(20)

def insertionSort(iList):
    if len(iList) <= 1:
        return iList
    for right in range(1, len(iList)):
        target = iList[right]
        for left in range(0, right):
            if target <= iList[left]:
                iList[left+1:right+1] = iList[left:right] #使用Python的切片赋值
                iList[left] = target
                break
        # print("第 %d 轮排序结果:" %(right), end="")
        # print(iList)
    return iList

if __name__ == "__main__":
    print(iList)
    print(insertionSort(iList))
    print(timeit.timeit("insertionSort(iList)", "from __main__ import insertionSort,iList", number=100))

$0
endsnippet
# ::::::::::::::
# ./02/mergeSort.py
# ::::::::::::::
snippet sortMerge "mergeSort" b
#!/usr/bin/env python3
#-*- coding:utf-8 -*-

from randomList import randomList
import timeit

iList = randomList(20)

def mergeSort(iList):
    if len(iList) <= 1:
        return iList
    middle = len(iList)//2
    left, right = iList[0:middle], iList[middle:]
    return mergeList(mergeSort(left), mergeSort(right))

def mergeList(left, right):
    mList = []
    while left and right:
        if left[0] >= right[0]:
            mList.append(right.pop(0))
        else:
            mList.append(left.pop(0))
    while left:
        mList.append(left.pop(0))
    while right:
        mList.append(right.pop(0))
    return mList


if __name__ == "__main__":
    print(iList)
    print(mergeSort(iList))
    print(timeit.timeit("mergeSort(iList)", "from __main__ import mergeSort,iList", number=100))

$0
endsnippet
# ::::::::::::::
# ./02/quickSort.py
# ::::::::::::::
snippet sortQuick "quickSort" b
#!/usr/bin/env python3
#-*- coding:utf-8 -*-

from randomList import randomList
import timeit

iList = randomList(20)

def quickSort(iList):
    if len(iList) <= 1:
        return iList
    left = []
    right = []
    for i in iList[1:]:
        if i <= iList[0]:
            left.append(i)
        else:
            right.append(i)
    return quickSort(left) + [iList[0]] + quickSort(right)

if __name__ == "__main__":
    print(iList)
    print(quickSort(iList))
    print(timeit.timeit("quickSort(iList)", "from __main__ import quickSort,iList", number=100))

$0
endsnippet
# ::::::::::::::
# ./02/randomList.py
# ::::::::::::::
snippet randomList "randomList" b
#!/usr/bin/env python3
#-*- coding:utf-8 -*-
import random

def randomList(n):
    '''返回一个长度为n的整数列表，数据范围[0,1000) '''
    iList = []
    for i in range(n):
        iList.append(random.randrange(1000))
    return iList

if __name__ == "__main__":
    iList = randomList(10)
    print(iList)

$0
endsnippet
# ::::::::::::::
# ./02/selectionSort.py
# ::::::::::::::
snippet sortSelection "selectionSort" b
#!/usr/bin/env python3
#-*- coding:utf-8 -*-

from randomList import randomList
import timeit

iList = randomList(20)

def selectionSort(iList):
    if len(iList) <= 1:
        return iList
    for i in range(0, len(iList)-1):
        if iList[i] != min(iList[i:]): #使用min函数找到剩余数列中最小的那个数
            minIndex = iList.index(min(iList[i:])) #minIndex是最小数的序号(下标)
            iList[i], iList[minIndex] = iList[minIndex], iList[i]
        # print("第 %d 轮排序结果:" %(i+1), end="")
        # print(iList)
    return iList

if __name__ == "__main__":
    print(iList)
    print(selectionSort(iList))
    print(timeit.timeit("selectionSort(iList)", "from __main__ import selectionSort,iList", number=100))

$0
endsnippet
# ::::::::::::::
# ./02/shellSort.py
# ::::::::::::::
snippet sortShell "shellSort" b
#!/usr/bin/env python3
#-*- coding:utf-8 -*-

from randomList import randomList
import timeit

iList = randomList(8)

def shellSort(iList):
    if len(iList) <= 1:
        return iList
    # if len(iList) <= 20 :
    #     n = 2
    # else:
    #     n = len(iList)//10 #子序列的个数
    gap = len(iList)
    while gap > 1:
        # gap = gap//n
        gap = gap//2
        for i in range(gap, len(iList)):
            for j in range(i%gap, i, gap):
                if iList[i] < iList[j]:
                    iList[i], iList[j] = iList[j], iList[i]
                    print(iList)
    return iList

if __name__ == "__main__":
    print(iList)
    print(shellSort(iList))
    print(timeit.timeit("shellSort(iList)", "from __main__ import shellSort,iList", number=100))

$0
endsnippet
# ::::::::::::::
# ./03/binarySearch.py
# ::::::::::::::
snippet binarySearch "binarySearch" b
#!/usr/bin/env python3
#-*- coding:utf-8 -*-

from randomList import randomList
from quickSort import quickSort
import random

iList = quickSort(randomList(20))

def binarySearch(iList, key):
    print("iList = %s" %str(iList))
    print("Find The number : %d" %key)
    iLen = len(iList)
    left = 0 
    right = iLen -1

    while right - left > 1:
        mid = (left + right) // 2
        if key < iList[mid]:
            right = mid
        elif key > iList[mid]:
            left = mid
        else:
            return mid
    if key == iList[left]:
        return left
    elif key == iList[right]:
        return right
    else:
        return -1

if __name__ == "__main__":
    keys = [random.choice(iList), random.randrange(min(iList), max(iList))]
    for key in keys:
        res = binarySearch(iList, key)
        if res >= 0:
            print("%d is in the list, index is : %d\n" %(key, res))
        else:
            print("%d is not in the list\n" %key)

$0
endsnippet
# ::::::::::::::
# ./03/blockSearch.py
# ::::::::::::::
snippet blockSearch "blockSearch" b
#!/usr/bin/env python3
#-*- coding:utf-8 -*-

from randomList import randomList
from quickSort import quickSort
import random

iList = randomList(20)
indexList = [[250, 0], [500, 0], [750, 0], [1000, 0]]

def divideBlock():
    global iList, indexList 
    sortList = []
    for key in indexList:
        subList = [i for i in iList if i < key[0]] #列表推导, 小于key[0]的单独分块
        key[1] = len(subList)
        sortList += subList 
        iList = list(set(iList) - set(subList)) #过滤掉已经加入到subList中的元素
    iList = sortList
    print()
    return indexList
        

def blockSearch(iList, key, indexList):
    print("iList = %s" %str(iList))
    print("indexList = %s" %str(indexList))
    print("Find The number : %d" %key)
    left = 0 #搜索数列的起始点索引
    right = 0 #搜索数列的终点索引
    for indexInfo in indexList:
        left += right
        right += indexInfo[1]
        if key < indexInfo[0]:
            break
    for i in range(left, right):
        if key == iList[i]:
            return i
    return -1


if __name__ == "__main__":
    print(iList)
    divideBlock()
    print(iList)
    keys = [random.choice(iList), random.randrange(min(iList), max(iList))]
    for key in keys:
        res = blockSearch(iList, key, indexList)
        if res >= 0:
            print("%d is in the list, index is : %d\n" %(key, res))
        else:
            print("%d is not in the list\n" %key)

$0
endsnippet
# ::::::::::::::
# ./03/fibonacciSearch.py
# ::::::::::::::
snippet fibonacciSearch "fibonacciSearch" b
#!/usr/bin/env python3
#-*- coding:utf-8 -*-

from randomList import randomList
from quickSort import quickSort
import random

iList = quickSort(randomList(20))

def fibonacci(n):
    '''return the last element of the fibonacci sequence'''
    fList = [1, 1]
    while n > 1 :
        fList.append(fList[-1] + fList[-2])
        n -= 1
    return fList[-1]

def fibonacciSearch(iList, key):
    print("iList = %s" %str(iList))
    print("Find The number : %d" %key)
    iLen = len(iList)
    left = 0 
    right = iLen - 1
    indexSum = 0

    k = 1
    while fibonacci(k) -1 < iLen - 1: #fibonacci数列中的最后一个元素要比iList的长度稍微大一点
        k += 1

    while right - left > 1:
        mid = left + fibonacci(k - 1)
        if key < iList[mid] :
            right = mid - 1
            k -= 1
        elif key == iList[mid]:
            return mid
        else:
            left = mid + 1
            k -= 2
    if key == iList[left]:
        return left
    elif key == iList[right]:
        return right
    else:
        return -1

if __name__ == "__main__":
    keys = [random.choice(iList), random.randrange(min(iList), max(iList))]
    for key in keys:
        res = fibonacciSearch(iList, key)
        if res >= 0:
            print("%d is in the list, index is : %d\n" %(key, res))
        else:
            print("%d is not in the list\n" %key)


$0
endsnippet
# ::::::::::::::
# ./03/insertSearch.py
# ::::::::::::::
snippet insertSearch "insertSearch" b
#!/usr/bin/env python3
#-*- coding:utf-8 -*-

from randomList import randomList
from quickSort import quickSort
import random

iList = quickSort(randomList(20))

def insertSearch(iList, key):
    print("iList = %s" %str(iList))
    print("Find The number : %d" %key)
    iLen = len(iList)
    left = 0 
    right = iLen -1

    while right - left > 1:
        mid = left + (key - iList[left]) * (right - left) // (iList[right] - iList[left])
        if mid == left:
            mid += 1 #当iList[right]和iList[left]相差太大时，有可能导致mid一直都等于left，从而陷入死循环
        if key < iList[mid]:
            right = mid
        elif key > iList[mid]:
            left = mid
        else:
            return mid
    if key == iList[left]:
        return left
    elif key == iList[right]:
        return right
    else:
        return -1


if __name__ == "__main__":
    keys = [random.choice(iList), random.randrange(min(iList), max(iList))]
    for key in keys:
        res = insertSearch(iList, key)
        if res >= 0:
            print("%d is in the list, index is : %d\n" %(key, res))
        else:
            print("%d is not in the list\n" %key)

$0
endsnippet
# ::::::::::::::
# ./03/quickSort.py
# ::::::::::::::
snippet quickSort "quickSort" b
#!/usr/bin/env python3
#-*- coding:utf-8 -*-

from randomList import randomList
import timeit

iList = randomList(20)

def quickSort(iList):
    if len(iList) <= 1:
        return iList
    left = []
    right = []
    for i in iList[1:]:
        if i <= iList[0]:
            left.append(i)
        else:
            right.append(i)
    return quickSort(left) + [iList[0]] + quickSort(right)

if __name__ == "__main__":
    print(iList)
    print(quickSort(iList))
    print(timeit.timeit("quickSort(iList)", "from __main__ import quickSort,iList", number=100))

$0
endsnippet
# ::::::::::::::
# ./03/randomList.py
# ::::::::::::::
snippet randomList "randomList" b
#!/usr/bin/env python3
#-*- coding:utf-8 -*-
import random

def randomList(n):
    '''返回一个长度为n的整数列表，数据范围[0,1000) '''
    iList = []
    for i in range(n):
        iList.append(random.randrange(1000))
    return iList

if __name__ == "__main__":
    iList = randomList(10)
    print(iList)

$0
endsnippet
# ::::::::::::::
# ./03/sequentialSearch.py
# ::::::::::::::
snippet sequentialSearch "sequentialSearch" b
#!/usr/bin/env python3
#-*- coding:utf-8 -*-

from randomList import randomList
from quickSort import quickSort
import random

iList = quickSort(randomList(20))

def sequentialSearch(iList, key):
    print("iList = %s" %str(iList))
    print("Find The number : %d" %key)
    iLen = len(iList)
    for i in range(iLen):
        if iList[i] == key:
            return i
    return -1

if __name__ == "__main__":
    keys = [random.choice(iList), random.randrange(min(iList), max(iList))]
    for key in keys:
        res = sequentialSearch(iList, key)
        if res >= 0:
            print("%d is in the list, index is : %d\n" %(key, res))
        else:
            print("%d is not in the list\n" %key)


$0
endsnippet
# ::::::::::::::
# ./04/containsDuplicate_last.py
# ::::::::::::::
snippet containsDuplicate_last "containsDuplicate_last" b
#!/usr/bin/env python3
#-*- coding:utf-8 -*-

def containsDuplicate(nums):
    # for i in range(len(nums) - 1):
    #     if nums[i] in nums[i+1:]:
    #         return True
    # return False
    # 提交结果：超出时间限制 

    # nums.sort()
    # for i in range(len(nums) - 1):
    #     if nums[i] == nums[i + 1]:
    #         return True
    # return False

    if len(set(nums)) == len(nums):
        return False
    else:
        return True

if __name__ == "__main__":
    nums = [1, 2, 3, 4, 4]
    print(containsDuplicate(nums))

$0
endsnippet
# ::::::::::::::
# ./04/intersect_last.py
# ::::::::::::::
snippet intersect_last "intersect_last" b
#!/usr/bin/env python3
#-*- coding:utf-8 -*-

def intersect(nums1, nums2):
    # rList = []
    # if len(nums1) > len(nums2):
    #     nums1, nums2 = nums2, nums1
    # for n in nums1:
    #     if n in nums2:
    #         rList.append(n)
    #         nums2.remove(n)
    # return rList
    # nums1 比 nums2小很多



    # rList = []
    # nums1.sort()
    # nums2.sort()
    # p1 = 0 #point for nums1
    # p2 = 0 #point for nums2
    # while p1 < len(nums1) and p2 < len(nums2):
    #     if nums1[p1] < nums2[p2]:
    #         p1 += 1
    #     elif nums1[p1] == nums2[p2]:
    #         rList.append(nums1[p1])
    #         p1 += 1
    #         p2 += 1
    #     else:
    #         p2 += 1
    # return rList
    #排序后算法




    # 内存不够
    if len(nums1) > len(nums2):
        nums1, nums2 = nums2, nums1
    rList = []
    left = 0
    right = len(nums1) - 1
    while right < len(nums2):
        temp = nums2[left: right]
        for n in nums1:
            if n in temp:
                rList.append(n)
                temp.remove(n)
        left = right
        if right + len(nums1) >= len(nums2):
            right = len(nums2)
        else:
            right += len(nums1)
    return rLis
    # 分段读取nums2

        




if __name__ == "__main__":
    # nums1 = [4, 9, 5]
    # nums2 = [9, 4, 9, 8, 4]
    nums1 = [1, 2, 2, 1]
    nums2 = [2, 2]
    rList = intersect(nums1, nums2)
    print("The intersection is : %s"  %rList)

$0
endsnippet
# ::::::::::::::
# ./04/isValidSudoku_last.py
# ::::::::::::::
snippet isValidSudoku_last "isValidSudoku_last" b
#!/usr/bin/env python3
#-*- coding:utf-8 -*-

def isValidSudoku(board):
    rows = [[] for i in range(9)] #转换成行的列表
    columns = [[] for i in range(9)] #转换成按列的列表
    blocks = [[] for i in range(9)] #转换成按块的列表

    for i in range(9):
        for j in range(9):
            if board[i][j] == '.':
                pass
            else:
                rows[i].append(board[i][j])
                columns[j].append(board[i][j])
                blocks[i // 3 * 3 + j // 3].append(board[i][j])
    for B2L in rows, columns, blocks:
        for subList in B2L:
            if not len(subList) == len(set(subList)):
                return False
    return True

if __name__ == "__main__":
    board = [
["5","3",".",".","7",".",".",".","."],
["6",".",".","1","9","5",".",".","."],
[".","9","8",".",".",".",".","6","."],
["8",".",".",".","6",".",".",".","3"],
["4",".",".","8",".","3",".",".","1"],
["7",".",".",".","2",".",".",".","6"],
[".","6",".",".",".",".","2","8","."],
[".",".",".","4","1","9",".",".","5"],
[".",".",".",".","8",".",".","7","9"]
]
    print(isValidSudoku(board))


$0
endsnippet
# ::::::::::::::
# ./04/maxProfit2_last.py
# ::::::::::::::
snippet maxProfit2_last "maxProfit2_last" b
#!/usr/bin/env python3
#-*- coding:utf-8 -*-
def maxProfit(prices):
    maxPro = 0
    i = 1
    while i < len(prices):
        profit = prices[i] - prices[i-1]
        if profit > 0:
            maxPro += profit
        i += 1
    return maxPro

if __name__ == "__main__":
    prices = [7, 1, 5, 3, 6, 4]
    print(maxProfit(prices))

$0
endsnippet
# ::::::::::::::
# ./04/moveZeroes_last.py
# ::::::::::::::
snippet moveZeroes_last "moveZeroes_last" b
#!/usr/bin/env python3
#-*- coding:utf-8 -*-

def moveZeroes(nums):
    for n in nums:
        if n == 0:
            nums.remove(0)
            nums.append(0)
    return


    # left = 0
    # right = 0
    # while right < len(nums) - 1:
    #     if nums[left] == 0:
    #         nums[left:-1] = nums[left + 1:]
    #         nums[-1] = 0
    #         right += 1
    #     else:
    #         left += 1
    #         right += 1
    # return 




if __name__ == "__main__":
    nums = [0, 1, 0, 3, 12]
    print("before nums = %s" %nums)
    moveZeroes(nums)
    print("after nums = %s" %nums)

$0
endsnippet
# ::::::::::::::
# ./04/pivotIndex.py
# ::::::::::::::
snippet pivotIndex "pivotIndex" b
#!/usr/bin/env python3
#-*- coding:utf-8 -*-



def pivotIndex(nums):
    # left = 0
    # right = len(nums) - 1
    # sumLeft = 0
    # sumRight = 0
    # while right > left:
    #     if sumLeft == sumRight:
    #         sumLeft += nums[left]
    #         left += 1
    #         sumRight += nums[right]
    #         right -= 1
    #     elif sumLeft > sumRight:
    #         sumRight += nums[right]
    #         right -= 1
    #     else:
    #         sumLeft += nums[left]
    #         left += 1
    # if right == left:
    #     return left
    # else:
    #     return -1
    #这个只能对应正数列表


    if len(nums) < 3:
        return -1
    sum = 0
    for n in nums:
        sum += n
    halfSum = 0
    for i in range(len(nums)):
        if halfSum == (sum - nums[i]) / 2:
            return i
        else:
            halfSum += nums[i]
    return -1


if __name__ == "__main__":
    # nums = [1, 7, 3, 6, 5, 6]
    # nums = [-1, -1, -1, -1, -1, 0]
    # nums = [-1, -1, -1, -1, -1, -1]
    nums = [-1, -1, 0, 1, 1, 0]
    pIndex = pivotIndex(nums)
    print("The pivot index is : %d" %pIndex)

$0
endsnippet
# ::::::::::::::
# ./04/plusOne_last.py
# ::::::::::::::
snippet plusOne_last "plusOne_last" b
#!/usr/bin/env python3
#-*- coding:utf-8 -*-

def plusOne(digits):
    digits = [str(i) for i in digits]
    n = int("".join(digits))
    n += 1
    rList = [int(i) for i in list(str(n))]
    return rList

    # digits.reverse()
    # flag = True # plus one flag
    # for i in range(len(digits)):
    #     if flag == True:
    #         if digits[i] ==9:
    #             digits[i] = 0
    #         else:
    #             digits[i] += 1
    #             flag = False
    # if digits[-1] == 0:
    #     digits.append(1)
    # digits.reverse()
    # return digits


if __name__ == "__main__":
    digits = [1, 2, 3]
    rList = plusOne(digits)
    print("The List plus one is : %s" %rList)

$0
endsnippet
# ::::::::::::::
# ./04/removeDuplicates_last.py
# ::::::::::::::
snippet removeDuplicates_last "removeDuplicates_last" b
#!/usr/bin/env python3
#-*- coding:utf-8 -*-

def removeDuplicates(nums):
    n = len(set(nums))
    i = 0
    while i < n:
        if nums[i] == nums[i+1]:
            temp = nums[i+1]
            nums[i+1: len(nums) -1] = nums[i+2:]
            nums[-1] = temp
            continue
        else:
            i += 1
    return n

if __name__ == "__main__":
    nums = [0, 0, 1, 1, 1, 2, 2, 3, 3, 4]
    print("before nums = %s" %nums)
    print(removeDuplicates(nums))
    print("after nums = %s" %nums)

$0
endsnippet
# ::::::::::::::
# ./04/rotateImage_last.py
# ::::::::::::::
snippet rotateImage_last "rotateImage_last" b
#!/usr/bin/env python3
#-*- coding:utf-8 -*-

def rotate(matrix):
    '''二维数组顺时针旋转90°可以等同于将一个二维数组转置（行列互换），然后每行翻转。 '''
    for i in range(len(matrix)):
        for j in range(i + 1, len(matrix)):
            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]
    for i in range(len(matrix)):
        matrix[i].reverse()
    return


if __name__ == "__main__":
    matrix = [
        [1, 2, 3],
        [4, 5, 6],
        [7, 8, 9]
    ]
    print("beforte matrix:")
    for subList in matrix:
        print(subList)
    rotate(matrix)
    print("after maxtrix:")
    for subList in matrix:
        print(subList)

$0
endsnippet
# ::::::::::::::
# ./04/rotate_last.py
# ::::::::::::::
snippet rotate_last "rotate_last" b
#!/usr/bin/env python3
#-*- coding:utf-8 -*-

def rotate(nums, k):
    # if len(nums) < 2:
    #     return
    # nums.reverse()
    # k = k % len(nums) #避免k大于nums的长度
    # while k > 0:
    #     temp = nums.pop(0)
    #     nums.append(temp)
    #     k -= 1
    # nums.reverse()
    # return 

    # if len(nums) < 2:
    #     return
    # k = k % len(nums)
    # while k > 0:
    #     temp = nums[-1]
    #     nums[1:] = nums[:-1]
    #     nums[0] = temp
    #     k -= 1
    # return

    # if len(nums) < 2:
    #     return 
    # k = k % len(nums)
    # temp = nums[:len(nums) - k] # 1, 2, 3, 4
    # nums[:k] = nums[len(nums) - k:]
    # nums[k:] = temp
    # return

    if len(nums) < 2:
        return 
    k = k % len(nums)
    temp = nums[len(nums) - k:] # 5, 6, 7
    nums[k:] = nums[:len(nums) - k]
    nums[:k] = temp
    return



if __name__ == "__main__":
    nums = [1, 2, 3, 4, 5, 6, 7]
    k = 3
    print("before nums = %s" %nums)
    rotate(nums, k)
    print("after nums = %s" %nums)

$0
endsnippet
# ::::::::::::::
# ./04/singleNumber_last.py
# ::::::::::::::
snippet singleNumber_last "singleNumber_last" b
#!/usr/bin/env python3
#-*- coding:utf-8 -*-

def singleNumber(nums):
    # nums.sort()
    # length = len(nums)
    # if length < 3:
    #     return nums[0]
    # i = 0
    # while i < length - 2 :
    #     if nums[i] != nums[i+1]:
    #         return nums[i]
    #     else:
    #         i += 2
    # return nums[-1]

    # nums.sort()
    # n = list(set(nums[::2]) - set(nums[1::2]))[0]
    # return n

    n = 0
    for i in nums:
        n ^= i
    return n

if __name__ == "__main__":
    # nums = [4, 1, 2, 1, 2]
    nums = [17,12,5,-6,12,4,17,-5,2,-3,2,4,5,16,-3,-4,15,15,-4,-5,-6]
    sn = singleNumber(nums)
    print("the Single number is : %d" %(sn))

$0
endsnippet
# ::::::::::::::
# ./04/threeSum.py
# ::::::::::::::
snippet threeSum "threeSum" b
#!/usr/bin/env python3
# -*- coding:utf-8 -*-

def threeSum(nums):
    # rList = []
    # for i in range(1, len(nums) - 1):
    #     for j in range(i):
    #         if (nums[i] + nums[j]) * -1 in nums[i + 1:]:
    #             subList = [nums[i], nums[j], (nums[i] + nums[j]) * -1]
    #             subList.sort()
    #             if subList not in rList:
    #                 rList.append(subList)
    # return rList
    # time out

    # if len(nums) < 3 or max(nums) < 0 or min(nums) > 0:
    #     return []
    # rList = []
    # nums.sort()
    # left = 0
    # right = len(nums) - 1
    # if nums.count(0) > 2:
    #     rList.append([0, 0, 0])
    # if nums.count(0) > 0: # 一个正数，一个负数， 一个零的情况
    #     while nums[left] < 0 and nums[right] > 0:
    #         if nums[left] + nums[right] == 0:
    #             rList.append([nums[left], 0, nums[right]])
    #             left += 1
    #             right -= 1
    # nums = [i for i in nums if i != 0] #去掉所有的0

    # left = 0
    # right = len(nums) - 1
    # while nums[left + 1] < 0 and nums[right] > 0:
    #     if nums[left] + nums[left + 1] + nums[right] == 0:
    #         rList.append([nums[left], nums[left + 1], nums[right]])
    #         right += 1
    #         left -= 1
    #     elif nums[left] + nums[left + 1] + nums[right] > 0:
    #         right -= 1
    #     else:
    #         left += 1

    # left = 0
    # right = len(nums) - 1
    # while nums[left] < 0 and nums[right - 1] > 0:
    #     if nums[left] + nums[right] + nums[right - 1] == 0:
    #         rList.append([nums[left], nums[right], nums[right - 1]])
    #         right += 1
    #         left -= 1
    #     elif nums[left] + nums[right] + nums[right - 1] > 0:
    #         right -= 1
    #     else:
    #         left += 1
    # return rList
    # time out

    rList = []
    left = 0
    right = len(nums) - 1
    while nums[left] < 0 and nums[right] > 0:
        if nums[left] + nums[right] == 0 and nums.count(0) > 0: #正负相等，列表有0
            rList.append([nums[left], 0, nums[right]])
        


            

if __name__ == "__main__":
    # nums = [-1, 0, 1, 2, -1, 4]
    nums = [-2, 0, 1, 1, 2]
    # nums = [0, 0, 0]
    # nums = [3, -2, 1, 0]
    rList = threeSum(nums)
    print("return List is : %s" %(str(rList)))

$0
endsnippet
# ::::::::::::::
# ./04/twoSum_last.py
# ::::::::::::::
snippet twoSum_last "twoSum_last" b
#!/usr/bin/env python3
# -*- coding:utf-8 -*-

def twoSum(nums, target):
    # for i in range(len(nums)):
    #     if target - nums[i] in nums:
    #         j = nums.index(target - nums[i])
    #         if i == j:
    #             pass
    #         else:
    #             return [i, j]
    # 利用字典可能会比较快一点

    # for i in range(len(nums) - 1):
    #     for j in range(i+1, len(nums)):
    #         if nums[i] + nums[j] == target:
    #             return [i, j]

    for i in range(len(nums) - 1):
        if target - nums[i] in nums[i+1:]:
            j = nums[i+1:].index(target - nums[i])
            return [i, i + j + 1]


if __name__ == "__main__":
    nums = [2, 7, 11, 15]
    target = 9
    # nums = [3, 3]
    # target = 6
    rList = twoSum(nums, target)
    print("rList = %s" % rList)


$0
endsnippet
# ::::::::::::::
# ./05/countAndSay.py
# ::::::::::::::
snippet countAndSay "countAndSay" b
#!/usr/bin/env python3
#-*- coding:utf-8 -*-



def countAndSay(n):
    if n not in range(1, 31):
        return "the number is error, quit ..."
    if n == 1:
        return "1"
    rawStr = '1'
    countList = [] #统计个数
    pointer = 0 #指针
    while n > 1:
        if pointer + 1 < len(rawStr): 
            if rawStr[pointer] == rawStr[pointer + 1]: #当相邻两个数字相同时，指针后移一位
                pointer += 1
            else: #当相邻两数不同时
                countList.append(str(pointer + 1)) #个数,因为下标从0开始，所以需要需要加1
                countList.append(rawStr[pointer]) # 统计rawStr[pointer]这个数字和个数
                rawStr = rawStr[pointer + 1:] #截取后面不同的部分字符串，统计下一个不同的数字个数
                pointer = 0 #指针回零，从头开始统计新的字符串
            continue
        else: #旧的rawStr统计完毕，设置新的rawStr
            countList.append(str(pointer + 1))
            countList.append(rawStr[pointer])
            rawStr = "".join(countList)
            countList = []
            pointer = 0
        n -= 1
    return rawStr

if __name__ == "__main__":
    n = 7
    s = countAndSay(n)
    print("The nums is %d, say %s" %(n, s))

$0
endsnippet
# ::::::::::::::
# ./05/firstUniqChar.py
# ::::::::::::::
snippet firstUniqChar "firstUniqChar" b
#!/usr/bin/env python3
#-*- coding:utf-8 -*-



def firstUniqChar(s):
    if len(s) == 1:
        return 0
    for i in range(len(s)):
        if s[i] not in s[i+1: ] and  s[i] not in s[:i]:
            return i
    return -1

    

    # hash算法,26个字母的字典
    # words = [chr(i) for i in range(97, 123)] #[a - z]
    # values = [0] * 26
    # wordsDic = dict(zip(words, values)) #{'a':0, 'b':0 ...}
    # for word in s:
    #     wordsDic[word] += 1
    # for i in range(len(s)):
    #     if wordsDic[s[i]] == 1:
    #         return i
    # return -1
    

if __name__ == "__main__":
    # s = "leetcode"
    # s = "loveleetcode"
    s = "dddccdbba"
    num = firstUniqChar(s)
    print("the index for first uniq char is : %d" %num)

$0
endsnippet
# ::::::::::::::
# ./05/isAnagram.py
# ::::::::::::::
snippet isAnagram "isAnagram" b
#!/usr/bin/env python3
#-*- coding:utf-8 -*-



def isAnagram(s, t):
    # 排序比较
    # if len(s) != len(t):
    #     return False
    # sList = list(s)
    # sList.sort()
    # tList = list(t)
    # tList.sort()
    # for i in range(len(s)):
    #     if sList[i] == tList[i]:
    #         continue
    #     else:
    #         return False
    # return True


    #列表化后删除
    if len(s) != len(t):
        return False
    sList = list(s)
    for word in t:
        try:
            sList.remove(word)
        except ValueError as e:
            return False
    return True




if __name__ == "__main__":
    s = "anagram"
    t = "nagaram"
    print(isAnagram(s, t))

$0
endsnippet
# ::::::::::::::
# ./05/isPalindrome.py
# ::::::::::::::
snippet isPalindrome "isPalindrome" b
#!/usr/bin/env python3
#-*- coding:utf-8 -*-

def isPalindrome(s):
    # 先处理s字符串，将非字母处理掉，大写字母转换成小写字母。
    # if len(s) < 2:
    #     return True
    # sList = []
    # s = s.lower()
    # for word in s:
    #     if word.isalnum():
    #         sList.append(word)
    # n = len(sList) // 2
    # if sList[:n] == sList[:: -1][:n]:
    #     return True
    # else:
    #     return False


    if len(s) < 2:
        return True
    s = s.lower()
    left = 0
    right = len(s) - 1
    while right - left  > 0: 
        if not s[left].isalnum():
            left += 1
            continue
        if not s[right].isalnum():
            right -= 1
            continue
        if s[left] == s[right]:
            left += 1
            right -= 1
        else:
            return False
    return True

if __name__ == "__main__":
    s = "A man, a plan, a canal: Panama"
    # s = "p, h p"
    # s = "0p"
    print(isPalindrome(s))

$0
endsnippet
# ::::::::::::::
# ./05/longestCommonPrefix.py
# ::::::::::::::
snippet longestCommonPrefix "longestCommonPrefix" b
#!/usr/bin/env python3
#-*- coding:utf-8 -*-



def longestCommonPrefix(strList):
    if len(strList) == 0 or "" in strList:
        return ""
    if len(strList) == 1:
        return strList[0]
    publicWordList = []

    minLength = min([len(st) for st in strList]) #最短字符串的长度

    for i in range(minLength):
        for word in strList:
            publicWordList.append(word[:i+1])
        if len(set(publicWordList)) == 1:
            publicWordList = []
        else:
            return strList[0][:i]
    return strList[0][:minLength]




if __name__ == "__main__":
    # strList = ["flower", "flow", "xx"]
    # strList = ["flower", "flow", "flight"]
    strList = ['c', 'c']
    prefixStr = longestCommonPrefix(strList)
    print("the longest common prefix is : %s" %prefixStr)


$0
endsnippet
# ::::::::::::::
# ./05/myAtoi.py
# ::::::::::::::
snippet myAtoi "myAtoi" b
#!/usr/bin/env python3
#-*- coding:utf-8 -*-



def myAtoi(s):
    s = s.lstrip() #去开头空格
    if len(s) < 1:
        return 0
    minusFlag = False #假设最终数字非负
    if s[0] in ['+', '-']:
        if s[0] == '+':
            pass
        else:
            minusFlag = True
        s = s[1:] #确定负号后，去除掉负号标记

    if len(s) < 1: #去除正负号后字符串长度
        return 0
    if not s[0].isdigit(): #符号后不是数字
        return 0

    iList = []
    for i in range(len(s)):
        if s[i].isdigit():
            iList.append(s[i])
        else:
            break

    INT_MAX = pow(2, 31) - 1
    INT_MIN = pow(2, 31) * (-1)
    if minusFlag: #测试整数区间
        num = int("".join(iList)) * (-1)
        if num < INT_MIN: 
            num = pow(2, 31) * (-1)
    else:
        num = int("".join(iList))
        if num > INT_MAX:
            num = pow(2, 31) - 1
    return num






if __name__ == "__main__":
    # s = "-4197 with words"
    s = "+-2"
    # s = "words and 987"
    # s = "42"
    num = myAtoi(s)
    print("the string to inteter is : %d" %num)


$0
endsnippet
# ::::::::::::::
# ./05/reverseInteger.py
# ::::::::::::::
snippet reverseInteger "reverseInteger" b
#!/usr/bin/env python3
#-*- coding:utf-8 -*-


def reverse(x):
    # tList = list(str(x))
    # if tList[0] == '-':
    #     rNum = int(''.join(tList[1:][::-1])) * (-1) #列表反转
    # else:
    #     rNum = int(''.join(tList[::-1])) #列表反转
    #
    # if rNum in range(pow(2, 31)* (-1), pow(2, 31) -1):
    #     return rNum
    # else:
    #     return 0

    rList = []
    minus = False #负数标识，为False时表明是正数，True时为负数
    if x < 0:
        minus = True
        x = x * (-1) #将输入的数变成正数

    while x // 10 != 0: #将参数x的绝对值倒序放入列表
        rList.append(str(x % 10))
        x = x // 10
    rList.append(x)

    length = len(rList)
    rNum = 0
    for i in range(length): #列表还原成数字
        rNum += int(rList[i]) * pow(10, length - i - 1)

    if minus: #还原参数的符号
        rNum = rNum * (-1)

    if rNum in range(pow(2, 31)* (-1), pow(2, 31) -1): #判断值区间
        return rNum
    else:
        return 0



if __name__ == "__main__":
    x = 120
    print("numbers = %d" %x)
    rNum = reverse(x)
    print("reverse number = %d" %rNum)

$0
endsnippet
# ::::::::::::::
# ./05/reverseString.py
# ::::::::::::::
snippet reverseString "reverseString" b
#!/usr/bin/env python3
#-*- coding:utf-8 -*-


def reverseString(s):
    # s.reverse()
    # return
    #利用Python列表特性 

 

    length = len(s)
    if length < 2:
        return
    for i in range(length//2):
        s[i], s[length - i - 1] = s[length - i - 1] , s[i]
    return


if __name__ == "__main__":
    s = ['h', 'e', 'l', 'l', 'o']
    print("before s = " + str(s))
    reverseString(s)
    print("after s = "  + str(s))

$0
endsnippet
# ::::::::::::::
# ./05/strStr.py
# ::::::::::::::
snippet strStr "strStr" b
#!/usr/bin/env python3
#-*- coding:utf-8 -*-



def strStr(haystack, needle):
    if len(needle) > len(haystack):
        return -1
    if needle == haystack:
        return 0
    length = len(needle)
    pointer = 0
    lenght = len(needle)
    while pointer <= (len(haystack) - len(needle)):
        if haystack[pointer: pointer + length] == needle: # subStr = hystack[pointer: pointer + length]
            return pointer
        else:
            pointer += 1
    return -1
                
        

if __name__ == "__main__":
    # haystack = "hello"
    # needle = "ll"
    haystack = "mississippi"
    needle = "pi"
    print(strStr(haystack, needle))

$0
endsnippet
# ::::::::::::::
# ./06/createNode.py
# ::::::::::::::
snippet createNode "createNode" b
#!/usr/bin/env python3
#-*- coding:utf-8 -*-
import random


class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None

def createChain(n):
    randomList = random.sample(range(1000), n)
    print("randomList = %s" %(str(randomList)))
    pointer = ListNode(randomList.pop(0))
    head = pointer
    while randomList:
        pointer.next = ListNode(randomList.pop(0))
        pointer = pointer.next
    pointer.next = None
    return head

def createChainFromList(Li)-> bool:
    print("crate the Chain from list %s" %(str(Li)))
    pointer = ListNode(Li.pop(0))
    head = pointer
    while Li:
        pointer.next = ListNode(Li.pop(0))
        pointer = pointer.next
    pointer.next = None
    return head

def showChain(head):
    if head == None:
        print("the chain is None ...")
        return None
    while head.next:
        print("%d -> " %head.val, end='')
        head = head.next
    print("%d" %head.val)
    return

def showChainXth(head, x):
    pointer = head
    length = countChainLength(head)
    if x > length:
        print("index error, the chain length is : %d" %x)
        return
    length = x
    while length > 0:
        head = head.next
        length -= 1
    print("The Chain %dth node value is %d" %(x, head.val))
    return

def countChainLength(head):
    n = 0
    while head.next:
        n += 1
        head = head.next
    return n

def insertNode(head, th, val):
    length = countChainLength(head)
    pointer = head
    if th == 0:
        tempNode = ListNode(val)
        head.val , tempNode.val = tempNode.val, head.val
        tempNode.next = head.next
        head.next = tempNode
        return
    if th < length:
        while th > 1:
            pointer = pointer.next
            th -= 1
        tempNode = ListNode(val)
        tempNode.next = pointer.next
        pointer.next = tempNode
    else:
        while length > 0: 
            pointer = pointer.next
            length -= 1
        tempNode = ListNode(val)
        pointer.next = tempNode
        tempNode.next = None
    return

def deleteNode(head, val):
    pointer = head
    if pointer.val == val: #被删除节点在第一个
        head.val = head.next.val
        head.next = head.next.next
        return

    length = countChainLength(pointer)
    while length > 0:
        if pointer.next.val != val:
            pointer = pointer.next
            length -= 1
            continue
        else: 
            if length == 1: #节点是链表的最后一个
                pointer.next = None
            else:#节点在链表中间
                pointer.next = pointer.next.next
            return

def sortNode(head):
    valList = []
    pointer = head
    while pointer:
        valList.append(pointer.val)
        pointer = pointer.next
    valList.sort()
    pointer = head
    while pointer:
        pointer.val = valList.pop(0)
        pointer = pointer.next
    return 


if __name__ == "__main__":
    # head = createChain(5)
    # showChain(head)
    # showChainXth(head, 3)

    # insertNode(head,999, 1000)
    # showChain(head)

    # deleteNode(head, 1000)
    # showChain(head)

    # sortNode(head)
    # showChain(head)

    Li = [0, 0]
    head = createChainFromList(Li)
    showChain(head)

$0
endsnippet
# ::::::::::::::
# ./06/deleteNode.py
# ::::::::::::::
snippet deleteNode "deleteNode" b
#!/usr/bin/env python3
#-*- coding:utf-8 -*-

from createNode import *


head = createChain(10)

def deleteNode(node):
    val = node.val
    global head
    pointer = head
    while pointer.next.val != val:
        pointer = pointer.next
    pointer.next = pointer.next.next
    return 


if __name__ == "__main__":
    showChain(head)
    insertChain(head, 4, 55)
    showChain(head)
    node = ListNode(55)
    deleteNode(node)
    showChain(head)


$0
endsnippet
# ::::::::::::::
# ./06/hasCycel.py
# ::::::::::::::
snippet hasCycel "hasCycel" b
#!/usr/bin/env python3
#-*- coding:utf-8 -*-

from createNode import *

def hasCycle(self, head):
    if head == None:
        return False
    fast = head
    slow = head
    while fast:
        try:
            fast = fast.next.next
            slow = slow.next
        except :
            return False
        if fast == None or slow == None:
            return False
        if fast == slow:
            return True

if __name__ == "__main__":
    pass

$0
endsnippet
# ::::::::::::::
# ./06/isPalindrome.py
# ::::::::::::::
snippet isPalindrome "isPalindrome" b
#!/usr/bin/env python3
#-*- coding:utf-8 -*-
from createNode import *


def isPalindrome(head):
    if head == None:
        return True
    valList = []
    while head:
        valList.append(head.val)
        head = head.next
    rList = valList[::-1]
    if rList == valList:
        return True
    else:
        return False
    

if __name__ == '__main__':
    head = createChainFromList([0, 0])
    showChain(head)
    print(isPalindrome(head))


$0
endsnippet
# ::::::::::::::
# ./06/mergeTwoLists.py
# ::::::::::::::
snippet mergeTwoLists "mergeTwoLists" b
#!/usr/bin/env python3
#-*- coding:utf-8 -*-


from createNode import *

def mergeTwoLists(l1, l2):
    if l1 == None and l2 == None: #两条列表都是空列表
        return None
    fakeNode = ListNode(0)
    head = fakeNode
    while l1 != None or l2 != None: #俩调链表遍历完毕
        if l1 == None: #l1遍历完毕
            head.next = l2
            l2 = l2.next
            head = head.next
        elif l2 == None: #l2遍历完毕
            head.next = l1
            l1 = l1.next
            head = head.next
        else:
            if l1.val <= l2.val: #比较l1.val 和 l2.val
                head.next = l1  
                l1 = l1.next
                head = head.next
            else:
                head.next = l2
                l2 = l2.next
                head = head.next
    return fakeNode.next

if __name__ == "__main__":
    l1 = createChain(3)
    sortNode(l1)
    showChain(l1)
    l2 = createChain(3)
    sortNode(l2)
    showChain(l2)
    head = mergeTwoLists(l1, l2)
    showChain(head)
                

$0
endsnippet
# ::::::::::::::
# ./06/removeNthFromEnd.py
# ::::::::::::::
snippet removeNthFromEnd "removeNthFromEnd" b
#!/usr/bin/env python3
#-*- coding:utf-8 -*-
from createNode import *

def removeNthFromEnd(head: ListNode, n: int) -> ListNode:
    # 常规算法
    # pointer = head
    # length = 0
    # while pointer:
    #     pointer = pointer.next
    #     length += 1
    # if length == 1:
    #     return None
    # pointer = head
    # if n >= length:
    #     head.val = head.next.val
    #     head.next = head.next.next
    # else:
    #     if n == 1:
    #         for i in range(length - 2):
    #             pointer = pointer.next
    #         pointer.next = None
    #     else:
    #         for i in range(length - n - 1):
    #             pointer = pointer.next
    #         pointer.next  = pointer.next.next
    # return head

    # 进阶算法
    if head.next == None:
        return None
    left = right = head
    si = 0 
    while si < n:
        si += 1
        right = right.next
    if right == None:
        head = head.next #删除第一个节点
        return head
    while right.next != None:
        left = left.next
        right = right.next
    if n == 1: #删除最后一个节点
        left.next = None
    else: #删除中间的节点
        left.next = left.next.next
    return head
    




if __name__ == "__main__":
    # head = createChain(6)
    head = createChainFromList([2, 1])
    showChain(head)
    rHead = removeNthFromEnd(head, 2)
    showChain(rHead)

$0
endsnippet
# ::::::::::::::
# ./06/reverseList.py
# ::::::::::::::
snippet reverseList "reverseList" b
#!/usr/bin/env python3
#-*- coding:utf-8 -*-

from createNode import *

def reverseList(head: ListNode) -> ListNode:
    # valList = []
    # pointer = head
    # while pointer:
    #     valList.append(pointer.val)
    #     pointer = pointer.next
    # pointer = head
    # while valList:
    #     pointer.val = valList.pop()
    #     pointer = pointer.next
    # return head

    if head == None:
        return None
    left = right = head
    if right.next == None:
        return head
    else:
        right = right.next
        left.next = None
    while right != None:
        head = right
        right = right.next
        head.next = left
        left = head
    return head
    
    


if __name__ == "__main__":
    head = createChain(4)
    showChain(head)
    rHead = reverseList(head)
    showChain(rHead)

$0
endsnippet
# ::::::::::::::
# ./07/createTreeNode.py
# ::::::::::::::
snippet createTreeNode "createTreeNode" b
#!/usr/bin/env python3
#-*- coding:utf-8 -*-

class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

def createTreeFromList(tList):
    val = tList.pop(0)
    if val:
        return
    else:
        root.val = val
    val = tList.pop(0)
    if val:
        return
    else:
        root.left.val = val
    val = tList.pop(0)
    if val:
        return
    else:
        root.right.val = val
    # root = TreeNode(tList.pop(0))
    # root.left = createTreeFromList(tList)
    # root.right = createTreeFromList(tList)
    return root

def showMidTree(root):
    if root.val == None:
        print("None -> " , end="")
        return
    else:
        print("%d -> " %root.val, end="")

    showMidTree(root.left)
    showMidTree(root.right)
    return

if __name__ == "__main__":
    # tList = [3, 9, 20, None, None, 15, 7]
    tList = [3, 9, None, None, 20, 15, 7]
    root = createTreeFromList(tList)
    showMidTree(root)

$0
endsnippet
# ::::::::::::::
# ./07/isValidBST.py
# ::::::::::::::
snippet isValidBST "isValidBST" b
#!/usr/bin/env python3
#-*- coding:utf-8 -*-

from createTreeNode import *

def isValidBST(root):



if __name__ == "__main__":
    root = TreeNode(10)
    root.left = TreeNode(5)
    root.right = TreeNode(15)
    root.right.left = TreeNode(6)
    root.right.right = TreeNode(20)
    print(isValidBST(root))

$0
endsnippet
# ::::::::::::::
# ./07/levelOrder.py
# ::::::::::::::
snippet levelOrder "levelOrder" b
#!/usr/bin/env python3
#-*- coding:utf-8 -*-

class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

def levelOrder(root):
    """
    :type root: TreeNode
    :rtype: List[List[int]]
    """
    rList = []
    subList = []
    if not root:
        return rList
    else:
        cNodeList = [root] #current layer node
    nNodeList = [] #next layer node
    while True:
        if cNodeList:
            node = cNodeList.pop(0)
            subList.append(node.val)
            if node.left and node.right:
                nNodeList.append(node.left)
                nNodeList.append(node.right)
            elif node.left:
                nNodeList.append(node.left)
            elif node.right:
                noNdeList.append(node.right)
            else:
                pass
        else:
            rList.append(subList[:])
            subList = []
            if not nNodeList:
                break
            else:
                cNodeList = nNodeList[:]
                nNodeList = []
    return rList


if __name__ == "__main__":
    # root = TreeNode(1)
    # root.left = TreeNode(2)
    # root.right = TreeNode(3)
    print(levelOrder(root))


$0
endsnippet
# ::::::::::::::
# ./07/maxDepth.py
# ::::::::::::::
snippet maxDepth "maxDepth" b
        if root == None:
            return 0
        else:
            return 1 + max(self.maxDepth(root.right), self.maxDepth(root.left))

$0
endsnippet
# ::::::::::::::
# ./08/firstBadVersion.py
# ::::::::::::::
snippet firstBadVersion "firstBadVersion" b
#!/usr/bin/env python3
#-*- coding:utf-8 -*-

def firstBadVersion(n):
    #折半查找--二分法查找
    left = 1
    right = n
    while left <= n:
        mid = (left + right) //2
        if isBadVersion(mid):
            if isBadVersion(mid - 1):
                right = mid
            else:
                return mid
        else:
            if isBadVersion(mid + 1):
                return mid + 1
            else:
                left = mid

if __name__ == "__main__":
    n = 5
    

$0
endsnippet
# ::::::::::::::
# ./08/merge.py
# ::::::::::::::
snippet merge "merge" b
#!/usr/bin/env python3
#-*- coding:utf-8 -*-


def merge(nums1, m, nums2, n):
    # nums1[m: m+n] = nums2[:n]
    # for right in range(m, m+n):
    #     target = nums1[right]
    #     for left in range(0, right):
    #         if target <= nums1[left]:
    #             nums1[left+1:right+1] = nums1[left:right] #使用Python的切片赋值
    #             nums1[left] = target
    #             break        
    # return

    for i in range(n):
        nums1[m + i] = nums2[i]
    nums1.sort()
    return


if __name__ == "__main__":
    # nums1 = [1, 2, 3, 0, 0, 0]
    # nums2 = [4, 5, 6]
    # m = 3
    # n = 3
    # nums1 = [2, 0]
    # nums2 = [1]
    # m = 1
    # n = 1
    nums1 = [4, 0, 0, 0, 0, 0]
    nums2 = [1, 2, 3, 5, 6]
    m = 1
    n = 5
    print("before nums1 = %s" %(str(nums1)))
    print("before nums2 = %s" %(str(nums2)))
    merge(nums1, m, nums2, n)
    print("after nums1 = %s" %(str(nums1)))

$0
endsnippet
# ::::::::::::::
# ./08/minStack.py
# ::::::::::::::
snippet minStack "minStack" b
#!/usr/bin/env python3
#-*- coding:utf-8 -*-



class MinStack(object):
    def __init__(self):
        self.stack = []

    def push(self, x):
        self.stack.append(x)

    def pop(self):
        try:
            self.stack.pop():
        except Exception as e:
            pass

    def top(self):
        try:
            x = self.stack[-1]
        except Exception as e:
            return None
        else:
            return x

    def getMin(self):
        try:
            mi = min(self.stack)
        except Exception as e:
            return None
        else:
            return mi


if __name__ == "__main__":
    MS = MinStack()
    MS.push(x)
    MS.pop()
    param_3 = MS.top()
    param_4 = MS.getMin()

$0
endsnippet
# ::::::::::::::
# ./08/shuffleAnArray.py
# ::::::::::::::
snippet shuffleAnArray "shuffleAnArray" b
#!/usr/bin/env python3
#-*- coding:utf-8 -*-
import random
import copy

class Solution(object):
    def __init__(self, nums):
        self.nums = nums[:]
        self.numsCopy = nums[:]

    def reset(self):
        self.nums = self.numsCopy
        return self.nums

    def shuffle(self):
        sList = self.nums[:]
        rList = []
        while sList:
            val = random.choice(sList)
            rList.append(val)
            sList.remove(val)
        return rList

        # result = []
        # temp = copy.deepcopy(self.nums) 
        # while len(temp) != 0:
        #     toInsert = temp[random.randint(0,len(temp)-1)]
        #     result.append(toInsert)
        #     temp.remove(toInsert)
        # return result


def showArray(nums):
    print("nums = %s" %(str(nums)))

if __name__ == "__main__":
    nums = [1, 2, 3]
    array = Solution(nums)
    param_1 = array.reset()
    showArray(param_1)
    param_2 = array.shuffle()
    showArray(param_2)

$0
endsnippet
# ::::::::::::::
# ./09/climbStairs.py
# ::::::::::::::
snippet climbStairs "climbStairs" b
#!/usr/bin/env python3
#-*- coding:utf-8 -*-



def climbStairs(n):
    stepList = [1, 1, 2]
    i = n
    while i > 2:
        stepList.append(stepList[-1] + stepList[-2])
        i -= 1
    return stepList[n]

if __name__ == "__main__":
    n = 5
    print("count need %d step" %climbStairs(n))
    

$0
endsnippet
# ::::::::::::::
# ./09/maxProfit.py
# ::::::::::::::
snippet maxProfit "maxProfit" b
#!/usr/bin/env python3
#-*- coding:utf-8 -*-



def maxProfit(prices):
    profit = 0
    for i in range(len(prices) - 1):
        sub = max(prices[i + 1:]) - prices[i]
        profit = max(sub, profit)
    return profit

    # if len(prices) < 2:
    #     return 0
    # maxList = []
    # for j in range(len(prices) - 1):
    #     for i in range(j + 1, len(prices)):
    #         maxList.append(prices[i] - prices[j])
    # profit = max(maxList)
    # if profit < 0:
    #     return 0
    # else:
    #     return profit



    


if __name__ == "__main__":
    prices = [7, 1, 5, 3, 6, 4]
    # prices = [2,1,2,1,0,1,2]
    profit = maxProfit(prices)
    print("The max profit = %d" %profit)

$0
endsnippet
# ::::::::::::::
# ./09/maxSubArray.py
# ::::::::::::::
snippet maxSubArray "maxSubArray" b
#!/usr/bin/env python3
#-*- coding:utf-8 -*-


def maxSubArray(nums):
    subSum = 0
    maxSum = nums[0]
    for i in range(len(nums)):
        subSum += nums[i]
        if subSum > maxSum:
            maxSum = subSum
        if subSum < 0:
            subSum = 0
    return maxSum



if __name__ == "__main__":
    nums = [-2,1,-3,4,-1,2,1,-5,4]
    # nums = [-1, -3 ,-5, -2, -4]
    maxSum = maxSubArray(nums)
    print("The max count is : %d" %maxSum)

$0
endsnippet
# ::::::::::::::
# ./09/rob.py
# ::::::::::::::
snippet rob "rob" b
#!/usr/bin/env python3
#-*- coding:utf-8 -*-

def rob(nums):
    if len(nums) == 0:
        return 0
    if len(nums) == 1:
        return nums[0]
    maxCash = [nums[0], max(nums[0], nums[1])]
    for i in range(2, len(nums)):
        maxCash.append(max(nums[i] + maxCash[i - 2], maxCash[i - 1]))
    # print(maxCash)
    return maxCash[-1]


if __name__ == "__main__":
    # nums = [1,2,3,1]
    nums = [2, 7, 9, 3, 1]
    maxCash = rob(nums)
    print("get max cash is %d" %maxCash)

$0
endsnippet
# ::::::::::::::
# ./10/countPrimesV1.py
# ::::::::::::::
snippet countPrimesV1 "countPrimesV1" b
#!/usr/bin/env python3
#-*- coding:utf-8 -*-
import timeit

def countPrimes(n):
    '''按照质数的定义，用常规的方法来取质数 '''
    primesList = []
    for i in range(2, n+1):
        flag = True
        for divNum in range(2, i): # 从2到i-1，一个一个的除，如果有余数为0的状况，可以确定不是质数，退出循环
            if i % divNum == 0:
                flag = False
                break
        if flag:
            primesList.append(i)
    # print(primesList)
    return len(primesList)

if __name__ == "__main__":
    print(timeit.timeit("countPrimes(10000)", "from __main__ import countPrimes", number=10))
    print(countPrimes(10000))

$0
endsnippet
# ::::::::::::::
# ./10/countPrimesV2.py
# ::::::::::::::
snippet countPrimesV2 "countPrimesV2" b
#!/usr/bin/env python3
#-*- coding:utf-8 -*-
import timeit

def countPrimes(n):
    '''倍数筛选法获取质数 '''
    if n <= 2:
        return 0
    elif n == 3:
        return 1
    elif n == 4:
        return 2
    primesList = list(range(2, n))
    multList = []
    for i in range(0, n//2 + 1):
        multList += list(range(primesList[i], n+1))[::primesList[i]][1::]
    primesList = list(set(primesList) - set(multList)) # 利用集合过滤掉倍数
    primesList.sort()
    # print(primesList)
    return len(primesList)

if __name__ == "__main__":
    # print(timeit.timeit("countPrimes(10000)", "from __main__ import countPrimes", number=10))
    # print(countPrimes(10000))
    print(countPrimes(5))

$0
endsnippet
# ::::::::::::::
# ./10/countPrimesV3.py
# ::::::::::::::
snippet countPrimesV3 "countPrimesV3" b
#!/usr/bin/env python3
#-*- coding:utf-8 -*-
import timeit

def countPrimes(n):
    '''埃拉托斯特尼筛法获取质数 '''
    if n<3:
        return 0 # n<3时是没有质数的
    boolList = [True]*n
    boolList[0] = False
    boolList[1] = False
    for i in range(2, int(pow(n, 0.5)) + 1):
        if boolList[i]: #如果boolList[i]的值已经是False了，那说明在之前比较小的数的倍数已经筛选过一次了。可以不用再次筛选了。
            boolList[i::i] = [False]*len(boolList[i::i])
            boolList[i] = True
    # primesList = []
    # i = 0
    # while i < n:
    #     if boolList[i]:
    #         primesList.append(i)
    #     i += 1
    # print(primesList)
    return sum(boolList)

if __name__ == "__main__":
    print(timeit.timeit("countPrimes(10000)", "from __main__ import countPrimes", number=10))
    print(countPrimes(10000))

$0
endsnippet
# ::::::::::::::
# ./10/fizzBuzz.py
# ::::::::::::::
snippet fizzBuzz "fizzBuzz" b
#!/usr/bin/env python3
#-*- coding:utf-8 -*-



def fizzBuzz(n):
    rList = []
    for i in range(1, n+1):
        if i%3 == 0 and i%5 == 0:
            rList.append("FizzBuzz")
        elif i%3 == 0:
            rList.append("Fizz")
        elif i%5 == 0:
            rList.append("Buzz")
        else:
            rList.append(str(i))
    return rList

if __name__ == "__main__":
    n = 5
    rList = fizzBuzz(n)
    for s in rList:
        print(s)

$0
endsnippet
# ::::::::::::::
# ./10/isPowerOfThree.py
# ::::::::::::::
snippet isPowerOfThree "isPowerOfThree" b
#!/usr/bin/env python3
#-*- coding:utf-8 -*-



def isPowerOfThree(n):
    power3 = lambda i: pow(3, i)
    i = 0
    while power3(i) == n:
        if power3(i) == n:
            return True
        else:
            i += 1
    return False

if __name__ == "__main__":
    n = 15
    print("n = %d, return %s" %(n, isPowerOfThree(n)))

$0
endsnippet
# ::::::::::::::
# ./10/romanToInt.py
# ::::::::::::::
snippet romanToInt "romanToInt" b
#!/usr/bin/env python3
#-*- coding:utf-8 -*-

def romanToInt(s):
    romanDic = {
        'I': 1,
        'V': 5,
        'X': 10,
        'L': 50,
        'C': 100,
        'D': 500,
        'M': 1000
    }
    doubleDic = {
        "IV": 4,
        "IX": 9,
        "XL": 40,
        "XC": 90,
        "CD": 400,
        "CM": 900
    }
    sum = 0 #count number
    i = 0 #pointer
    while i < len(s):
        try:
            s[i:i+2]
        except IndexError as e:
            sum += romanDic[s[i]]
            i += 1
        else:
            if s[i:i+2] in doubleDic.keys():
                sum += doubleDic[s[i:i+2]]
                i += 2
            else:
                sum += romanDic[s[i]]
                i += 1
    return sum

if __name__ == "__main__":
    # s = "III"
    s = "MCMXCIV"
    # s = "IV"
    print(romanToInt(s))

$0
endsnippet
# ::::::::::::::
# ./11/generate.py
# ::::::::::::::
snippet generate "generate" b
#!/usr/bin/env python3
#-*- coding:utf-8 -*-


def generate(numRows):
    rList = []
    for i in range(1, numRows + 1):
        tempList = i * [None]
        tempList[0] = 1
        tempList[-1] = 1
        # if i > 2:
        if None in tempList:
            for n in range(1, i - 1):
                tempList[n] = rList[i - 2][n - 1] + rList[i - 2][n]
        rList.append(tempList)
    return rList


if __name__ == "__main__":
    numRows = 5
    print(generate(numRows))

$0
endsnippet
# ::::::::::::::
# ./11/hammingDistance.py
# ::::::::::::::
snippet hammingDistance "hammingDistance" b
#!/usr/bin/env python3
#-*- coding:utf-8 -*-



def hammingDistance(x, y):
    xList = list(bin(x))[2::]
    yList = list(bin(y))[2::]
    if len(xList) < 31:
        xList = ['0'] * (31 - len(xList)) + xList
    if len(yList) < 31:
        yList = ['0'] * (31 - len(yList)) + yList
    n = 0
    for i in range(31):
        if xList[i] != yList[i]:
            n += 1
    return n

if __name__ == "__main__":
    x = 2
    y = 4
    print("The hamming Distance is : %d" %(hammingDistance(x, y)))

$0
endsnippet
# ::::::::::::::
# ./11/hammingWeight.py
# ::::::::::::::
snippet hammingWeight "hammingWeight" b
#!/usr/bin/env python3
# -*- coding:utf-8 -*-

def hammingWeight(n):
    bList = list(bin(n))
    # sum = 0
    # while bList:
    #     c = bList.pop()
    #     if c == '1':
    #         sum += 1
    # return sum
    return bList.count('1')


if __name__ == "__main__":
    n = 0b00000000000000000000000000001011
    print("The hamming weight is : %d" % (hammingWeight(n)))


$0
endsnippet
# ::::::::::::::
# ./11/isValid.py
# ::::::::::::::
snippet isValid "isValid" b
#!/usr/bin/env python3
#-*- coding:utf-8 -*-



def isValid(s):
    if len(s)%2 != 0:
        return False
    symbolDic = {'{':'}', '[': ']', '(': ')'}
    stack = []
    for i in range(len(s)):
        if len(stack) == 0:
            if s[i] in symbolDic.keys():
                stack.append(s[i])
            else:
                return False
        else: # len(stack) != 0
            if s[i] in symbolDic.keys():
                stack.append(s[i])
            else:
                if symbolDic[stack[-1]] == s[i]:
                    stack.pop()
                else:
                    return False
    if len(stack) == 0:
        return True
    else:
        return False

if __name__ == "__main__":
    s = "{[]}"
    # s = "){"
    # s = "(([]){})"
    # s = "()[]{}"
    # s = "[({(())}[()])]"
    # s = "(("
    # s = "()"
    print(isValid(s))

$0
endsnippet
# ::::::::::::::
# ./11/missingNumber.py
# ::::::::::::::
snippet missingNumber "missingNumber" b
#!/usr/bin/env python3
#-*- coding:utf-8 -*-



def missingNumber(nums):
    try:
        n = (set(range(len(nums) + 1)) - set(nums)).pop()
    except KeyError as e:
        return
    else:
        return n

if __name__ == "__main__":
    nums = [0]
    n = missingNumber(nums)
    print("The missing number is %d" %(n))

$0
endsnippet
# ::::::::::::::
# ./11/reverseBits.py
# ::::::::::::::
snippet reverseBits "reverseBits" b
#!/usr/bin/env python3
#-*- coding:utf-8 -*-



def reverseBits(n):
    dec2bin = bin(n)
    newBin = dec2bin[::-1][:-2]
    if len(newBin) < 32:
        newBin += '0'*(32-len(newBin))
    newDec = int(newBin, 2)
    return newDec

if __name__ == "__main__":
    n = 43261596
    print(reverseBits(n))

$0
endsnippet
