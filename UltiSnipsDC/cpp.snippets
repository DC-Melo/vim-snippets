priority -50

extends c

# We want to overwrite everything in parent ft.
priority -49
###########################################################################
#			    Global functions 						  #
###########################################################################

global !p

def write_docstring_args(arglist, snip):
	args = str(arglist).split(',')

	if len(args) > 1:
		c = 0
		for arg in args:
			if c == 0:
				snip.rv += arg
				c = 1
			else:
				snip += '*       : %s' % arg.strip()
	else:
		snip.rv = args[0]


endglobal

###########################################################################
#                            TextMate Snippets                            #
###########################################################################

snippet mainAppFW "main and App"
/* code by 王江 DC-Melo */
#include <string>
#include <vector>
#include <chrono>
#include <iostream>
using namespace std;
class App
{
public:
    App() {}
    ~App() {}
private:
};
int main() {
    return 0;
}
$0
endsnippet

snippet printDuration "print duration"
/* timestamp begin */
auto tBegin = std::chrono::high_resolution_clock::now();
/* code heer */

/* timestamp end */
auto tEnd = std::chrono::high_resolution_clock::now();
auto duration = std::chrono::duration_cast<std::chrono::microseconds>( tEnd - tBegin).count();
std::cout << "\nprogram cust " <<  duration <<" microseconds" << std::endl;
$0
endsnippet

snippet initInclude "init include "
using namespace std;
// #include <bits/stdc++.h>
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include "math.h"
#include <string>
#include <set>
#include <sstream>
#include <cstring>
#include <ctime>
#include <vector>
#include <iostream>
#include <unordered_map>
#include <chrono>
$0
endsnippet
######################################################################
#   Array                                                            #
######################################################################
snippet initArray "Initializing a array"
int ${1:arr}[] = { 1, 2, 3, 4, 5 };
$0
endsnippet
snippet printArray "loop through the array elements"
for (size_t i = 0; i < sizeof(${1:arr})/sizeof($1[0]); i++) std::cout << $1[i] << '\t'; std::cout << std::endl;
$0
endsnippet
snippet printArray "Print contents of an array in C++ using range-based for-loop"
for (const auto &value : ${1:arr})  std::cout << value << '\t'; std::cout << std::endl;
$0
endsnippet

######################################################################
#   2D Array                                                         #
######################################################################

snippet initArray2D "Initializing a array"
int ${1:arr2d}[][4] = { {1,2,3,4}, {5,6,7,8} };
$0
endsnippet
snippet printArray2D "loop through the array elements"
for (int i = 0; i < sizeof(${1:arr2d}) / sizeof($1[0]); ++i) {for (int j = 0; j < sizeof($1[0]) / sizeof($1[0][0]); ++j) std::cout << $1[i][j] << "\t"; std::cout << std::endl;}
$0
endsnippet

######################################################################
#   vector                                                           #
######################################################################
snippet initVector "Initializing like arrays"
vector<int> ${1:vect}{ 10, 20, 30 };
$0
endsnippet
snippet initVector "Initializing from an array"
int arr[] = { 10, 20, 30 };
int n = sizeof(arr) / sizeof(arr[0]);
vector<int> ${1:vect}(arr, arr + n);
$0
endsnippet
snippet initVector "Specifying size and initializing all values"
vector<int> ${1:vect}(3, 10);
$0
endsnippet
snippet initVector "Initializing by pushing values one by one"
vector<int> ${1:vect};
$1.push_back(10);
$1.push_back(20);
$1.push_back(30);
$0
endsnippet
snippet printVector " print vector "
for (auto x : ${1:vect}) std::cout << x << "\t"; std::cout << std::endl;
$0
endsnippet
snippet printVector " print vector "
for (auto i = ${1:vect}.begin(); i != $1.end(); ++i) std::cout << *i << '\t';std::cout << std::endl;
$0
endsnippet
snippet printVector " print vector "
for (int i = 0; i < ${1:vect}.size(); i++)  std::cout << $1[i] << "\t";std::cout << std::endl;
$0
endsnippet

######################################################################
#   matrix                                                           #
######################################################################
snippet initMatrix "Initializing a 2D Vector i.e. vector of vectors"
vector<vector<char>> matrix = { {'1','2' ,'3' ,'4' ,'a'  },
								{'6','7' ,'8' ,'9' ,'b'  },
								{'5','6' ,'8' ,'1' ,'c'  },
								{'1','7' ,'2' ,'4' ,'d'  },
							 };
$0
endsnippet
snippet printMatrix "Initializing a 2D Vector i.e. vector of vectors"
for ( const auto &v : matrix ) { for ( auto x : v ) std::cout << x << '\t'; std::cout << std::endl; }
$0
endsnippet
snippet printMatrix "Initializing a 2D Vector i.e. vector of vectors"
for (int i = 0; i < ${1:matrix}.size(); i++) { for (int j = 0; j < $1[i].size(); j++)  cout << $1[i][j] << "\t"; std::cout << endl; }
$0
endsnippet

######################################################################
#  singly linked list                                                #
######################################################################
snippet singlyLinkedListDefinition "Definition for singly-linked list."
struct ListNode {
	int val;
	ListNode *next;
	ListNode() : val(0), next(nullptr) {}
	ListNode(int x) : val(x), next(nullptr) {}
	ListNode(int x, ListNode *next) : val(x), next(next) {}
};
$0
endsnippet
snippet printListNode "init list node"
ListNode* head = new ListNode(0);
for(ListNode* pi =l2;pi!=NULL;pi=pi->next) cout<<pi->val << " "; std::cout << std::endl;
ListNode* ptr =head;
while(ptr!=NULL){
	cout<<ptr->val<<"\t";
	ptr = ptr->next;
}
$0
endsnippet


######################################################################
#  tree                                                              #
######################################################################
snippet treeNodeDefination "Definition for a binary tree node.  "
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

$0
endsnippet

snippet printBinaryTree "Print binary tree structure with its contents"
// Data structure to store a binary tree node
struct Trunk
{
    Trunk *prev;
    string str;

    Trunk(Trunk *prev, string str)
    {
        this->prev = prev;
        this->str = str;
    }
};

// Helper function to print branches of the binary tree
void showTrunks(Trunk *p)
{
    if (p == nullptr) {
        return;
    }

    showTrunks(p->prev);
    cout << p->str;
}

void printTree(TreeNode* root, Trunk *prev, bool isLeft)
{
    if (root == nullptr) {
        return;
    }

    string prev_str = "    ";
    Trunk *trunk = new Trunk(prev, prev_str);

    printTree(root->right, trunk, true);

    if (!prev) {
        trunk->str = "———";
    }
    else if (isLeft)
    {
        trunk->str = ".———";
        prev_str = "   |";
    }
    else {
        trunk->str = "\`———";
        prev->str = prev_str;
    }

    showTrunks(trunk);
    cout << " " << root->val << endl;

    if (prev) {
        prev->str = prev_str;
    }
    trunk->str = "   |";

    printTree(root->left, trunk, false);
}

int main()
{
    // Construct above tree
    TreeNode* root = new TreeNode(1);
    root->left = new TreeNode(2);
    root->right = new TreeNode(3);
    root->left->left = new TreeNode(4);
    root->left->right = new TreeNode(5);
    root->right->left = new TreeNode(6);
    root->right->right = new TreeNode(7);
    root->left->left->left = new TreeNode(8);
    root->left->left->right = new TreeNode(9);
    root->left->right->left = new TreeNode(10);
    root->left->right->right = new TreeNode(11);
    root->right->left->left = new TreeNode(12);
    root->right->left->right = new TreeNode(13);
    root->right->right->left = new TreeNode(14);
    root->right->right->right = new TreeNode(15);

    // print constructed binary tree
    printTree(root, nullptr, false);

    return 0;
}

$0
endsnippet
######################################################################
#  graph                                                             #
######################################################################

# 2  sort
# 3  search
# 4  array
# 5  string
# 6  linknode
# 7  tree
# 7.1 
snippet btMinDepth "Recursion=Given the root of a binary tree, return its maximum depth." b
/* C++ implementation to find minimum depth of a given Binary tree */
#include <iostream>
#include<math.h>
using namespace std;

struct TreeNode
{
int data;
struct TreeNode *left;
struct TreeNode *right;
TreeNode(int k){
	data = k;
	left = right = NULL;
}
};

/* Function to calculate the minimum depth of the tree */
int minimumDepth(TreeNode *root, int level)
{

		if (root == NULL)
			return level;
		level++;

		return min(minimumDepth(root->left, level),
				minimumDepth(root->right, level));
}

/* Driver program to test above functions */
int main()
{

	// Let us create binary tree shown in above diagram
	TreeNode *root = new TreeNode(1);
	root->left = new TreeNode(2);
	root->right = new TreeNode(3);
	root->left->left = new TreeNode(4);
	root->left->right = new TreeNode(5);

	cout << minimumDepth(root, 0);
	return 0;
}

// This code is contributed by aafreen1804.

$0
endsnippet
snippet btMaxDepth "Recursion=Given the root of a binary tree, return its maximum depth." b
// C++ program to find height of tree
#include <bits/stdc++.h>
using namespace std;


/* A binary tree node has data, pointer to left child
and a pointer to right child */
class node
{
	public:
	int data;
	node* left;
	node* right;
};

/* Compute the "maxDepth" of a tree -- the number of
	nodes along the longest path from the root node
	down to the farthest leaf node.*/
int maxDepth(node* node)
{
	if (node == NULL)
		return -1;
	else
	{
		/* compute the depth of each subtree */
		int lDepth = maxDepth(node->left);
		int rDepth = maxDepth(node->right);

		/* use the larger one */
		if (lDepth > rDepth)
			return(lDepth + 1);
		else return(rDepth + 1);
	}
}

/* Helper function that allocates a new node with the
given data and NULL left and right pointers. */
node* newTreeNode(int data)
{
	node* TreeNode = new node();
	TreeNode->data = data;
	TreeNode->left = NULL;
	TreeNode->right = NULL;

	return(TreeNode);
}

// Driver code
int main()
{
	node *root = newTreeNode(1);

	root->left = newTreeNode(2);
	root->right = newTreeNode(3);
	root->left->left = newTreeNode(4);
	root->left->right = newTreeNode(5);

	cout << "Height of tree is " << maxDepth(root);
	return 0;
}

// This code is contributed by Amit Srivastav

$0
endsnippet
snippet btMaxDepth "Level Order Traversal=Given the root of a binary tree, return its maximum depth." b
#include <iostream>
#include <bits/stdc++.h>
using namespace std;

// A Tree node
struct TreeNode
{
	int key;
	struct TreeNode* left, *right;
};

// Utility function to create a new node
TreeNode* newTreeNode(int key)
{
	TreeNode* temp = new TreeNode;
	temp->key = key;
	temp->left = temp->right = NULL;
	return (temp);
}

/*Function to find the height(depth) of the tree*/
int height(struct TreeNode* root){

	//Initialising a variable to count the
	//height of tree
	int depth = 0;

	queue<TreeNode*>q;

	//Pushing first level element along with NULL
	q.push(root);
	q.push(NULL);
	while(!q.empty()){
		TreeNode* temp = q.front();
		q.pop();

		//When NULL encountered, increment the value
		if(temp == NULL){
			depth++;
		}

		//If NULL not encountered, keep moving
		if(temp != NULL){
			if(temp->left){
				q.push(temp->left);
			}
			if(temp->right){
				q.push(temp->right);
			}
		}

		//If queue still have elements left,
		//push NULL again to the queue.
		else if(!q.empty()){
			q.push(NULL);
		}
	}
	return depth;
}

// Driver program
int main()
{
	// Let us create Binary Tree shown in above example
	TreeNode *root = newTreeNode(1);
	root->left = newTreeNode(12);
	root->right = newTreeNode(13);

	root->right->left = newTreeNode(14);
	root->right->right = newTreeNode(15);

	root->right->left->left = newTreeNode(21);
	root->right->left->right = newTreeNode(22);
	root->right->right->left = newTreeNode(23);
	root->right->right->right = newTreeNode(24);

	cout<<"Height(Depth) of tree is: "<<height(root);
}

$0
endsnippet
# 7.2 
snippet isBinarySearchTree "Recursion = Given the root of a binary tree, determine if it is a valid binary search tree (BST)." b
// C++ program to check if a given tree is BST.
#include <bits/stdc++.h>
using namespace std;

/* A binary tree node has data, pointer to
left child and a pointer to right child */
struct TreeNode
{
	int data;
	struct TreeNode* left, *right;
};

// Returns true if given tree is BST.
bool isBST(TreeNode* root, TreeNode* l=NULL, TreeNode* r=NULL)
{
	// Base condition
	if (root == NULL)
		return true;

	// if left node exist then check it has
	// correct data or not i.e. left node's data
	// should be less than root's data
	if (l != NULL and root->data <= l->data)
		return false;

	// if right node exist then check it has
	// correct data or not i.e. right node's data
	// should be greater than root's data
	if (r != NULL and root->data >= r->data)
		return false;

	// check recursively for every node.
	return isBST(root->left, l, root) and
		isBST(root->right, root, r);
}

/* Helper function that allocates a new node with the
given data and NULL left and right pointers. */
struct TreeNode* newTreeNode(int data)
{
	struct TreeNode* node = new TreeNode;
	node->data = data;
	node->left = node->right = NULL;
	return (node);
}

/* Driver program to test above functions*/
int main()
{
	struct TreeNode *root = newTreeNode(3);
	root->left	 = newTreeNode(2);
	root->right	 = newTreeNode(5);
	root->left->left = newTreeNode(1);
	root->left->right = newTreeNode(4);

	if (isBST(root,NULL,NULL))
		cout << "Is BST";
	else
		cout << "Not a BST";

	return 0;
}

$0
endsnippet
snippet isBinarySearchTree "midOrderTraversal = Given the root of a binary tree, determine if it is a valid binary search tree (BST)." b
// C++ program to check if a given tree is BST.
#include <bits/stdc++.h>
using namespace std;

/* A binary tree node has data, pointer to
left child and a pointer to right child */
struct TreeNode
{
	int data;
	struct TreeNode* left, *right;

	TreeNode(int data)
	{
		this->data = data;
		left = right = NULL;
	}
};


bool isBSTUtil(struct TreeNode* root, TreeNode *&prev)
{
	// traverse the tree in inorder fashion and
	// keep track of prev node
	if (root)
	{
		if (!isBSTUtil(root->left, prev))
		return false;

		// Allows only distinct valued nodes
		if (prev != NULL && root->data <= prev->data)
		return false;

		prev = root;

		return isBSTUtil(root->right, prev);
	}

	return true;
}

bool isBST(TreeNode *root)
{
TreeNode *prev = NULL;
return isBSTUtil(root, prev);
}

/* Driver program to test above functions*/
int main()
{
	struct TreeNode *root = new TreeNode(3);
	root->left	 = new TreeNode(2);
	root->right	 = new TreeNode(5);
	root->left->left = new TreeNode(1);
	root->left->right = new TreeNode(4);

	if (isBST(root))
		cout << "Is BST";
	else
		cout << "Not a BST";

	return 0;
}

$0
endsnippet
# 7.3 
snippet btIsMirror "Recursion=Given a binary tree, check whether it is a mirror of itself." b
// C++ program to check if a given
// Binary Tree is symmetric or not
#include <bits/stdc++.h>
using namespace std;

// A Binary Tree TreeNode
struct TreeNode
{
	int key;
	struct TreeNode *left, *right;
};

// Utility function to create new TreeNode
TreeNode* newTreeNode(int key)
{
	TreeNode* temp = new TreeNode;
	temp->key = key;
	temp->left = temp->right = NULL;
	return (temp);
}

// Returns true if trees
// with roots as root1 and root2 are mirror
bool isMirror(struct TreeNode* root1, struct TreeNode* root2)
{
	// If both trees are empty,
	// then they are mirror images
	if (root1 == NULL && root2 == NULL)
		return true;

	// For two trees to be mirror
	// images, the following
	// three conditions must be true
	// 1 - Their root node's
	// key must be same 2 - left
	// subtree of left tree and right subtree
	// of right tree have to be mirror images
	// 3 - right subtree of left tree and left subtree
	// of right tree have to be mirror images
	if (root1 && root2 && root1->key == root2->key)
		return isMirror(root1->left, root2->right)
			&& isMirror(root1->right, root2->left);

	// if none of above conditions is true then root1
	// and root2 are not mirror images
	return false;
}

// Returns true if a tree is
// symmetric i.e. mirror image of itself
bool isSymmetric(struct TreeNode* root)
{
	// Check if tree is mirror of itself
	return isMirror(root, root);
}

// Driver code
int main()
{
	// Let us construct the Tree shown in the above figure
	TreeNode* root = newTreeNode(1);
	root->left = newTreeNode(2);
	root->right = newTreeNode(2);
	root->left->left = newTreeNode(3);
	root->left->right = newTreeNode(4);
	root->right->left = newTreeNode(4);
	root->right->right = newTreeNode(3);

	if(isSymmetric(root))
	cout<<"Symmetric";
	else
	cout<<"Not symmetric";
	return 0;
}

$0
endsnippet
# 7.4 
snippet btLevelOrderTraversal "printCurrentLevel(tree, level) = Level order traversal of a tree" b
// Recursive CPP program for level
// order traversal of Binary Tree
#include <bits/stdc++.h>
using namespace std;

/* A binary tree node has data,
pointer to left child
and a pointer to right child */
class node {
public:
	int data;
	node *left, *right;
};

/* Function prototypes */
void printCurrentLevel(node* root, int level);
int height(node* node);
node* newTreeNode(int data);

/* Function to print level
order traversal a tree*/
void printLevelOrder(node* root)
{
	int h = height(root);
	int i;
	for (i = 1; i <= h; i++)
		printCurrentLevel(root, i);
}

/* Print nodes at a current level */
void printCurrentLevel(node* root, int level)
{
	if (root == NULL)
		return;
	if (level == 1)
		cout << root->data << " ";
	else if (level > 1) {
		printCurrentLevel(root->left, level - 1);
		printCurrentLevel(root->right, level - 1);
	}
}

/* Compute the "height" of a tree -- the number of
	nodes along the longest path from the root node
	down to the farthest leaf node.*/
int height(node* node)
{
	if (node == NULL)
		return 0;
	else {
		/* compute the height of each subtree */
		int lheight = height(node->left);
		int rheight = height(node->right);

		/* use the larger one */
		if (lheight > rheight) {
			return (lheight + 1);
		}
		else {
			return (rheight + 1);
		}
	}
}

/* Helper function that allocates
a new node with the given data and
NULL left and right pointers. */
node* newTreeNode(int data)
{
	node* TreeNode = new node();
	TreeNode->data = data;
	TreeNode->left = NULL;
	TreeNode->right = NULL;

	return (TreeNode);
}

/* Driver code*/
int main()
{
	node* root = newTreeNode(1);
	root->left = newTreeNode(2);
	root->right = newTreeNode(3);
	root->left->left = newTreeNode(4);
	root->left->right = newTreeNode(5);

	cout << "Level Order traversal of binary tree is \n";
	printLevelOrder(root);

	return 0;
}

// This code is contributed by rathbhupendra

$0
endsnippet
snippet btLevelOrderTraversal "Using queue = Level order traversal of a tree" b
/* C++ program to print level
	order traversal using STL */
#include <bits/stdc++.h>
using namespace std;

// A Binary Tree TreeNode
struct TreeNode {
	int data;
	struct TreeNode *left, *right;
};

// Iterative method to find height of Binary Tree
void printLevelOrder(TreeNode* root)
{
	// Base Case
	if (root == NULL)
		return;

	// Create an empty queue for level order traversal
	queue<TreeNode*> q;

	// Enqueue Root and initialize height
	q.push(root);

	while (q.empty() == false) {
		// Print front of queue and remove it from queue
		TreeNode* node = q.front();
		cout << node->data << " ";
		q.pop();

		/* Enqueue left child */
		if (node->left != NULL)
			q.push(node->left);

		/*Enqueue right child */
		if (node->right != NULL)
			q.push(node->right);
	}
}

// Utility function to create a new tree node
TreeNode* newTreeNode(int data)
{
	TreeNode* temp = new TreeNode;
	temp->data = data;
	temp->left = temp->right = NULL;
	return temp;
}

// Driver program to test above functions
int main()
{
	// Let us create binary tree shown in above diagram
	TreeNode* root = newTreeNode(1);
	root->left = newTreeNode(2);
	root->right = newTreeNode(3);
	root->left->left = newTreeNode(4);
	root->left->right = newTreeNode(5);

	cout << "Level Order traversal of binary tree is \n";
	printLevelOrder(root);
	return 0;
}

$0
endsnippet
# 7.5 
snippet btSortArray2BalaneceBinaryTree "Given a sorted array convert  Balanced Binary Search Tree." b
// C++ program to print BST in given range
#include<bits/stdc++.h>
using namespace std;

/* A Binary Tree node */
class TTreeNode
{
	public:
	int data;
	TTreeNode* left;
	TTreeNode* right;
};

TTreeNode* newTreeNode(int data);

/* A function that constructs Balanced Binary Search Tree from a sorted array */
TTreeNode* sortedArrayToBST(int arr[],
						int start, int end)
{
	/* Base Case */
	if (start > end)
	return NULL;

	/* Get the middle element and make it root */
	int mid = (start + end)/2;
	TTreeNode *root = newTreeNode(arr[mid]);

	/* Recursively construct the left subtree and make it left child of root */
	root->left = sortedArrayToBST(arr, start,
									mid - 1);

	/* Recursively construct the right subtree and make it right child of root */
	root->right = sortedArrayToBST(arr, mid + 1, end);

	return root;
}

/* Helper function that allocates a new node
with the given data and NULL left and right
pointers. */
TTreeNode* newTreeNode(int data)
{
	TTreeNode* node = new TTreeNode();
	node->data = data;
	node->left = NULL;
	node->right = NULL;

	return node;
}

/* A utility function to print
preorder traversal of BST */
void preOrder(TTreeNode* node)
{
	if (node == NULL)
		return;
	cout << node->data << " ";
	preOrder(node->left);
	preOrder(node->right);
}

// Driver Code
int main()
{
	int arr[] = {1, 2, 3, 4, 5, 6, 7};
	int n = sizeof(arr) / sizeof(arr[0]);

	/* Convert List to BST */
	TTreeNode *root = sortedArrayToBST(arr, 0, n-1);
	cout << "PreOrder Traversal of constructed BST \n";
	preOrder(root);

	return 0;
}

// This code is contributed by rathbhupendra

$0
endsnippet
# 8 design
# 8.1
# 8.2
# 8.3
# 8.4
# 9  dp
# 9.1

snippet sumWayClimbStairs "dp = many distinct ways can you climb to the top?  " b
// C++ program to count number of
// ways to reach Nth stair
#include <bits/stdc++.h>
using namespace std;

// A simple recursive program to
// find N'th fibonacci number
int fib(int n, int dp[])
{
	if (n <= 1)
		return dp[n] = 1;

	if(dp[n] != -1 ){
		return dp[n] ;
	}
	dp[n] = fib(n - 1, dp) + fib(n - 2, dp);
	return dp[n] ;
}

// Returns number of ways to
// reach s'th stair
int countWays(int n)
{
	int dp[n+1] ;
	memset(dp, -1, sizeof dp) ;
	fib(n, dp) ;
	return dp[n] ;
}

// Driver C
int main()
{
	int n = 4;

	cout << "Number of ways = " << countWays(n);

	return 0;
}

$0
endsnippet
# 9.2
snippet maxProfitStock "dp = find the maximum profit possible for buying and selling the stock" b
// C++ program for the above approach

#include <bits/stdc++.h>
#include <iostream>
using namespace std;

// Function to find the maximum
// profit in the buy and sell stock
int find(vector<int>& prices, int ind, bool buy, int c,
		vector<vector<vector<int> > >& memo)
{
	// If buy =1 means buy now
	// else sell
	if (ind >= prices.size() || c >= 2)
		return 0;
	if (memo[ind][buy] != -1)
		return memo[ind][buy];

	// Already bought, sell now
	if (buy) {
		return memo[ind][buy]
			= max(-prices[ind]
						+ find(prices, ind + 1, !buy, c,
								memo),
					find(prices, ind + 1, buy, c, memo));
	}

	// Can buy stocks
	else {
		return memo[ind][buy]
			= max(prices[ind]
						+ find(prices, ind + 1, !buy,
								c + 1, memo),
					find(prices, ind + 1, buy, c, memo));
	}
}

// Function to find the maximum
// profit in the buy and sell stock
int maxProfit(vector<int>& prices)
{
	// Here maximum two transaction are allowed

	// Use 3-D vector because here
	// three states are there: i,k,buy/sell
	vector<vector<vector<int> > > memo(
		prices.size(),
		vector<vector<int> >(2, vector<int>(2, -1)));

	// Answer
	return find(prices, 0, 1, 0, memo);
}

// Driver Code
int main()
{

	// Given prices
	vector<int> prices = { 3, 3, 5, 0, 0, 3, 1, 4 };

	// Function Call
	int ans = maxProfit(prices);

	// Answer
	cout << ans << endl;
	return 0;
}


$0
endsnippet
# 9.3
snippet maxSumSubarray "dp = Maximum Subarray Sum" b
// A Divide and Conquer based program for maximum subarray
// sum problem
#include <limits.h>
#include <stdio.h>

// A utility function to find maximum of two integers
int max(int a, int b) { return (a > b) ? a : b; }

// A utility function to find maximum of three integers
int max(int a, int b, int c) { return max(max(a, b), c); }

// Find the maximum possible sum in arr[] auch that arr[m]
// is part of it
int maxCrossingSum(int arr[], int l, int m, int h)
{
	// Include elements on left of mid.
	int sum = 0;
	int left_sum = INT_MIN;
	for (int i = m; i >= l; i--) {
		sum = sum + arr[i];
		if (sum > left_sum)
			left_sum = sum;
	}

	// Include elements on right of mid
	sum = 0;
	int right_sum = INT_MIN;
	for (int i = m + 1; i <= h; i++) {
		sum = sum + arr[i];
		if (sum > right_sum)
			right_sum = sum;
	}

	// Return sum of elements on left and right of mid
	// returning only left_sum + right_sum will fail for
	// [-2, 1]
	return max(left_sum + right_sum, left_sum, right_sum);
}

// Returns sum of maximum sum subarray in aa[l..h]
int maxSubArraySum(int arr[], int l, int h)
{
	// Base Case: Only one element
	if (l == h)
		return arr[l];

	// Find middle point
	int m = (l + h) / 2;

	/* Return maximum of following three possible cases
			a) Maximum subarray sum in left half
			b) Maximum subarray sum in right half
			c) Maximum subarray sum such that the subarray
	crosses the midpoint */
	return max(maxSubArraySum(arr, l, m),
			maxSubArraySum(arr, m + 1, h),
			maxCrossingSum(arr, l, m, h));
}

/*Driver program to test maxSubArraySum*/
int main()
{
	int arr[] = { 2, 3, 4, 5, 7 };
	int n = sizeof(arr) / sizeof(arr[0]);
	int max_sum = maxSubArraySum(arr, 0, n - 1);
	printf("Maximum contiguous sum is %d\n", max_sum);
	getchar();
	return 0;
}

$0
endsnippet
snippet minSumSubarray "contiguous subarray having the smallest(minimum) sum" b
// C++ implementation to find the smallest sum
// contiguous subarray
#include <bits/stdc++.h>

using namespace std;

// function to find the smallest sum contiguous subarray
int smallestSumSubarr(int arr[], int n)
{
	// to store the minimum value that is ending
	// up to the current index
	int min_ending_here = INT_MAX;

	// to store the minimum value encountered so far
	int min_so_far = INT_MAX;

	// traverse the array elements
	for (int i=0; i<n; i++)
	{
		// if min_ending_here > 0, then it could not possibly
		// contribute to the minimum sum further
		if (min_ending_here > 0)
			min_ending_here = arr[i];

		// else add the value arr[i] to min_ending_here
		else
			min_ending_here += arr[i];

		// update min_so_far
		min_so_far = min(min_so_far, min_ending_here);
	}

	// required smallest sum contiguous subarray value
	return min_so_far;
}


// Driver program to test above
int main()
{
	int arr[] = {3, -4, 2, -3, -1, 7, -5};
	int n = sizeof(arr) / sizeof(arr[0]);
	cout << "Smallest sum: "
		<< smallestSumSubarr(arr, n);
	return 0;
}

$0
endsnippet
# 9.4

# 10 math
# 11 other
# 001
snippet twoSum "(vector<int>)index=find two sum target(vector<int> &numbers, int target) "
/* code by 王江 DC-Melo */
vector<int> findTwoSum(vector<int> &numbers, int target) {
    unordered_map<int, int> hash;
    vector<int> result;
    for (int i = 0; i < numbers.size(); i++) {
        int findNum = target - numbers[i];
        if (hash.find(findNum) != hash.end()) {
            result.push_back(hash[findNum]);
            result.push_back(i);
            return result;
        }
        hash[numbers[i]] = i;
    }
    return result;
}
$0
endsnippet

# 002
snippet addTwoListNode "(ListNode *)sum=add two list node(ListNode *l1,ListNode *l2) "
/* code by 王江 DC-Melo */
ListNode *addTwoListNode(ListNode *l1,ListNode *l2){ 
    ListNode *result = new ListNode(0); 
    ListNode *pi = result; 
    int carry=0; 
    while(l1 != NULL || l2 != NULL){ 
        int val1 = (l1 != NULL) ? l1->val : 0;
        int val2 = (l2 != NULL) ? l1->val : 0;
        pi->next = new ListNode((val1+val2+carry)%10); 
        carry = (val1+val2+carry)/10; 
        pi = pi->next; 
        if (l1 != NULL) l1 = l1->next; 
        if (l2 != NULL) l2 = l2->next; 
    } 
    if (carry != 0) { 
        pi->next = new ListNode(carry); 
    } 
    return result->next; 
} 
$0
endsnippet

# 003
snippet longestUniqueSubstr "(int)maxlen=Longest Substring Without Repeating Characters(string s)"
/* code by 王江 DC-Melo */
int longestUniqueSubsttr(string str) {
	int n = str.size();
	int len = 0; // result
	// last index of all characters is initialized
	// as -1
	vector<int> lastIndex(255, -1);
	// Initialize start of current window
	int i = 0;
	// Move end of current window
	for (int j = 0; j < n; j++) {
		// Find the last index of str[j]
		// Update i (starting index of current window)
		// as maximum of current value of i and last
		// index plus 1
		i = max(i, lastIndex[str[j]] + 1);
		// Update result if we get a larger window
		len = max(len, j - i + 1);
		// Update last index of j.
		lastIndex[str[j]] = j;
	}
	return len;
}
$0
endsnippet

# 004
snippet midSortedArrays "(double)mid=find median sorted vector(vector<int>& nums1, vector<int>& nums2)"
/* code by 王江 DC-Melo */
double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
	vector<int> res;
	int medianPos = 0;
	int p1,p2;
	for(p1=0,p2=0;p1<nums1.size() && p2<nums2.size();) {
		if(nums1[p1] < nums2[p2]) {
			res.push_back(nums1[p1]);
			p1++;
		} else {
			res.push_back(nums2[p2]);
			p2++;
		}
	}
	for(;p1 < nums1.size();p1++) res.push_back(nums1[p1]);
	for(;p2 < nums2.size();p2++) res.push_back(nums2[p2]);
	medianPos = (nums1.size() + nums2.size())/2;
	if((nums1.size()+nums2.size())%2 == 0) return (res[medianPos - 1] + res[medianPos]) / 2.0;
	return res[medianPos];
}
$0
endsnippet

# 005
snippet longestPalindrome "(int)centerSpread=find longest palindrome (string s)" b
/* code by 王江 DC-Melo */
string longestPalindrome(string s) {
    int len = s.size();
    if(len < 1 ) return s;
    string ansLen;
    for(int i=0;i<len;i++){
        int len1 = centerSpread(s,i,i);     // odd
        int len2 = centerSpread(s,i,i+1);   // even number
        if(len1>len2){
            ansLen = ansLen.size() > len1 ? ansLen: s.substr(i-len1/2,len1);
        }else{
            ansLen = ansLen.size() > len2 ? ansLen: s.substr(i-len2/2+1,len2);
        }
    }
    return ansLen;
}
int centerSpread(string s,int left, int right){
    int l=left,r=right;
    while( l>=0 && r<=s.size() && s[l]==s[r] ){
        l--;
        r++;
    }
    return r-l-1;
}
$0
endsnippet

# 005
snippet longestPalindrome "(int)maxlen=find longest palindrome(string s)" b
/* code by 王江 DC-Melo */
// This function prints the
// longest palindrome substring
// It also returns the length of
// the longest palindrome
int longestPalSubstr(string str) {
    // get length of input string
    int n = str.size();
    // table[i][j] will be false if substring
    // str[i..j] is not palindrome.
    // Else table[i][j] will be true
    bool table[n][n];
    memset(table, 0, sizeof(table));
    // All substrings of length 1
    // are palindromes
    int maxLength = 1;
    for (int i = 0; i < n; ++i) table[i][i] = true;
    // check for sub-string of length 2.
    int start = 0;
    for (int i = 0; i < n - 1; ++i) {
        if (str[i] == str[i + 1]) {
            table[i][i + 1] = true;
            start = i;
            maxLength = 2;
        }
    }
    // Check for lengths greater than 2.
    // k is length of substring
    for (int k = 3; k <= n; ++k) {
        // Fix the starting index
        for (int i = 0; i < n - k + 1; ++i) {
            // Get the ending index of substring from
            // starting index i and length k
            int j = i + k - 1;

            // checking for sub-string from ith index to
            // jth index iff str[i+1] to str[j-1] is a
            // palindrome
            if (table[i + 1][j - 1] && str[i] == str[j]) {
                table[i][j] = true;
                if (k > maxLength) {
                    start = i;
                    maxLength = k;
                }
            }
        }
    }
    // return length of LPS
    return maxLength;
}
$0
endsnippet


snippet longestPalindromeSubstringDynamicPlanON2 "(string)DP=find longest palindrome(string s)" b
string longestPalindrome(string s) {
    string ans=s.substr(0,1);
    int len = s.size();
    if(len == 0) return s;
    bool dp[len][len];
    for(int i=0;i<len;i++){
        dp[i][i]=true;
    }
    for(int j=1;j<len;j++){
        for(int i=0;i<j;i++){
            if(s[i]!=s[j])
                dp[i][j] = false;
            else{
                if(j-i<3){
                    dp[i][j] = 1;
                }else{
                    dp[i][j] = dp[i+1][j-1];
                }
            }
            if(dp[i][j] && j-i+1 > ans.size())
                ans = s.substr(i, j-i+1);
        }
    }
    return ans;
}
$0
endsnippet

snippet longestPalindromeSubstringManacher "(string)subStr=find longest palindrome(string s)" b
string longestPalindrome(string s) {
    string manaStr = "$#";
    for (int i=0;i<s.size();i++){
		manaStr += s[i];
		manaStr += '#';
    }
	vector<int> rd(manaStr.size(), 0);
	int pos = 0, mx = 0;
	int start = 0, maxLen = 0;
	for (int i = 1; i < manaStr.size(); i++) {
		rd[i] = i < mx ? min(rd[2 * pos - i], mx - i) : 1;
		while (i+rd[i]<manaStr.size() && i-rd[i]>0 && manaStr[i + rd[i]] == manaStr[i - rd[i]]) rd[i]++;
		if (i + rd[i] > mx){
			pos = i;
			mx = i + rd[i];
		} 
		if (rd[i] - 1 > maxLen)     {
			start = (i - rd[i]) / 2;
			maxLen = rd[i] - 1;
		}
	}
    return s.substr(start, maxLen);
}
$0
endsnippet
# 005

# 006
snippet printZwords  "(string)zStr=convert z words accound lines(string s,int nRows) " b
/* code by 王江 DC-Melo */
    string ${1:funciton}(string s, int nRows) 
    {
        int strLength = s.length();
        int flag = 0;
        string result(strLength,'*');
        if(nRows == 1) return result;
        for(int  i = 0;i < strLength ; i += 2*nRows-2) {
            result[flag] = s[i];
            flag++;
        }
        for (int i = 1; i < nRows -1  ; i ++ ) {
            int flagM = flag;
            int flagN = flag+1;
            for(int m = i; m < strLength; m += 2*nRows-2) {
                result[flagM] = s[m];
                flagM+=2;
                flag++;
            }
            for(int n = i + 2*(nRows - i - 1);n < strLength;n += 2*nRows-2) {
                result[flagN] = s[n];
                flagN+=2;
                flag++;
            }
        }
        for(int  i = nRows - 1;i < strLength ; i += 2*nRows-2) {
            result[flag] = s[i];
            flag++;
        }
        return result;
    }
$0
endsnippet

# 007
snippet reverseInteger "(int)val=reverse integer(int x)" b
/* code by 王江 DC-Melo */
int ${1:function}(int x) {
	int flag = x > 0? 1:-1;
	x = abs(x);
	long int result = 0;
	int digit = 0;
	while(x) {
		digit = x % 10;
		result = result * 10 + digit;
		x /= 10;
	}
	result *= flag;
	if(result > 2147483647 || result < -2147483648) return 0;
	return (int)result; 
}
$0
endsnippet

# 008
snippet string2Int "(int)val=convert String to Int(string str)" b
/* code by 王江 DC-Melo */
int ${1:fuction}(string str) {
	int tempResult,result=0;
	int sign = 1;
	int i=0;
	while(i<str.size() && str[i]==' ') i++;
	if (str[i] == '-' || str[i] == '+') sign = str[i++]=='-'? -1 : 1; 
	for(;i<str.size();i++) {
		if(str[i]>='0' && str[i]<='9')
		{
			tempResult = result*10 + str[i]-'0';
			if(tempResult/10 != result)
				return  sign>0 ? INT_MAX:INT_MIN;
			result = tempResult;
		}
		else
			break;
	}
	return result * sign;
}
$0
endsnippet

# 009
snippet isPalindrome "(bool)is=is palindrome(int x)" b
/* code by 王江 DC-Melo */
bool ${1:function}(int x) {
        if( x<0 || (x!=0 &&x%10==0)) return false;
        int rev=0;
        while(x>rev) {
            rev = rev*10+x%10;
            x = x/10;
        }
        return (x==rev)||(x==rev/10);
    }
$0
endsnippet

# 010
snippet isMatchString "(bool)is=is match regex string(string s, string p)" b
/* code by 王江 DC-Melo */
    bool ${1:function}(string s, string p) {
        return ${2:recursionFunction}(s,p,0,0);
    }
    bool $2(string &s,string &p,int i,int j)
    {
        if(j == p.size()) return i == s.size();
        if(p[j+1] == '*') {
            if((s[i] == p[j] || p[j] == '.') && i<s.size()) return match(s,p,i,j+2) || match(s,p,i+1,j);
            return match(s,p,i,j+2);
        }
        if(s[i] == p[j] || p[j] == '.') return match(s,p,i+1,j+1);
        return false;
    }
$0
endsnippet

# 011
snippet maxWaterAreaON2 "(int)store=find Maximum water that can be stored between two buildings(int height[], int n)" b
/* code by 王江 DC-Melo */
// Return the maximum water that can be stored
int maxWater(int height[], int n) {
    int maximum = 0;
    // Check all possible pairs of buildings
    for (int i = 0; i < n - 1; i++) {
        for (int j = i + 1; j < n; j++) {
            int current = (min(height[i], height[j]) * (j - i - 1));
            // Maximum so far
            maximum = max(maximum, current);
        }
    }
    return maximum;
}
$0
endsnippet

# 011
snippet maxWaterAreaONLN "(int)store=find Maximum water that can be stored between two buildings(int height[], int n)" b
/* code by 王江 DC-Melo */
bool compareTo(pair<int, int> p1, pair<int, int> p2) {
    return p1.second < p2.second;
}
// Return the maximum water that
// can be stored
int maxWater(int height[], int n) {
    // Make pairs with indices
    pair<int, int> pairs[n];
    for(int i = 0; i < n; i++) pairs[i] = make_pair(i, height[i]);
    // Sort array based on heights
    sort(pairs, pairs + n, compareTo);       
    // To store the min and max index so far
    // from the right
    int minIndSoFar = pairs[n - 1].first;
    int maxIndSoFar = pairs[n - 1].first;
    int maxi = 0;
    for(int i = n - 2; i >= 0; i--) {
        // Current building paired with
        // the building greater in height
        // and on the extreme left
        int left = 0;
        if (minIndSoFar < pairs[i].first) {
            left = (pairs[i].second * (pairs[i].first - minIndSoFar - 1));
        }
        // Current building paired with
        // the building greater in height
        // and on the extreme right
        int right = 0;
        if (maxIndSoFar > pairs[i].first) {
            right = (pairs[i].second * (maxIndSoFar - pairs[i].first - 1));
        }
        // Maximum so far
        maxi = max(left, max(right, maxi));
        // Update the maximum and minimum so far
        minIndSoFar = min(minIndSoFar, pairs[i].first);
        maxIndSoFar = max(maxIndSoFar, pairs[i].first);
    }
    return maxi;
}
$0
endsnippet

# 011
snippet maxWaterArea "(int)store=find Maximum water that can be stored between two buildings(vector<int> &height)" b
/* code by 王江 DC-Melo */
    int ${1:function}(vector<int> &height) 
    {
        int left = 0;
        int right = height.size() -1;
        int maxArea = 0;
        while(left < right) {
            int area = (right - left)*min(height[left],height[right]);
            maxArea = max(maxArea,area);
            if(height[left] < height[right]) left++;
            else right--;
        }
        return maxArea;
    }
$0
endsnippet

# 012
snippet int2Roman "(string)roman=convert Int to Roman(int num)" b
/* code by 王江 DC-Melo */
    string ${1:function1}(int num) {
        char symbol[9] = {'I','V','X','L','C','D','M'};
        string roman="";
        int scale = 1000;
        int p=6;
        while(num) {
            int bit = num/scale;
            $2(roman, bit, symbol+p);
            num = num%scale;
            scale /= 10;
            p -= 2;
        }
        return roman;
    }
    void ${2:function2}(string& roman, int num, char* symbol) {
        if(num == 0) return;
        else if(num <= 3) roman.append(num, *symbol);
        else if(num == 4) {
            roman.append(1,*symbol);
            roman.append(1,*(symbol+1));
        }
        else if(num <= 8) {
            roman.append(1,*(symbol+1));
            roman.append(num-5,*symbol);
        }
        else if(num == 9) {
            roman.append(1,*symbol);
            roman.append(1,*(symbol+2));
        }
    }
    
$0
endsnippet

# 013
snippet roman2Int "(int)ival=convert Roman to Int(string s)" b
/* code by 王江 DC-Melo */
int ${1:function}(string s) {
	int map[26];
	map['I'-'A'] = 1;
	map['V'-'A'] = 5;
	map['X'-'A'] = 10;
	map['L'-'A'] = 50; 
	map['C'-'A'] = 100;
	map['D'-'A'] = 500;
	map['M'-'A'] = 1000;
	int result = 0, n = s.size();
	s.push_back(s[n-1]);
	for(int i = 0; i < n; i++) {
		if(map[s[i]-'A'] >= map[s[i+1]-'A']) result += map[s[i]-'A'];
		else result -= map[s[i]-'A'];
	}
	return result;
}
$0
endsnippet

# 014
snippet commonPrefix "(string)prefix=find common prefix(vector<string> &strs)" b
/* code by 王江 DC-Melo */
string ${1:function}(vector<string> &strs) {
    if( strs.size() == 0) return "";
    string prefix = strs[0];
    for(int i = 0;i<strs.size();i++) {
        if(prefix.size() == 0 || strs[i].size() == 0) return "";
        int j = 0;
        while(prefix[j] == strs[i][j])  j++; 
        prefix = prefix.substr(0,j);
    }
    return prefix;
}
$0
endsnippet

# 015
snippet threeSumON2O1 "(int)val=find three sum(vector<int>& arr, int x)" b
/* code by 王江 DC-Melo */
// Function to return the sum of a
// triplet which is closest to x
int solution(vector<int>& arr, int x) {
    // Sort the array
    sort(arr.begin(), arr.end());
    // To store the closest sum
	//not using INT_MAX to avoid overflowing condition
    int closestSum = 1000000000;
    // Fix the smallest number among
    // the three integers
    for (int i = 0; i < arr.size() - 2; i++) {
        // Two pointers initially pointing at
        // the last and the element
        // next to the fixed element
        int ptr1 = i + 1, ptr2 = arr.size() - 1;
        // While there could be more pairs to check
        while (ptr1 < ptr2) {
            // Calculate the sum of the current triplet
            int sum = arr[i] + arr[ptr1] + arr[ptr2];
			// if sum is equal to x, return sum as
		    if (sum == x) return sum;
            // If the sum is more closer than
            // the current closest sum
            if (abs(x - sum) < abs(x - closestSum)) {
                closestSum = sum;
            }
            // If sum is greater then x then decrement
            // the second pointer to get a smaller sum
            if (sum > x) { ptr2--; }
            // Else increment the first pointer
            // to get a larger sum
            else { ptr1++; }
        }
    }
    // Return the closest sum found
    return closestSum;
}
$0
endsnippet

# 015
snippet threeSum "(vector<vector<int>>)index=find three sum(vector<int> &num)" b
/* code by 王江 DC-Melo */
vector<vector<int> > ${1:function}(vector<int> &num) {
	vector<vector<int> > result;
	if(num.size() == 0) return result;
	sort(num.begin(),num.end());
	for( int pos1 = 0;pos1<num.size();pos1++) {
		for(int pos2 = pos1 + 1, pos3 = num.size() - 1; pos2 < pos3;) {
			int sum = num[pos1] + num[pos2] + num[pos3];
			if(sum == 0) {
				vector<int> tempResult;
				tempResult.push_back(num[pos1]);
				tempResult.push_back(num[pos2]);
				tempResult.push_back(num[pos3]);
				result.push_back(tempResult);
				while( pos2+1 < pos3 && num[pos2+1] == num[pos2]) pos2++;
				pos2++;
				while( pos3-1 > pos2 && num[pos3-1] == num[pos3]) pos3--;
				pos3--;
			}
			else if(sum < 0) pos2++;
			else pos3--;
		}
		while( pos1+1 < num.size() && num[pos1+1] == num[pos1]) pos1++;
	}
	return result;
}
$0
endsnippet

# 016
snippet threeSumClosest "(int)val=find three sum(vector<int> &num, int target)" b
/* code by 王江 DC-Melo */
    int findThreeSumClosest(vector<int> &num, int target) {
        int closestSum = num[0]+num[1]+num[2];
        sort(num.begin(),num.end());
        for( int num1pos = 0; num1pos<num.size(); num1pos++ ) {
            for(int num2pos=num1pos+1, num3pos=num.size()-1; num2pos < num3pos;) {
                int sum = num[num1pos] + num[num2pos] + num[num3pos];
                if(sum == target) return target;
                if(abs(sum-target)<abs(closestSum-target)) closestSum = sum;
                if(sum < target) num2pos++;
                else num3pos--;
            }
        }
        return closestSum;
    }
};
$0
endsnippet


# 003
snippet longestSubstringWithoutRepeatingCharacters "(int)maxlen=Longest Substring Without Repeating Characters(string s)" b
/* code by 王江 DC-Melo */
int lengthOfLongestSubstring(string s) {
	int left=0, right=0;
	int maxLength=0, length=0;
	vector<bool> flag(255,false);
	for(;right<s.size();right++) {
		if(flag[s[right]] == true) {
			for(;s[left] != s[right];left++) {
				flag[s[left]] = false;
				length --;
			}
			left++;
		} else {
			flag[s[right]] = true;
			length++;
			if(length > maxLength) maxLength = length;
		}
	}
	return maxLength;
}
$0
endsnippet

# 004
snippet midTwoSortedArrays "(double)val=Median of Two Sorted Arrays(vector<int>& nums1, vector<int>& nums2)" b
/* code by 王江 DC-Melo */
double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
	vector<int> res;
	int medianPos = 0;
	int p1,p2;
	for(p1=0,p2=0;p1<nums1.size() && p2<nums2.size();) {
		if(nums1[p1] < nums2[p2]) {
			res.push_back(nums1[p1]);
			p1++;
		} else {
			res.push_back(nums2[p2]);
			p2++;
		}
	}
	for(;p1 < nums1.size();p1++) res.push_back(nums1[p1]);
	for(;p2 < nums2.size();p2++) res.push_back(nums2[p2]);
	medianPos = (nums1.size() + nums2.size())/2;
	if((nums1.size()+nums2.size())%2 == 0) return (res[medianPos - 1] + res[medianPos]) / 2.0;
	return res[medianPos];
}
$0
endsnippet

# 005
snippet longestPalindromicSubstring "(string)subStr=Longest Palindromic Substring(string s)" b
/* code by 王江 DC-Melo */
string longestPalindrome(string s) {
	int position, maxLength=0, length=0;
	for(int i=0;i<s.size();i++) {
		length = 1;
		for(int j=1;i+j<s.size()&&i-j>=0;j++) {
			if(s[i-j] == s[i+j]) length += 2;
			else break;
		}
		if(length > maxLength) {
			maxLength = length;
			position = i-length/2;
		}
	}
	for(int i=0;i+1<s.size();i++) {
		length = 0;
		for(int j=0;i+1+j<s.size()&&i-j>=0;j++) {
			if(s[i-j] == s[i+1+j]) length += 2;
			else break;
		} if(length > maxLength) {
			maxLength = length;
			position = i-length/2+1;
		}
	}
	return s.substr(position,maxLength);
}
$0
endsnippet

# 006
snippet printZigZagConversion "(string)str=ZigZag-Conversion(string s, int nRows)" b
/* code by 王江 DC-Melo */
string convert(string s, int nRows) {
	int strLength = s.length();
	int flag = 0;
	/* string result(s); */
	string result(strLength,'*');
	if(nRows == 1) return result;
	for(int  i = 0;i < strLength ; i += 2*nRows-2) {
		result[flag] = s[i];
		flag++;
	}
	for (int i = 1; i < nRows -1  ; i ++ ) {
		int flagM = flag;
		int flagN = flag+1;
		for(int m = i; m < strLength; m += 2*nRows-2) {
			result[flagM] = s[m];
			flagM+=2;
			flag++;
		}
		for(int n = i + 2*(nRows - i - 1);n < strLength;n += 2*nRows-2) {
			result[flagN] = s[n];
			flagN+=2;
			flag++;
		}
	}
	for(int  i = nRows - 1;i < strLength ; i += 2*nRows-2) {
		result[flag] = s[i];
		flag++;
	}
	return result;
}
$0
endsnippet

# 007
snippet reverseInteger2 "(int)val=reverse Integer(int x)" b
/* code by 王江 DC-Melo */
int reverse(int x) {
	int flag = x > 0? 1:-1;
	x = abs(x);
	long int result = 0;
	int digit = 0;
	while(x) {
		digit = x % 10;
		result = result * 10 + digit;
		x /= 10;
	}
	result *= flag;
	if(result > 2147483647 || result < -2147483648) return 0;
	return (int)result; 
}
$0
endsnippet

# 008
snippet string2IntegerAtoi "(int)String to Integer atoi(string str)" b
/* code by 王江 DC-Melo */
#include <limits.h>
int myAtoi(string str) {
	int tempResult,result=0;
	int sign = 1;
	int i=0;
	while(i<str.size() && str[i]==' ') i++;
	if (str[i] == '-' || str[i] == '+') sign = str[i++]=='-'? -1 : 1; 
	for(;i<str.size();i++) {
		if(str[i]>='0' && str[i]<='9') {
			tempResult = result*10 + str[i]-'0';
			if(tempResult/10 != result) return  sign>0 ? INT_MAX:INT_MIN;
			result = tempResult;
		} else break;
	}
	return result * sign;
}
$0
endsnippet

# 009
snippet isPalindromeNumber "(bool)is=Palindrome Number(int x)" b
/* code by 王江 DC-Melo */
bool isPalindrome(int x) {
	if(x<0|| (x!=0 &&x%10==0)) return false;
	int rev=0;
	while(x>rev) {
		rev = rev*10+x%10;
		x = x/10;
	}
	return (x==rev)||(x==rev/10);
}
$0
endsnippet

# 010
snippet isMatchRegularExpressionMatching "(bool)is=Regular-Expression-Matching(string &s,string &p,int i,int j)" b
/* code by 王江 DC-Melo */
bool match(string &s,string &p,int i,int j) {
	if(j == p.size()) return i == s.size();
	if(p[j+1] == '*') {
		if((s[i] == p[j] || p[j] == '.') && i<s.size()) return match(s,p,i,j+2) || match(s,p,i+1,j);
		return match(s,p,i,j+2);
	}
	if(s[i] == p[j] || p[j] == '.') return match(s,p,i+1,j+1);
	return false;
}
bool isMatch(string s, string p) 
{
	return match(s,p,0,0);
}
$0
endsnippet

# 011
snippet maxWaterContainer "(int)area=Container With Most Water (vector<int> &height)" b
/* code by 王江 DC-Melo */
int maxArea(vector<int> &height) {
	int left = 0;
	int right = height.size() -1;
	int maxArea = 0;
	while(left < right) {
		int area = (right - left)*min(height[left],height[right]);
		maxArea = max(maxArea,area);
		if(height[left] < height[right]) left++;
		else right--;
	}
	return maxArea;
}
$0
endsnippet

# 012
snippet int2Roman "(string)str=Integer to Roman(int num)" b
/* code by 王江 DC-Melo */
void romanstr(string& roman, int num, char* symbol) {
	if(num == 0)return;
	else if(num <= 3) roman.append(num, *symbol);
	else if(num == 4) {
		roman.append(1,*symbol);
		roman.append(1,*(symbol+1));
	} else if(num <= 8) {
		roman.append(1,*(symbol+1));
		roman.append(num-5,*symbol);
	} else if(num == 9) {
		roman.append(1,*symbol);
		roman.append(1,*(symbol+2));
	}
}
string intToRoman(int num) {
	char symbol[9] = {'I','V','X','L','C','D','M'};
	string roman="";
	int scale = 1000;
	int p=6;
	while(num) {
		int bit = num/scale;
		romanstr(roman, bit, symbol+p);
		num = num%scale;
		scale /= 10;
		p -= 2;
	}
	return roman;
}
$0
endsnippet

# 013
snippet roman2Integer "(int)ival=Roman-to-Integer(string s)" b
/* code by 王江 DC-Melo */
int romanToInt(string s) {
	int map[26];
	map['I'-'A'] = 1;
	map['V'-'A'] = 5;
	map['X'-'A'] = 10;
	map['L'-'A'] = 50; 
	map['C'-'A'] = 100;
	map['D'-'A'] = 500;
	map['M'-'A'] = 1000;
	int result = 0, n = s.size();
	s.push_back(s[n-1]);
	for(int i = 0; i < n; i++) {
		if(map[s[i]-'A'] >= map[s[i+1]-'A']) result += map[s[i]-'A'];
		else result -= map[s[i]-'A'];
	}
	return result;
}
$0
endsnippet

# 014
snippet longestCommonPrefix "(string)str=Longest Common Prefix(vector<string> &strs)" b
/* code by 王江 DC-Melo */
string longestCommonPrefix(vector<string> &strs) {
	if( strs.size() == 0) return "";
	string prefix = strs[0];
	for(int i = 0;i<strs.size();i++) {
		if(prefix.size() == 0 || strs[i].size() == 0) return "";
		int j = 0;
		while(prefix[j] == strs[i][j]) { j++; }
		prefix = prefix.substr(0,j);
	}
	return prefix;
}
$0
endsnippet

# 015
snippet threeSum2 "(vector<vector<int>>)res=find three sum(vector<int> &num)" b
/* code by 王江 DC-Melo */
vector<vector<int>> threeSum(vector<int> &num) {
	vector<vector<int> > result;
	if(num.size() == 0) return result;
	sort(num.begin(),num.end());
	for( int pos1 = 0;pos1<num.size();pos1++) {
		for(int pos2 = pos1 + 1, pos3 = num.size() - 1; pos2 < pos3;) {
			int sum = num[pos1] + num[pos2] + num[pos3];
			if(sum == 0) {
				vector<int> tempResult;
				tempResult.push_back(num[pos1]);
				tempResult.push_back(num[pos2]);
				tempResult.push_back(num[pos3]);
				result.push_back(tempResult);
				while( pos2+1 < pos3 && num[pos2+1] == num[pos2]) pos2++;
				pos2++;
				while( pos3-1 > pos2 && num[pos3-1] == num[pos3]) pos3--;
				pos3--;
			}
			else if(sum < 0) pos2++;
			else pos3--;
		}
		while( pos1+1 < num.size() && num[pos1+1] == num[pos1]) pos1++;
	}
	return result;
}
$0
endsnippet

# 016
snippet threeSumClosest "(int)closest=find3SumClosest(vector<int> &num, int target)" b
/* code by 王江 DC-Melo */
int threeSumClosest(vector<int> &num, int target) {
	int closestSum = num[0]+num[1]+num[2];
	sort(num.begin(),num.end());
	for( int num1pos = 0; num1pos<num.size(); num1pos++ ) {
		for(int num2pos=num1pos+1, num3pos=num.size()-1; num2pos < num3pos;) {
			int sum = num[num1pos] + num[num2pos] + num[num3pos];
			if(sum == target) return target;
			if(abs(sum-target)<abs(closestSum-target)) closestSum = sum;
			if(sum < target) num2pos++;
			else num3pos--;
		}
	}
	return closestSum;
}
$0
endsnippet

# 017
snippet combinationPhoneNumberLetter "(vector<string>)combination=Letter Combinations of a Phone Number(string digits)" b
/* code by 王江 DC-Melo */
vector<string> letterCombinations(string digits) {
	vector<string> result;
	if(digits == "") return result;
	result.push_back("");
	vector<string> dict(10);
	dict[2] = "abc";
	dict[3] = "def";
	dict[4] = "ghi";
	dict[5] = "jkl";
	dict[6] = "mno";
	dict[7] = "pqrs";
	dict[8] = "tuv";
	dict[9] = "wxyz";
	for(int i = 0; i < digits.size(); i ++) {
		int size = result.size();
		for(int j = 0; j < size; j ++) {
			string current = result[0];
			result.erase(result.begin());
			for(int k = 0; k < dict[digits[i]-'0'].size(); k ++) result.push_back(current + dict[digits[i]-'0'][k]);
		}
	}
	return result;
}
$0
endsnippet

# 018
snippet fourSum "(vector<vector<int>>)sum=find Four Sum (vector<int>& nums, int target)" b
/* code by 王江 DC-Melo */
vector<vector<int>> fourSum(vector<int>& nums, int target) {
	vector<vector<int> > result;
	if(nums.size() == 0) return result;
	sort(nums.begin(),nums.end());
	for( int pos1 = 0;pos1<nums.size();pos1++) {
		for(int pos2 = pos1 + 1;pos2<nums.size();pos2++) {
			for(int pos3 = pos2 + 1, pos4 = nums.size() - 1; pos3 < pos4;) {
				int sum = nums[pos1] + nums[pos2] + nums[pos3] + nums[pos4];
				if(sum == target) {
					vector<int> tempResult;
					tempResult.push_back(nums[pos1]);
					tempResult.push_back(nums[pos2]);
					tempResult.push_back(nums[pos3]);
					tempResult.push_back(nums[pos4]);
					result.push_back(tempResult);
					while( pos3+1 < pos4 && nums[pos3+1] == nums[pos3]) pos3++;
					pos3++;
					while( pos4-1 > pos3 && nums[pos4-1] == nums[pos4]) pos4--;
					pos4--;
				}
				else if(sum < target) pos3++;
				else pos4--;
			}
			while( pos2+1 < nums.size() && nums[pos2+1] == nums[pos2]) pos2++;
		}
		while( pos1+1 < nums.size() && nums[pos1+1] == nums[pos1]) pos1++;
	}
	return result;
}
$0
endsnippet

# 019
snippet removeNthNodeFromEndOfList "(ListNode*)head=Remove Nth Node From End of List(ListNode *head, int n)" b
/* code by 王江 DC-Melo */
ListNode *${1:function}(ListNode *head, int n) {
	ListNode *tempHead = new ListNode(0);
	tempHead->next = head;
	ListNode *first = tempHead, *second = tempHead;
	for(int i = 0; i < n+1; i++) first = first -> next;
	while(first) {
		first = first -> next;
		second = second -> next;
	}
	second->next = second->next->next;
	return tempHead->next;
}
$0
endsnippet

# 020
snippet isValidParentheses "(bool)is=Find the number of valid parentheses expressions of given length(string s)" b
/* code by 王江 DC-Melo */
#include <stack>
bool isValid(string s) {
	stack<char> stk;
	for(int i=0;i<s.size();i++) {
		switch(s[i]) {
			case '(': stk.push(')');break;
			case '[': stk.push(']');break;
			case '{': stk.push('}');break;
			case ')': 
			case ']':
			case '}':
				if(stk.empty() || stk.top() != s[i]) 
					return false;
				else
					stk.pop();
				break;
		}
	}
	if(!stk.empty())
		return false;
	return true;
}
$0
endsnippet

# 021
snippet mergeTwoSortedLists "(ListNode*)head=Merge Two Sorted Lists(ListNode* l1, ListNode* l2)" b
/* code by 王江 DC-Melo */
ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
	ListNode *head = new ListNode(0);
	ListNode *point = head;
	while(l1 && l2) {
		if(l1->val < l2-> val) {
			point->next = l1;
			l1 = l1->next;
		} else {
			point->next = l2;
			l2 = l2->next;
		}
		point = point->next;
	}
	if(!l1) point->next = l2;
	else point->next = l1;
	return head->next;
}
$0
endsnippet

# 022
snippet generateNParentheses "(vector<string>)parStr=generate all combinations of well-formed parentheses(int n)" b
/* code by 王江 DC-Melo */
    void generate(vector<string> &strList, string str, int k, int length) {
        if(str.size() == length) {
            if(k==0) strList.push_back(str);
            return;
        }
        if(k>0) {
            generate(strList, str+')', k-1, length);
        }
        generate(strList, str+'(', k+1, length);
    }
    vector<string> generateParenthesis(int n) {
        vector<string> strList;
        string str;
        generate(strList, str, 0, n*2);
        return strList;
    }
$0
endsnippet

# 023
snippet mergeNSortedLists "(ListNode*)head=Merge k sorted linked lists(vector<ListNode*>& lists)" b
/* code by 王江 DC-Melo */
#include <queue>
struct Compare {
    bool operator()(const ListNode*p, const ListNode* q)const{
        return p->val > q->val;
    }
};
ListNode* mergeKLists(vector<ListNode*>& lists) {
	int length = lists.size();
	ListNode *head = new ListNode(0);
	ListNode *pointer = head;
	priority_queue<ListNode*, vector<ListNode*>, Compare> listQueue;
	for (int i=0; i<length; i++) if (lists[i]) listQueue.push(lists[i]);
	while (listQueue.size() > 0) {
		ListNode* tempNode = listQueue.top();
		listQueue.pop();
		pointer->next = tempNode;
		pointer = pointer->next;
		if (tempNode->next) listQueue.push(tempNode->next);
	}
	pointer->next = NULL;
	return head->next;
}
$0
endsnippet

# 024
snippet swapEach2NodesInPairs "(ListNode *)mem=swap every two adjacent nodes(ListNode* head)" b
/* code by 王江 DC-Melo */
ListNode *swapPairs(ListNode* head) {
	/* ListNode **pp = &head, *a, *b; */
	ListNode **pp = &head;
	ListNode  *a;
	ListNode  *b;
	while ((a = *pp) && (b = a->next)) {
		a->next = b->next;
		b->next = a;
		*pp = b;
		pp = &(a->next);
	}
	return head;
}
$0
endsnippet

# 025
snippet reverseNodesInKGroup "(ListNode *r)head=reverse first K Nodes other folow (ListNode *head, int k)" b
/* code by 王江 DC-Melo */
ListNode *reverseKGroup(ListNode *head, int k) {
	if( head==NULL || k==1 ) return head;
	int sum=0;
	ListNode *preheader = new ListNode(0);
	preheader->next = head;
	ListNode *current = preheader, *forward, *precede = preheader;
	while(current = current->next) sum++;
	while(sum>=k) {
		current = precede->next;
		forward = current->next;
		for(int i=1;i<k;++i) {
			current->next=forward->next;
			forward->next=precede->next;
			precede->next=forward;
			forward=current->next;
		}
		precede = current;
		sum-=k;
	}
	return preheader->next;
}
$0
endsnippet

# 026
snippet removeDuplicatesFromSortedArray "(int)mem=remove Duplicates from Sorted Array (vector<int>& nums)" b
/* code by 王江 DC-Melo */
int removeDuplicates(vector<int>& nums) {
	int length = nums.size();
	for(int i=0,j=1;j<nums.size();j++) {
		if(nums[i] != nums[j]) {
			i++;
			nums[i] = nums[j];
		} else length--;
	}
	return length;
}
$0
endsnippet

# 027
snippet removeVectorElement "(int)vec=remove vector element(vector<int>& nums, int val)" b
/* code by 王江 DC-Melo */
int removeElement(vector<int>& nums, int val) {
	int length = 0;
	for(int i=0,j=0;j<nums.size();j++) {
		if(nums[j] != val) {
			nums[i] = nums[j];
			i++;
			length ++;
		}
	}
	return length;
}
$0
endsnippet

# 028
snippet firstPositionSubstr1 "(int)pos=find the first position of substring Implement strStr(string haystack, string needle)" b
/* code by 王江 DC-Melo */
int strStr(string haystack, string needle) {
    if(needle.size() == 0) return 0;
    for(int i=0;i<haystack.size();i++) {
        int j = 0;
        for(j;j<needle.size();j++) {
            if(haystack[i+j] != needle[j]) break;
        }
        if(j == needle.size()) return i;
    }
    return -1;
}
$0
endsnippet

# 028
snippet firstPositionSubstr2 "(int)pos=find the first position of substring Implement strStr(string haystack, string needle)" b
/* code by 王江 DC-Melo */
int strStr(string haystack, string needle) {
	int m = haystack.length(), n = needle.length();
	if (!n) return 0;
	for (int i = 0; i < m - n + 1; i++) {
		int j = 0;
		for (; j < n; j++) if (haystack[i + j] != needle[j]) break;
		if (j == n) return i;
	}
	return -1;
}
$0
endsnippet

# 029
snippet divideTwoIntegers "(int)div=divide Two Integers without / function(int dividend, int divisor)" b
/* code by 王江 DC-Melo */
#include <limits.h>
int divide(int dividend, int divisor) {
	if(!divisor || (dividend == INT_MIN && divisor == -1)) return INT_MAX;
	int sign = ((dividend > 0) ^ (divisor > 0))? -1:1;
	long long dvd = labs(dividend);
	long long dvs = labs(divisor);
	long long result = 0;
	long long tempDivisor;
	int base;
	while(dvd >= dvs) {
		tempDivisor = dvs;
		base = 1;
		while( (dvd>>1) >= tempDivisor ) {
			tempDivisor <<= 1;
			base <<= 1;
		}
		dvd -= tempDivisor;
		result += base;
	}
	return sign>0? result:-result;
}
$0
endsnippet

# 030
snippet firstOcurenceSubstrings "(vector<int>)Substring with Concatenation of All Words(string s, vector<string>& words)" b
/* code by 王江 DC-Melo */
#include <map>
vector<int> findSubstring(string s, vector<string>& words) {
	vector<int> res;
	map<string, int> words_map;
	int l = s.size(), num = words.size(), len = words[0].size();
	for(int i = 0; i < num; i++){
		words_map[words[i]]++;
	}
	for(int i = 0; i < l - num*len + 1; i++){
		map<string, int> finded;
		int j = 0;
		for( ; j < num; j++){
			string cur = s.substr(i + j*len, len);
			if(words_map.find(cur) != words_map.end()){
				finded[cur]++;
				if(finded[cur] > words_map[cur]) break;
			}
			else break;
		}
		if(j == num)
			res.push_back(i);
	}
	return res;
}
vector<int> findSubstring(string S, vector<string> &L) {
	ret.clear();
	if (L.size() == 0) return ret;
	index.clear();
	countSize = 0;
	for(int i = 0; i < L.size(); i++)
		if (index.count(L[i]) > 0) count[index[L[i]]]++;
		else {
			index[L[i]] = countSize;
			count[countSize++] = 1;
		}
		int step = L[0].size();
		vector<int> a;
		for(int i = 0; i < step; i++) {
			a.clear();
			for(int j = i; j < S.size(); j += step) {
				if (j + step <= S.size()) {
					string s(S, j, step);
					if (index.count(s) > 0) a.push_back(index[s]);
					else a.push_back(-1);
				}
			}

			int beg = -1;
			int end = 0;
			int size = L.size();
			while(end < a.size()) {
				if (a[end] != -1) {
					if (count[a[end]] > 0) {
						if (beg == -1) beg = end;
						size--;
						count[a[end]]--;
					} else {
					   while(beg < end) {
						   count[a[beg]]++;
						   size++;
						   if (a[beg++] == a[end]) break;
					   }
					   count[a[end]]--;
					   size--;
					   }
				   } else {
					   size = L.size();
					   if (beg != -1) {    
						   for(int i = beg; i < end; i++) count[a[i]]++;
					   }
					   beg = -1;
				   }
				   end++;
				   if (size == 0) {
					   ret.push_back(beg * step + i);
					   size++;
					   count[a[beg]]++;
					   beg++;
				   }
			   }
			   if (beg != -1) {
				   for(int i = beg; i < end; i++) count[a[i]]++;
			   }
		   }
		   return ret;
   }
$0
endsnippet

# 031
snippet generateNextPermutation "(void)gen=generate Next Permutation (vector<int> &num)" b
/* code by 王江 DC-Melo */
void nextPermutation(vector<int> &num) {
	if(num.size() < 2) return;
	int curMax = num[num.size() - 1];
	for(int i = num.size() - 1; i >= 0;i--) {
		if(num[i] < curMax) {
			int tmp = num[i];
			int j = 0;
			for(j = i + 1; j < num.size();j++) {
				if(tmp < num[j]) {
					num[i] = num[j];
					num[j] = tmp;
					return;
				}
			}
			if(j == num.size()) {
				num[j - 1] = tmp;
				return;
			}
		} else {
			curMax = num[i];
			for(int j = i + 1; j < num.size();j++) num[j - 1] = num[j];
			num[num.size() - 1] = curMax;
		}
	}
}
$0
endsnippet

# 032
snippet findLongestValidParentheses "(int)maxlen=find Longest Valid Parentheses(string s)" b
/* code by 王江 DC-Melo */
int longestValidParentheses(string s) {
	stack<int>S;
	S.push(-1);
	int ans=0;
	for(string::size_type i=0;i<s.size();i++) {
		char ch=s[i];
		if(ch == '(') {
			S.push(i);
		} else {
			if(S.size()>1) {
				S.pop();
				int tmp=S.top();
				ans=max(ans,(int)i-tmp);
			} else {
				S.pop();
				S.push(i);
			}
		}
	}
	return ans;
}
$0
endsnippet

# 033
snippet searchInRotatedSortedArray "(int)pos=Search in Rotated Sorted Array(int A[], int n, int target)" b
/* code by 王江 DC-Melo */
int findPos(int a[], int left, int right) {
	if (left > right) return -1;
	int mid = left + (right - left) / 2;
	if (a[left] <= a[mid]) {
		int pos = findPos(a, mid + 1, right);
		if (pos == -1) return left;
		else return a[left] < a[pos] ? left : pos; 
	} else {
		int pos = findPos(a, left, mid - 1);
		if (pos == -1) return mid;
		else return a[pos] < a[mid] ? pos : mid;
	}
}
int bsearch(int a[], int left, int right, int key) {
	if (left > right) return -1;
	int mid = left + (right - left) / 2;
	if (a[mid] == key) return mid;
	else if (a[mid] < key) return bsearch(a, mid + 1, right, key);
	else return bsearch(a, left, mid - 1, key);
}
int search(int A[], int n, int target) {
	int pos = findPos(A, 0, n - 1);
	int index = bsearch(A, 0, pos - 1, target);
	if (index != -1) return index;
	return bsearch(A, pos, n - 1, target);
}
$0
endsnippet

# 034
snippet firstLastPositionOfElementInSortedArray "(vector<int>)index=find First Last Position Of Element In Sorted Array(int A[], int n, int target)" b
/* code by 王江 DC-Melo */
public:
    vector<int> searchRange(int A[], int n, int target) {
        begin = end = -1;
        find(A, 0, n - 1, target);
        vector<int> ans;
        ans.push_back(begin);
        ans.push_back(end);
        return ans;
    }
  
private:
    int begin;
    int end;
  
    void find(int A[], int l, int r, int target) {
        if (l > r) { return; }
        int mid = (l + r) >> 1;
        if (A[mid] == target) {
            if (mid < begin || begin == -1) { begin = mid; }            
            if (mid > end) { end = mid; }
            find(A, l, mid - 1, target);
            find(A, mid + 1, r, target);
        }
        else if (A[mid] < target) { find(A, mid + 1, r, target); }
        else { find(A, l, mid - 1, target); }
    }
$0
endsnippet

# 035
snippet searchBigThanPosition "(int)pos=Search Insert Position (vector<int>& nums, int target)" b
/* code by 王江 DC-Melo */
int searchInsert(vector<int>& nums, int target) {
	int mid,left = 0, right = nums.size();
	while(left < right) {
		mid =  left+(right-left)/2;
		if(nums[mid] > target) right = mid;
		else if (nums[mid] < target) left = mid + 1;
		else return mid;
	}
	return nums[mid]>target?mid:mid+1;
}
$0
endsnippet

# 036
snippet isSudokuValid "(bool)is=Determine if a 9 x 9 Sudoku board is valid (vector<vector<char> > &board)" b
/* code by 王江 DC-Melo */
bool isValidSudoku(vector<vector<char> > &board) {
	vector<vector<bool> > rows(9, vector<bool>(9,false));
	vector<vector<bool> > cols(9, vector<bool>(9,false));
	vector<vector<bool> > blocks(9, vector<bool>(9,false));
	for(int i = 0; i < 9; i++)
		for(int j = 0; j < 9; j++) {
			if(board[i][j] == '.')continue;
			int num = board[i][j] - '1';
			if(rows[i][num] || cols[j][num] || blocks[i - i%3 + j/3][num]) return false;
			rows[i][num] = cols[j][num] = blocks[i - i%3 + j/3][num] = true;
		}
	return true;
}
$0
endsnippet

# 037
snippet sudokuSolver "comment " b
/* code by 王江 DC-Melo */
bool isValid(vector<vector<char> > &board, int a, int b) {
	for (int i = 0; i < 9; ++i) { if (i != a && board[i][b] == board[a][b]) return false; }
	for (int j = 0; j < 9; ++j) { if (j != b && board[a][j] == board[a][b]) return false; }
	int x = a / 3 * 3, y = b / 3 * 3;
	for (int i = 0; i < 3; ++i) {
		for (int j = 0; j < 3; ++j) {
			if (x + i != a && y + j != b && board[x + i][y + j] == board[a][b]) return false;
		}
	}
	return true;
}
bool solveHelper(vector<vector<char> > &board) {
	for (int i = 0; i < 9; ++i) {
		for (int j = 0; j < 9; ++j) {
			if (board[i][j] == '.') {
				for (int k = 1; k <= 9; ++k) {
					board[i][j] = '0' + k;
					if (isValid(board, i, j) && solveHelper(board)) { return true; }
					board[i][j] = '.';
				}
				return false;
			}
		}
	}
	return true;
}

void solveSudoku(vector<vector<char> > &board) 
{
	solveHelper(board);
}
$0
endsnippet

# 038
snippet countAndSay "(string)countsay=count-and-Say (string s)" b
/* code by 王江 DC-Melo */
string revolution(string s) {
	string ret;
	/* char pre =s[0]; */ 
	int i,j;
	int count = 1;
	for(i = 1, j=0; i < s.size(); i ++) {
		if(s[i]==s[j]) { count ++; }
		else {
			char tmp =  count+'0';
			ret = ret + tmp + s[j];
			/* s[j] = s[i]; */
			j=i;
			count = 1;
		}
	}
	char tmp =  count+'0';
	ret = ret + tmp + s[j];
	return   ret;
}
string countAndSay(int n) {
	string ret = "1";
	int j = 1;
	while( j< n) {
		ret=revolution(ret);
		j++;
	}
	return ret;
}
$0
endsnippet

# 039
snippet sumCombination "(vector<vector<int> >)set=Combination Sum with use element many times() " b
/* code by 王江 DC-Melo */
#include <algorithm>
public:
    vector<vector<int> > combinationSum(vector<int> &candidates, int target) {
        vector<int> vecTmp;
        m_vecRet.clear();
        sort(candidates.begin(), candidates.end());
        combination(candidates, 0, vecTmp, target);
        return m_vecRet;
    }
private:
    void combination(const vector<int> &candidates, size_t idx, vector<int> &curr, int target) {
        if (target == 0) { m_vecRet.push_back(curr); }
        else {
            for (size_t i = idx; i < candidates.size(); ++i) {
                if (target >= candidates[i]) {
                    curr.push_back(candidates[i]);
                    combination(candidates, i, curr, target - candidates[i]);
                    curr.pop_back();
                }
            }
        }
    }

$0
endsnippet

# 040
snippet sumCombinationII "(vector<vector<int> >)set=Combination Sum with use element many times() " b
/* code by 王江 DC-Melo */
public:
    vector<vector<int> > combinationSum2(vector<int> &num, int target) {
        vector<int> vecTmp;
        m_vecRet.clear();
        sort(num.begin(), num.end());
        combination(num, 0, vecTmp, target);
        return m_vecRet;
    }
  
private:
    void combination(const vector<int> &num, size_t idx, vector<int> &curr, int target) {
        if (target == 0) { m_vecRet.push_back(curr); }
        else {
            for (size_t i = idx; i < num.size(); ++i) {
                if (i != idx && num[i] == num[i - 1]) { continue; }
                if (target >= num[i]) {   
                    curr.push_back(num[i]);
                    combination(num, i + 1, curr, target - num[i]);
                    curr.pop_back();
                }
            }
        }
    }
private:
    vector<vector<int> > m_vecRet;
$0
endsnippet
# 041
snippet firstMissingPositiveNumber "find the first missing positive integer" b
/* code by 王江 DC-Melo */
void swap(int &a,int &b) {
	int temp = a;
	a = b;
	b = temp;
}
int firstMissingPositive(int A[], int n) {
	for(int i=0;i<n;i++) {
		while(A[i]!=i+1) {
			if(A[i]>=n||A[i]<=0||A[i]==A[A[i]-1]) break;
			swap(A[i],A[A[i]-1]);
		}
	}
	for(int i=0;i<n;i++) { if(A[i]!=i+1) return i+1; }
	return n+1;
}
$0
endsnippet

# 042
snippet maxWaterArea1 "(int)area=Trapping Rain Water(int A[], int n)" b
/* code by 王江 DC-Melo */
int trap(int A[], int n) {
	int leftMax = 0;
	int left[n]; 
	for(int i=0;i<n;i++) {
		left[i] = leftMax;
		if(A[i] > leftMax) leftMax = A[i];
	}
	int rightMax = 0;
	int right[n]; 
	for(int i=n-1;i>=0;i--) {
		right[i] = rightMax;
		if(A[i] > rightMax) rightMax = A[i];
	}
	int result = 0;
	int temp;
	for(int i=0;i<n;i++) {
		temp = min(left[i],right[i]);
		if(temp > A[i]) result += temp-A[i];
	}
	return result;
}
$0
endsnippet

# 042
snippet maxWaterArea2 "(int)area=Trapping Rain Water(vector<int>& height)" b
/* code by 王江 DC-Melo */
    int trap(vector<int>& height) {
        int res = 0, mx = 0, n = height.size();
        vector<int> dp(n, 0);
        for (int i = 0; i < n; ++i) {
            dp[i] = mx;
            mx = max(mx, height[i]);
        }
        mx = 0;
        for (int i = n - 1; i >= 0; --i) {
            dp[i] = min(dp[i], mx);
            mx = max(mx, height[i]);
            if (dp[i] > height[i]) res += dp[i] - height[i];
        }
        return res;
    }
$0
endsnippet

# 042
snippet maxWaterArea3 "(int)area=Trapping Rain Water(vector<int>& height)" b
/* code by 王江 DC-Melo */
int trap(vector<int>& height) {
	int res = 0, l = 0, r = height.size() - 1;
	while (l < r) {
		int mn = min(height[l], height[r]);
		if (mn == height[l]) {
			++l;
			while (l < r && height[l] < mn) {
				res += mn - height[l++];
			}
		} else {
			--r;
			while (l < r && height[r] < mn) {
				res += mn - height[r--];
			}
		}
	}
	return res;
}
$0
endsnippet

# 042
snippet maxWaterArea4 "(int)area=Trapping Rain Water(vector<int>& height)" b
/* code by 王江 DC-Melo */
int trap(vector<int>& height) {
	int l = 0, r = height.size() - 1, level = 0, res = 0;
	while (l < r) {
		int lower = height[(height[l] < height[r]) ? l++ : r--];
		level = max(level, lower);
		res += level - lower;
	}
	return res;
}
$0
endsnippet

# 042
snippet maxWaterArea5 "(int)area=Trapping Rain Water(vector<int>& height)" b
/* code by 王江 DC-Melo */
int trap(vector<int>& height) {
	stack<int> st;
	int i = 0, res = 0, n = height.size();
	while (i < n) {
		if (st.empty() || height[st.top()] >= height[i]) {
			st.push(i++);
		} else {
			int m = st.top(); st.pop();
			if (st.empty()) continue;
			res += (min(height[i], height[st.top()]) - height[m]) * (i - st.top() - 1);
		}
	}
	return res;
}
$0
endsnippet

# 043
snippet multiplyTwoStringsNumber "(string)str=multiply Two Strings Number (string num1, string num2)" b
/* code by 王江 DC-Melo */
string multiply(string num1, string num2) {
	int len1 = num1.size(), len2 = num2.size(), len = len1 + len2;
	string str(len, '0');
	for (int i = len1 - 1; i >= 0; i--) {
		int a = num1[i] - '0';
		for (int j = len2 - 1, k = len2 + i; j >= 0; j--, k--) {
			int b = num2[j] - '0';
			int c = str[k] - '0';
			int t = b * a + c;
			str[k] = t % 10 + '0';
			int d = (str[k-1] - '0') + t / 10;
			if (d >= 10) str[k-2] = str[k-2] - '0' + d / 10 + '0';
			str[k-1] = d % 10 + '0';
		}
	}
	int x = 0;
	while (str[x] == '0') x++;
	if (str.substr(x, len - x) == "") return "0";
	return str.substr(x, len - x);
}
$0
endsnippet

# 044
snippet isWildcardMatching "is Wildcard regex Matching " b
/* code by 王pre,next;
        const char *start,*end,*mid;
        const char *ss,*se,*sm;
        start = p;
        end = p;
        ss = s;
        while(true) {
            if(*start == '*') pre = true;//查看前面有没有*
            else pre = false; //查看新的没有*的word
            while(*start != '\0' && *start == '*') start++;
            end = start;
            while(*end != '\0' && *end != '*') end++;
            if(*end == '*') next = true;
            else next = false;
            end--;
          
            if(*ss == '\0' && pre && *start == '\0') return true;//p和s均完全匹配
            if(*ss != '\0' && pre && *start == '\0') return true;
            if(*ss != '\0' && (*start == '\0' && !pre)) return false;//s没能完全匹配
            if(*ss == '\0' && *start != '\0') return false;//p的字母没能匹配完全
          
            //处理greedy匹配问题
            if(next == true) {//后面有*可供匹配
                if(pre == true) {//前面有供做匹配的
                    sm = ss,mid = start;//判断s中剩余的还够匹配不够
                    while(mid != end && *sm != '\0') { mid++,sm++; }
                    if(*sm == '\0') return false;
                    mid = start;
                    while(*mid != '*' && *ss != '\0') {
                        for(sm = ss,mid = start;*sm != '\0' && *mid != '*';sm++,mid++) {
                            if(*mid == '?')continue;
                            if(*mid != *sm)break;
                        }
                        if(*mid == '*') ss = sm;
                        else ss++;
                    }//while
                    if(*mid != '*') return false;
                    ss = sm;
                    start = mid;
                } else {//前面没有供匹配的
                    for(sm = ss,mid = start;*sm != '\0' && mid != end+1;sm++,mid++) {
                        if(*mid == '?') continue;
                        if(*mid != *sm) return false;
                    }
                    if(mid != end+1) return false;
                    ss = sm;//匹配成功
                    start = end+1;
                }
            } else {//最后必须匹配的一串，因为后面没有*可供匹配最后的字母
                if(pre) {
                    se = ss;
                    while(*se != '\0') se++;
                    se--;
                    for(sm = se,mid = end;mid != start && sm != ss;mid--,sm--) {
                        if(*mid == '?') continue;
                        if(*mid != *sm) return false;
                    }
                    if((sm == ss && mid != start) || (*mid != *sm && *mid != '?')) return false;//如果s不够匹配或者p开头不能匹配
                    return true;
                } else {
                    for(sm = ss,mid = start;*sm != '\0' && *mid !='\0';sm++,mid++) {
                        if(*mid == '?') continue;
                        if(*mid != *sm) return false;
                    }
                    if(*sm != '\0' || *mid != '\0') return false;
                    return true;
                }
            }
        }
    }
};
class Solution2 {
public:
    bool isMatch(string s, string p) {
        int len1 = s.length(), len2 = p.length();
        vector<vector<bool>> ans(len1 + 1, vector<bool> (len2 + 1, false));
        ans[0][0] = true;
        for (int j=1;j<=len1;j++){
            ans[0][j] = ( p[j]=='*');
        } 
        for (int i = 0; i < len1; i++) {
            for (int j = 0; j < len2; j++) {
                if(p[j]=='*'){
                    ans[i+1][j+1]= true && (ans[i][j] || ans[i+1][j] );
                }else if(p[j]==s[i] || p[j]=='?'){
                    ans[i+1][j+1]= true && (ans[i][j]);
                }
                /* else{ */
                /*     ans[i+1][j+1]= 0; */
                /* } */
            }
        }
        return ans[len1][len2];
    }
};
class Solution3 {
public:
	bool isMatch(string s, string p) {
		int n = s.size(), m = p.size();
		int i = 0, j = 0, ri = -1, rj = -1;
		while (i < n)
		{
			if (p[j] == '*')
			{
				ri = i;
				rj = j++;
			}
			else if (p[j] == '?' || p[j] == s[i])
			{
				i++; j++;
			}
			else if (rj > -1)
			{
				i = ++ri;
				j = rj+1;
            } else{
                return false;
            } 
		}
		while (j < m && p[j] == '*')j++;
		return j == m;
	}
    bool isMatchB(const char *s, const char *p) {
            const char* ps=nullptr;
            const char* ss=nullptr;
            while (*s){
                if (*p=='*'){ps=p; ss=s; p++;} //save states and then p++,use * as zero
                else if ((*p=='?')||(*p==*s)){s++;p++;} //pattern ok,next
                else if(ps){p=ps+1; s=ss+1;ss++;}//restory states and next step,and old states. 
                else return false;
            }
            while (*p=='*'){++p;}
            return !*p;
    }
};
class Solution4 {
    int drs(const char *s, const char *p){
            const char* ps=nullptr;
            const char* pp=nullptr;
            //边界处理,退出条件
            if (!*s and !*p ){return true;}
            if(!*s and *p=='*'){return true;}
            if(!*s and *p!='*'){return false;}
            //循环判断
            if(*p=='*'){ps=s;pp=p;drs(s,++p);}
            if((*p=='?')||(*p==*s)){drs(++s,++p);}
            if(ps){drs(ps+1,pp+1);++ps;}
    }
     int dfs(string& s, string& p, int si, int pi) {
         if (si == s.size() and pi == p.size()) return 2;
         if (si == s.size() and p[pi] != '*') return 0;
         if (pi == p.size()) return 1;
         if (p[pi] == '*') {
             if (pi + 1 < p.size() and p[pi + 1] == '*')
                 return dfs(s, p, si, pi + 1); // skip duplicate ‘*’
             for (int i = 0; i <= s.size() - si; ++i) {
                 int ret = dfs(s, p, si + i, pi + 1);
                 if (ret == 0 or ret == 2) return ret;
             }
         }else if (p[pi] == '?' or s[si] == p[pi]){
             return dfs(s, p, si + 1, pi + 1);
         }
         return 1;
     }

	 public:
		 bool isMatch(string s, string p) {
			 /* return dfs(s, p, 0, 0) > 1; */
            /* char *sc=s.data(); */
            /* char *pc=p.data(); */
			return drs("abcab", "*a*ab");
			/* return 0; */
		 }
};
int main(){
    Solution sln;
    Solution2 sln2;
    Solution3 sln3;
    Solution4 sln4;
    /* bool ret=sln.isMatch("adcab","*ab"); */
    /* bool ret=sln.isMatch("adcab","**ab"); */
    /* cout << "ret:"<<ret<<endl; */
    bool ret2=sln2.isMatch("adcab","*aab");
    cout << "ret2:"<<ret2<<endl;
    bool ret3=sln3.isMatchB("bcd","**cd");
    cout << "ret3:"<<ret3<<endl;
    bool ret4=sln4.isMatch("adcab","**ab");
    cout << "ret4:"<<ret4<<endl;

}
$0
endsnippet

# 045
snippet minStepToEndJumpGameII "(int)step=The minimum number of jumps to reach the last index(int A[], int n)" b
/* code by 王江 DC-Melo */
int jump(int A[], int n) {
	int ret = 0;
	int curMax = 0;
	int curRch = 0;
	for(int i = 0; i < n; i ++)
	{
		if(curRch < i)
		{
			ret ++;
			curRch = curMax;
		}
		curMax = max(curMax, A[i]+i);
	}
	return ret;
}
$0
endsnippet

## 046
#snippet permutations "comment " b
#/* code by 王江 DC-Melo */

##include<vector>
##include<algorithm>
##include<exception>
#using namespace std;

#class Solution 
#{
#public:
#    vector<int> nextPermutation(vector<int> &num) 
#    {
#        if(num.size() < 2) 
#            return num;
#        int curMax = num[num.size() - 1];
#        for(int i = num.size() - 1; i >= 0;i--)
#        {
#            if(num[i] < curMax)
#            {
#                int tmp = num[i];
#                int j = 0;
#                for(j = i + 1; j < num.size();j++)
#                {
#                    if(tmp < num[j])
#                    {
#                        num[i] = num[j];
#                        num[j] = tmp;
#                        return num;
#                    }
#                }
#                if(j == num.size())
#                {
#                    num[j - 1] = tmp;
#                    return num;
#                }
#            }
#            else
#            {
#                curMax = num[i];
#                for(int j = i + 1; j < num.size();j++)
#                    num[j - 1] = num[j];
#                num[num.size() - 1] = curMax;
#            }
#        }
#        return num;
#    }
#    vector<vector<int> > permute(vector<int> &num) 
#    {
#        long long n = num.size();
#        for(int i=n-1;i>0;i--)
#            n *= i;
#        vector<vector<int> > result;
#        while(n--)
#            result.push_back(nextPermutation(num));
#        return result;
#    }
#};

#class Solution1 {
#public:
#    vector<vector<int>> permute(vector<int>& num) {
#        vector<vector<int>> res;
#        vector<int> out, visited(num.size(), 0);
#        permuteDFS(num, 0, visited, out, res);
#        return res;
#    }
#    void permuteDFS(vector<int>& num, int level, vector<int>& visited, vector<int>& out, vector<vector<int>>& res) {
#        if (level == num.size()) {res.push_back(out); return;}
#        for (int i = 0; i < num.size(); ++i) {
#            if (visited[i] == 1) continue;
#            visited[i] = 1;
#            out.push_back(num[i]);
#            permuteDFS(num, level + 1, visited, out, res);
#            out.pop_back();
#            visited[i] = 0;
#        }
#    }
#};

#class Solution2 {
#public:
#    vector<vector<int>> permute(vector<int>& num) {
#        vector<vector<int>> res;
#        permuteDFS(num, 0, res);
#        return res;
#    }
#    void permuteDFS(vector<int>& num, int start, vector<vector<int>>& res) {
#        if (start >= num.size()) res.push_back(num);
#        for (int i = start; i < num.size(); ++i) {
#            swap(num[start], num[i]);
#            permuteDFS(num, start + 1, res);
#            swap(num[start], num[i]);
#        }
#    }
#};

#class Solution3 {
#public:
#    vector<vector<int>> permute(vector<int>& num) {
#        if (num.empty()) return vector<vector<int>>(1, vector<int>());
#        vector<vector<int>> res;
#        int first = num[0];
#        num.erase(num.begin());
#        vector<vector<int>> words = permute(num);
#        for (auto &a : words) {
#            for (int i = 0; i <= a.size(); ++i) {
#                a.insert(a.begin() + i, first);
#                res.push_back(a);
#                a.erase(a.begin() + i);
#            }
#        }
#        return res;
#    }
#};

#class Solution4 {
#public:
#    vector<vector<int>> permute(vector<int>& num) {
#        vector<vector<int>> res{{}};
#        for (int a : num) {
#            for (int k = res.size(); k > 0; --k) {
#                vector<int> t = res.front();
#                res.erase(res.begin());
#                for (int i = 0; i <= t.size(); ++i) {
#                    vector<int> one = t;
#                    one.insert(one.begin() + i, a);
#                    res.push_back(one);
#                }
#            }
#        }
#        return res;
#    }
#};

#class Solution5 {
#public:
#    vector<vector<int>> permute(vector<int>& num) {
#        vector<vector<int>> res;
#        sort(num.begin(), num.end());
#        res.push_back(num);
#        while (next_permutation(num.begin(), num.end())) {
#            res.push_back(num);
#        }
#        return res;
#    }
#};

#int main(int argc, char *argv[])
#{
#    Solution sln;
#    Solution1 sln1;
#    Solution2 sln2;
#    Solution3 sln3;
#    Solution4 sln4;
#    Solution5 sln5;
#    vector<int> input={ 4, 3, 2, 1 };
#    vector<vector<int>> ret=sln.permute(input);
#    vector<vector<int>> ret1=sln1.permute(input);
#    vector<vector<int>> ret2=sln2.permute(input);
#    vector<vector<int>> ret3=sln3.permute(input);
#    vector<vector<int>> ret4=sln4.permute(input);
#    vector<vector<int>> ret5=sln5.permute(input);
#    return 0;
#}
#$0
#endsnippet

## 047
#snippet permutationsII "comment " b
#/* code by 王江 DC-Melo */

##include <iostream>
##include <vector>
##include <math>
#using namespace std;
#class Solution {
#public:
#    vector<vector<int> > permuteUnique(vector<int> &num) 
#    {
#        int len = num.size();
#        vector<vector<int> > res;
#        sort(num.begin(), num.end());
#        gen(res, num, 0, len);
#        return res;
#    }
   
#    bool isSwap(vector<int>& num, int s, int e) 
#    {
#        int i = s;
#        while (num[i] != num[e] && i < e) i++;
#        if (i == e) return true;
#        else return false;
#    }
   
#    void gen(vector<vector<int> > &res, vector<int>& num, int cur, int len) 
#    {
#        if (cur == len) {
#            res.push_back(num);
#            return;
#        }

#        for (int i = cur; i < len; i++) {
#            if (!isSwap(num, cur, i)) continue;
#            swap(num[cur], num[i]);
#            gen(res, num, cur+1, len);
#            swap(num[cur], num[i]);
#        }
#    }
#};

#int main(int argc, char *argv[])
#{
#    Solution sln;
#    int input[]={2,3,1,1,4 };
#    int output=sln.jump(input,5);
#    std::cout << "output:" << output << std::endl;
#    return 0;
#}
#$0
#endsnippet

# 47
snippet rotateImage "rotateImage " b
/* code by 王江 DC-Melo */
void rotate(vector<vector<int> > &matrix) {
	int n=matrix.size();
	int temp = 0;
	for(int i=0;i<n;i++) {
		for(int j=i;j<n;j++) swap(matrix[i][j],matrix[j][i]);
		reverse(matrix[i].begin(),matrix[i].end());
	}
}
$0
endsnippet

# 049
snippet groupAnagrams "(vector<string>)group=group words with same character(vector<string> &strs)" b
/* code by 王江 DC-Melo */
#include <map>
#include <algorithm>
vector<string> anagrams(vector<string> &strs) {
	string s;
	map<string, int> anagram;
	vector<string> result;
	for (int i = 0; i < strs.size(); ++i) {
		s = strs[i];
		sort(s.begin(), s.end());
		if (anagram.find(s) == anagram.end()) {
			anagram[s] = i;
		} else {
			if (anagram[s] >= 0) {
				result.push_back(strs[anagram[s]]);
				anagram[s] = -1;
			}
			result.push_back(strs[i]);
		}
	}
	return result;        
}
$0
endsnippet

# 050
snippet calculatePowxn "(double)cal=comment (double x, int n)" b
/* code by 王江 DC-Melo */
double pow(double x, int n) {
	long long index = n;
	double result = 0;
	int flag = 1;
	if (x<0 && n%2!=0) x = -x, flag = -1;
	if (index < 0) result = powI(x, -index);
	else result = powI(x, index);
	if (index < 0) return 1/result*flag;
	else return result*flag;
}
double powI(double x, long long n) // x>0, n>=0 {
	if (n == 0) return 1;
	else if (n == 1) return x;
	else if (n == 2) return x*x;
	else {
		if (n%2==0) {
			double mid = powI(x, n/2);
			return mid*mid;
		} else {
			double mid = powI(x, (n-1)/2);
			return mid*mid*x;
		}
	}
}
$0
endsnippet

# 051
snippet putQueensN "(vector<vector<string> >)place=placing n queens that no two queens attack each other(int n)" b
/* code by 王江 DC-Melo */
vector<vector<string> > result;
bool isAvailable(int row, int line) {
	for(int i=0;i<row;i++) {
		if( line == chessBoard[i] || abs(row-i) == abs(line - chessBoard[i]) ) return false;
	}
	return true;
}

void solve(int curLine) {
	if(curLine == target) {
		result.push_back(tempResult);
		for(int i=0;i<target;i++) result.back()[i][chessBoard[i]] = 'Q';
	} else {
		for(int i=0;i<target;i++) {
			if(isAvailable(curLine,i)) {
				chessBoard[curLine] = i;
				solve(curLine+1);
			}
		}
	}
}
vector<vector<string> > solveNQueens(int n) {
	chessBoard.resize(n);
	target = n;
	string tempRow;
	for(int i=0;i<n;i++) tempRow.push_back('.');
	for(int i=0;i<n;i++) tempResult.push_back(tempRow);
	solve(0);
	return result;
}
$0
endsnippet

# 052
snippet putQueensNII "(vector<vector<string> >)place=placing n queens that no two queens attack each other(int n)" b
/* code by 王江 DC-Melo */
vector<vector<string> > result;
bool isAvailable(int row, int line) {
	for(int i=0;i<row;i++) {
		if( line == chessBoard[i] || abs(row-i) == abs(line - chessBoard[i]) ) return false;
	}
	return true;
}
void solve(int curLine) {
	if(curLine == target) {
		result.push_back(tempResult);
		for(int i=0;i<target;i++) result.back()[i][chessBoard[i]] = 'Q';
	} else {
		for(int i=0;i<target;i++) {
			if(isAvailable(curLine,i)) {
				chessBoard[curLine] = i;
				solve(curLine+1);
			}
		}
	}
}
int totalNQueens(int n) {
	chessBoard.resize(n);
	target = n;
	string tempRow;
	for(int i=0;i<n;i++) tempRow.push_back('.');
	for(int i=0;i<n;i++) tempResult.push_back(tempRow);
	solve(0);
	return result.size();
}
$0
endsnippet

# 053
snippet findContinuousMaxSubarray "(int)max=find the contiguous subarray in integer array nums(int A[], int n)" b
/* code by 王江 DC-Melo */
int maxSubArray(int A[], int n) {
	int ThisSum,MaxSum;
	MaxSum = A[0];
	ThisSum = 0;
	for(int j=0;j<n;j++) {
		ThisSum += A[j];
		if( ThisSum > MaxSum) MaxSum = ThisSum;
		if(ThisSum < 0) ThisSum = 0;
	}
	return MaxSum;
}
$0
endsnippet

# 054
snippet rotateMatrixSpiralMatrix "(vector<int>)rotate=all elements of the matrix in spiral order(vector<vector<int> > &matrix)" b
/* code by 王江 DC-Melo */
struct Node {
    int x,y;
    Node(int _x,int _y):x(_x),y(_y){}
};
vector<int> spiralOrder(vector<vector<int> > &matrix) {
	// Start typing your C/C++ solution below
	// DO NOT write int main() function
	vector<int> result;
	int m=matrix.size();
	if(m==0) return result;
	int n=matrix[0].size();
	if(n==0) return result;

	Node a(0,0);
	Node b(m-1,n-1);
	int e = m < n ? m : n;
	e = e/2;
	while(e--) {
		for(int i=a.y;i<=b.y;i++) result.push_back(matrix[a.x][i]);
		for(int i=a.x+1;i<=b.x;i++) result.push_back(matrix[i][b.y]);
		for(int i=b.y-1;i>=a.y;i--) result.push_back(matrix[b.x][i]);
		for(int i=b.x-1;i>a.x;--i) result.push_back(matrix[i][a.y]);
		a.x++;
		a.y++;
		b.x--;
		b.y--;
	}
	if(a.x==b.x) {
		for(int i=a.y;i<=b.y;i++) result.push_back(matrix[a.x][i]);
	} else if(a.y==b.y) {
		for(int i=a.x;i<=b.x;i++) result.push_back(matrix[i][a.y]);
	}
	return result;
}
$0
endsnippet

# 055
snippet canJumpEndJumpGame "(bool)can=reach the last index(int A[], int n)" b
/* code by 王江 DC-Melo */
bool canJump(int A[], int n) {
	int max = 0;
	for(int i=0;i<n;i++) {
		if(A[i]>max) max = A[i];
		if(max == 0 && i != n-1) return false;
		max--;
	}
	return true;
}
$0
endsnippet

# 056
snippet mergeAreaIntervals "(vector<Interval>)merge=all overlapping intervals(vector<Interval> &intervals)" b
/* code by 王江 DC-Melo */
/**
 * Definition for an interval.
 * struct Interval {
 *     int start;
 *     int end;
 *     Interval() : start(0), end(0) {}
 *     Interval(int s, int e) : start(s), end(e) {}
 * };
 */
bool cmp(struct Interval in1,struct Interval in2) { return in1.start < in2.start; }
vector<Interval> merge(vector<Interval> &intervals) {
	sort(intervals.begin(),intervals.end(),cmp);
	vector<Interval> result;
	if(intervals.size()==0)
		return result; 
	int pend=intervals[0].end;
	Interval s(intervals[0].start,pend);
	for(int i=1;i<intervals.size();i++) {
		if(intervals[i].start>pend) {   
			s.end=pend;
			result.push_back(s);
			s.start=intervals[i].start;
			pend=intervals[i].end;
		}
		else pend=max(intervals[i].end,pend);       
	}
	 s.end=pend;
	 result.push_back(s);
	 return result;
}
$0
endsnippet

# 057
snippet insertAreaInterval "(vector<Interval>)area=insert merge interval into the intervals(vector<Interval> &intervals, Interval newInterval)" b
/* code by 王江 DC-Melo */
/**
 * Definition for an interval.
 * struct Interval {
 *     int start;
 *     int end;
 *     Interval() : start(0), end(0) {}
 *     Interval(int s, int e) : start(s), end(e) {}
 * };
 */
vector<Interval> insert(vector<Interval> &intervals, Interval newInterval) {
	int i = 0;
	int len = intervals.size();
	if(0 == len) { intervals.push_back(newInterval); return intervals; }
	vector<Interval> re;
	//find the insert position of start.
	while(i < len && intervals[i].end < newInterval.start) {
		re.push_back(intervals[i]);
		++i;
	}
	//at the right, 
	if(i == len) { re.push_back(newInterval); return re; }
	int j = i;
	//find the insert position of end.
	while(j < len && intervals[j].end < newInterval.end) { ++j; }
	Interval jion;
	jion.start = min(intervals[i].start, newInterval.start);
	if(j == len) {
		jion.end = newInterval.end;
		re.push_back(jion);
		return re;
	}
	if(newInterval.end < intervals[j].start) {
	   --j;
	   jion.end = newInterval.end;
	   re.push_back(jion);
	} else {
		jion.end = intervals[j].end;
		re.push_back(jion);
	}
	++j;
	while(j < len) {
		re.push_back(intervals[j]);
		++j;
	}
	return re;
}
$0
endsnippet

# 058
snippet countLengthOfLastWord "(int)len=length of last word in the string(const char *s)" b
/* code by 王江 DC-Melo */
int lengthOfLastWord(const char *s) {
	int result = 0;
	bool flag = false;
	while(*s != '\0') {
		if(*s == ' ') flag = true;
		else if(flag == true) {
			flag = false;
			result = 1;
		} else result++;
		s++;
	}
	return result;
}
$0
endsnippet

# 059
snippet genrotateMatrixSpiralMatrixII "(vector<vector<int> >)matrix=generate a square matrix filled with elements in spiral order " b
/* code by 王江 DC-Melo */
void solve(int startPos, int startNum, int n) {
	if(n <= 0) return ;
	else  {
		for(int i=startPos;i<startPos+n;i++) {
			matrix[startPos][i] = startNum;
			startNum++;
		}
		for(int i=startPos+1;i<startPos+n;i++) {
			matrix[i][startPos+n-1] = startNum;
			startNum++;
		}
		for(int i=startPos+n -2;i> startPos-1;i--) {
			matrix[startPos+n-1][i] = startNum;
			startNum++;
		}
		for(int i=startPos+n -2;i>startPos;i--) {
			matrix[i][startPos] = startNum;
			startNum++;
		}
		solve(startPos+1,startNum,n-2);
	}
}
vector<vector<int> > generateMatrix(int n) 
{
	matrix.resize(n,vector<int>(n));
	solve(0,1,n);
	return matrix;
}
$0
endsnippet

# 060
snippet getKthPermutation "(sting)kth=Given n and k, return the kth permutation sequence.(int n, int k)" b
/* code by 王江 DC-Melo */
string getPermutation(int n, int k) {
	vector<int> nums(n);
	int pCount = 1;
	for(int i = 0 ; i < n; ++i) {
		nums[i] = i + 1;
		pCount *= (i + 1);
	}
	k--;
	string res = "";
	for(int i = 0 ; i < n; i++) {
		pCount = pCount/(n-i);
		int selected = k / pCount;
		res += ('0' + nums[selected]);
		for(int j = selected; j < n-i-1; j++) nums[j] = nums[j+1];
		k = k % pCount;
	}
	return res;
}
$0
endsnippet

# 061
snippet reverseNodeBykthrotateList "(ListNode *)rotate=the list to the right by k places(ListNode *head, int k)" b
/* code by 王江 DC-Melo */
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
ListNode *rotateRight(ListNode *head, int k) {
	if(k == 0 || head == NULL) return head;
	int length = 0;
	for(ListNode *temp = head;temp != NULL;temp = temp->next) length++;
	ListNode* left = head, *right = head;
	k %= length;
	while(k--) right = right->next;
	while(right->next != NULL) {
		right = right->next;
		left = left->next;
	}
	right->next = head;
	ListNode *result = left->next;
	left->next = NULL;
	return result;
}
$0
endsnippet

# 062
snippet howManyUniquePaths "(int)num=How many possible unique paths are there(int m, int n)" b
/* code by 王江 DC-Melo Dynamic Programming */
int uniquePaths(int m, int n) {
	vector<vector<int> > f(m, vector<int>(n));
	for(int i = 0; i < n; i++) f[0][i] = 1;
	for(int i = 0; i < m; i++) f[i][0] = 1;
	for(int i = 1; i < m; i++) for(int j = 1; j < n; j++) f[i][j] = f[i-1][j] + f[i][j-1];
	return f[m-1][n-1];
}
$0
endsnippet

# 063
snippet howManyUniquePathsSkipobstacles "(int)num=How many unique paths would there besome obstacles(vector<vector<int> > &obstacleGrid)" b
/* code by 王江 DC-Melo */
int uniquePathsWithObstacles(vector<vector<int> > &obstacleGrid) {
	int m = obstacleGrid.size();
	int n = obstacleGrid[0].size();
	vector<vector<int> > f(m, vector<int>(n));
	if(obstacleGrid[0][0] == 1) return 0;
	f[0][0] = 1;
	for(int i = 1; i < n; i++) {
		if(obstacleGrid[0][i] == 1) f[0][i] = 0;
		else    f[0][i] = f[0][i-1];
	}
	for(int i = 1; i < m; i++) {
		if(obstacleGrid[i][0] == 1) f[i][0] = 0;
		else    f[i][0] = f[i-1][0];
	}
	for(int i = 1; i < m; i++)
		for(int j = 1; j < n; j++) {
			if(obstacleGrid[i][j] == 1) f[i][j] = 0;
			else f[i][j] = f[i-1][j] + f[i][j-1];
		}
	return f[m-1][n-1];
}
$0
endsnippet

# 064
snippet minStepSumNumPathSum "(int)sum=find a path from top left to bottom right which minimizes the sum(vector<vector<int> > &grid)" b
/* code by 王江 DC-Melo */
int minPathSum(vector<vector<int> > &grid) {
	int m = grid.size();
	int n = grid[0].size();
	vector<vector<int> > DP(m, vector<int>(n));
	DP[0][0] = grid[0][0];
	for(int i = 1; i < n; i++) DP[0][i] = DP[0][i-1] + grid[0][i];
	for(int i = 1; i < m; i++) DP[i][0] = DP[i-1][0] + grid[i][0];
	for(int i = 1; i < m; i++)
		for(int j = 1; j < n; j++)
			DP[i-1][j] < DP[i][j-1] ? DP[i][j] = DP[i-1][j] + grid[i][j] : DP[i][j] = DP[i][j-1] + grid[i][j];
	return DP[m-1][n-1];
}
$0
endsnippet

# 065
snippet isValidNumber "(bool)is=Validate if a given string is numeric(sting s)" b
/* code by 王江 DC-Melo */
bool isNumber(string s) {
	int i=0;
	while (s[i] == ' ') ++i;
	while (s[i] == '+' || s[i] == '-') ++i;
	bool exp = false, space = false, point = false;
	bool number = false;
	while (s[i] != '\0') {
		if (isdigit(s[i])) {
			if (space) return false;
			else number = true;
		} else if (s[i] == '.') {
			if (!point && !space && !exp) { point = true; } 
			else { return false; }
		} else if (s[i] == 'e') {
			if (!exp && number && !space) {
				exp = true;
				number = false;
				while (s[i+1] == '+' || s[i+1] == '-') ++i;
			} else { return false; }
		} else if (s[i] == ' ') {
			if (!space) { space = true; }
		} else {
			return false;
		}
		++i;
	}
	return number;
}
$0
endsnippet

# 066
snippet addOneInArrayPlusOne "(vector<int>)Given a non-empty array(vector<int> &digits)" b
/* code by 王江 DC-Melo */
vector<int> plusOne(vector<int> &digits) {
	vector<int> answer;
	int c = 1;
	for (int i = digits.size() - 1; i >= 0; i--) {
		c += digits[i];
		answer.insert(answer.begin(), c % 10);
		c = c / 10;
	}
	if (c > 0) { answer.insert(answer.begin(), c); }
	return answer;
}
$0
endsnippet

# 067
snippet addBinaryString "(sting)sum=comment (string a, string b)" b
/* code by 王江 DC-Melo */
string addBinary(string a, string b) {
	string c;
	int flag=0;
	int lena = a.size();
	int lenb = b.size();
	int len = abs(lena-lenb);
	string append(len,'0');
	if(lena>lenb) {
		b = append + b;
		c.resize(lena,'0');
	} else {
		a = append + a;
		c.resize(lenb,'0');
	}
	for(int j=c.size()-1;j>=0;j--) {
		int current = (a[j]-'0') ^(b[j]-'0') ^flag;
		if((a[j]-'0') +(b[j]-'0') +flag >1) flag = 1;
		else flag = 0;
		c[j] = current+'0';
	}
	if(flag == 1) c = '1'+ c;
	return c;
}
$0
endsnippet

# 068
snippet textJustification "(vector<string>)characters and is fully (left and right) justified(vector<string> &words, int L)" b
/* code by 王江 DC-Melo */
public:
    vector<string> fullJustify(vector<string> &words, int L) {
        int start = 0;
        int size = words.size();
        int len = words[0].size();
        vector<string> ans;
        for(int i = 1 ; i < size ; ++i) {
            if(len + words[i].size() + 1 > L) {
                string result = addSpace(words, start , i , len , L);
                ans.push_back(result);
                start = i;
                len = words[i].size();
            } else { len += words[i].size() + 1; }
        }
        //procee last
        string result = addLast(words, start , size , L);
        ans.push_back(result);
        return ans;
    }
private:
    //[start,end)
    string addSpace(vector<string>& words , int start , int end ,  int len , int L) {
        int exspace = L - len;
        int cnt = end - start;
        string tmp = "";
        if(cnt == 1) {
            tmp = words[start];
            tmp.append(exspace , ' ');
        } else {
            int avespace = exspace / (cnt - 1);
            int reminder = exspace % (cnt - 1);
            for(int i = start ; i < end - 1 ; ++i) {
                tmp += words[i];
                tmp.append(avespace + 1 , ' ');
                if(reminder) {
                    tmp.append(1 , ' ');
                    reminder --;
                }
            }
            tmp += words[end-1];
        }
        return tmp;
    }
    string addLast(vector<string>& words , int start , int end , int L) {
        string tmp = words[start];
        for(int i = start + 1 ; i < end ; ++i) {
            tmp += " " + words[i];
        }
        if(tmp.size() < L) tmp.append(L - tmp.size() , ' ');
        return tmp;
    }
$0
endsnippet

# 069
snippet sqrtX "(int)sqrt=comment (int x)" b
/* code by 王江 DC-Melo */
int sqrt(int x) {
	double ans = x;
	while(abs(ans * ans - x) > 0.0001) ans = (ans + x / ans) / 2;
	return (int)ans;
}
$0
endsnippet

# 070
snippet climbingStairs "(int)ways=Each time you can either climb 1 or 2 steps to n stair(int n)" b
/* code by 王江 DC-Melo */
int climbStairs(int n) {
	if(n == 0) return 0;
	if(n == 1) return 1;
	if(n == 2) return 2;

	int sum[n];
	sum[0] = 1;
	sum[1] = 2;
	for(int i=2;i<n;i++) {
		sum[i] = sum[i-1]+sum[i-2];
	}
	return sum[n-1];
}
$0
endsnippet

# 072
snippet minOperationConvertWord1Toword2EditDistance "minimum number of operations required to convert word1 to word2(string word1, string word2)" b
/* code by 王江 DC-Melo */
int minDistance(string word1, string word2) {
	int row = word1.length() + 1;
	int col = word2.length() + 1;
	vector<vector<int> > f(row, vector<int>(col));
	for (int i = 0; i < row; i++) f[i][0] = i;
	for (int i = 0; i < col; i++) f[0][i] = i;
	for (int i = 1; i < row; i++)
		for (int j = 1; j < col; j++) {
			if (word1[i-1] == word2[j-1]) f[i][j] = f[i-1][j-1];
			else f[i][j] = f[i-1][j-1] + 1;
			f[i][j] = min(f[i][j], min(f[i-1][j]+1, f[i][j-1]+1));
		}
	return f[row-1][col-1];
}
$0
endsnippet

## 073
snippet setMatrixRowColumnZeroes "(void)if an element is 0 set its entire row and column to 0(vector<vector<int> > &matrix)" b
/* code by 王江 DC-Melo */
void setZeroes(vector<vector<int> > &matrix) {
	bool firstLine = false, firstRow = false;
	for(int i=0;i<matrix[0].size();i++) if(matrix[0][i] == 0) firstRow = true;
	for(int i=0;i<matrix.size();i++) if(matrix[i][0] == 0) firstLine = true;
	for(int i=1;i<matrix.size();i++) {
		for(int j=1;j<matrix[i].size();j++) {
			if(matrix[i][j] == 0) {
				matrix[0][j] = 0;
				matrix[i][0] = 0;
			}
		}
	}
	for(int i=1;i<matrix[0].size();i++) {
		if(matrix[0][i] == 0) {
			for(int j=0;j<matrix.size();j++) matrix[j][i] = 0;
		}
	}

	for(int i=1;i<matrix.size();i++) {
		if(matrix[i][0] == 0) {
			for(int j=0;j<matrix[i].size();j++) matrix[i][j] = 0;
		}
	}
	if(firstRow) for(int i=0;i<matrix[0].size();i++) matrix[0][i] = 0;
	if(firstLine) for(int i=0;i<matrix.size();i++) matrix[i][0] = 0;
}
$0
endsnippet

# 074
snippet existTargetInAscendingMatrix "(bool)exist=searches for a target in integer ascending matrix(vector<vector<int> > &matrix, int target)" b
/* code by 王江 DC-Melo */
int transform(vector<vector<int> > &matrix, int index) {
	return matrix[index/matrix[0].size()][index%matrix[0].size()];
}
int bSearch(vector<vector<int> > &matrix, int begin, int end, int target) {
	if(begin <= end) {
		int mid = (begin+end)/2;
		int temp = transform(matrix,mid);
		if(target == temp) return mid;
		else if(target < temp) return  bSearch(matrix,begin,mid-1,target);
		else return  bSearch(matrix,mid+1,end,target);
	} else return -1;
}
bool searchMatrix(vector<vector<int> > &matrix, int target) {
	if (bSearch(matrix,0,matrix.size()*matrix[0].size()-1,target) >= 0) return true;
	else return false;
}
$0
endsnippet

# 075
snippet sortColors "(void)sort colors as integer(int A[], int n)" b
/* code by 王江 DC-Melo */
void sortColors(int A[], int n) {
	int count[3] = {0};
	for(int i=0;i<n;i++) count[A[i]] ++;
	int index = 0;
	while(count[0]) {
		A[index] = 0;
		count[0]--;
		index++;
	}
	while(count[1]) {
		A[index] = 1;
		count[1]--;
		index++;
	}
	while(count[2]) {
		A[index] = 2;
		count[2]--;
		index++;
	}
}
$0
endsnippet

# 076
snippet minWindowSubstring "(string)find the minimum window in S which will contain all the characters in T(string S, string T)" b
/* code by 王江 DC-Melo */
#define INT_MAX 0x7fffffff
private:
    int count1[256];
    int count2[256];
public:
    string minWindow(string S, string T) {
        if (T.size() == 0 || S.size() == 0) return "";
        memset(count1, 0, sizeof(count1));
        memset(count2, 0, sizeof(count2));
        for(int i = 0; i < T.size(); i++) {
            count1[T[i]]++;
            count2[T[i]]++;
        }
        int count = T.size();
        int start = 0;
        int minSize = INT_MAX;
        int minStart;
        for(int end = 0; end < S.size(); end++) {
            if (count2[S[end]] > 0) {
                count1[S[end]]--;
                if (count1[S[end]] >= 0) count--;
            }
            if (count == 0) {
                while(true) {
                    if (count2[S[start]] > 0) {
                        if (count1[S[start]] < 0) count1[S[start]]++;
                        else break;
                    }
                    start++;
                }
                if (minSize > end - start + 1) {
                    minSize = end - start + 1;
                    minStart = start;
                }
            }
        }
      
        if (minSize == INT_MAX) return "";
        string ret(S, minStart, minSize);
        return ret;        
    }
$0
endsnippet

# 077
snippet combinations "Given two integers n and k, return all possible combinations of k numbers out of 1 ... n" b
/* code by 王江 DC-Melo */
vector<vector<int> > result;
vector<bool> flag;
void solve(vector<int> temp, int k) {
	if(k == 0) { result.push_back(temp); }
	else {
		for(int i=temp.empty()?1:temp.back()+1;i<flag.size();i++) {
			if(flag[i] == false) {
				flag[i] = true;
				temp.push_back(i);
				solve(temp,k-1);
				temp.erase(temp.end()-1);
				flag[i] = false;
			}
		}
	}
}
vector<vector<int> > combine(int n, int k) {
	flag.resize(n+1,false);
	solve(vector<int>(),k);
	return result;
}
$0
endsnippet

# 078
snippet subsets "(vector<vector<int> >)Given a set of distinct integers, S, return all possible subsets.(vector<int> &S)" b
/* code by 王江 DC-Melo */
vector<vector<int> > result;
vector<int> Str;
vector<bool> flag;
void solve(vector<int> temp, int f, int k) {
	if(k == 0) { result.push_back(temp); }
	else {
		for(int i=f;i<flag.size();i++) {
			if(flag[i] == false) {
				flag[i] = true;
				temp.push_back(Str[i]);
				solve(temp,i,k-1);
				temp.erase(temp.end()-1);
				flag[i] = false;
			}
		}
	}
}
vector<vector<int> > subsets(vector<int> &S) {
	flag.resize(S.size());
	sort(S.begin(),S.end());
	Str = S;
	for(int i=0;i<S.size()+1;i++) solve(vector<int>(),0,i);
	return result;
}
$0
endsnippet

# 079
snippet searchWordIn2DBoard "Given a 2D board and a list of words from the dictionary, find all words in the board" b
/* code by 王江 DC-Melo */
vector<vector<char> > brd;
vector<vector<bool> > flag;
string wrd;
bool isExist(int row, int line, int index) {
	if(index == wrd.size()) return true;
	else {
		if(row>=brd.size() || row<0 || line>= brd[0].size() || line<0) return false;
		if(flag[row][line] == true) return false;
		if(wrd[index] == brd[row][line]) {
			flag[row][line] = true;
			bool temp = ( isExist(row+1,line,index+1) 
				|| isExist(row,line+1,index+1)
				|| isExist(row-1,line,index+1)
				|| isExist(row,line-1,index+1));
			flag[row][line] = false;
			return temp;
		}
	}
	return false;
}
bool exist(vector<vector<char> > &board, string word) {
	brd = board;
	wrd = word;
	flag.resize(board.size(),vector<bool>(board[0].size(),false));
	for(int i=0;i<board.size();i++)
		for(int j=0;j<board[i].size();j++) { if(isExist(i,j,0)) return true; }
	return false;
}
$0
endsnippet

# 080
snippet removeFromSortedArrayKeepAtMostTwice "(int)Given an integer array nums sorted in non-decreasing order, remove some duplicates in-place such that each unique element appears at most twice(int A[], int n)" b
/* code by 王江 DC-Melo */
int removeDuplicates(int A[], int n) {
	if(n <= 0) return 0;
	int firstIndex = 0, secondIndex = 0;
	int curVal = A[0] , curCount = 0;
	for(int i=0;i<n;i++) {
		if(A[i] == curVal) {
			if(curCount<2) {
				A[firstIndex] = curVal;
				firstIndex++;
			}
			curCount++;
		} else {
			curVal = A[i];
			curCount = 1;
			A[firstIndex] = curVal;
			firstIndex++;
		}
	}
	return firstIndex;
}
$0
endsnippet

# 081
snippet searchElementInRotatedSortedArrayII "search element in sorted ascending order is rotated at some pivot unknown" b
/* code by 王江 DC-Melo */
bool search(int A[], int n, int target) {
	if(NULL == A || 0 == n) return false;
	int left = 0, right = n-1, mid = 0;
	while(left <= right) {
		mid = left+(right-left)/2;
		if(A[mid] == target) return true;
		bool isLeft = true;
		for(int i = left; i <= mid; ++i) if(A[i] > A[mid]) {
				isLeft = false;
				break;
			}
		if(isLeft) {
			if(A[left] <= target && target < A[mid]) right = mid - 1;
			else left = mid + 1;
		} else {
			if(A[mid] < target && target <= A[right]) left = mid + 1;
			else right = mid - 1;
		}
	}
	return false;
}
$0
endsnippet

# 082
snippet removeDuplicatesAllFromSortedListII "(ListNode *)Given a sorted linked list, delete all nodes that have duplicate numbers(ListNode *head)" b
/* code by 王江 DC-Melo */
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
ListNode *deleteDuplicates(ListNode *head) {
	ListNode** curNext = &head;
	ListNode* cur = head;
	while(NULL != cur) {
		ListNode* temp = cur;
		while(NULL != cur->next && cur->next->val == cur->val) cur = cur->next;
		if(cur == temp) {
			*curNext = temp;
			curNext = &(*curNext)->next;
		}
		cur = cur->next;
	}
	*curNext = NULL;
	return head;    
}
$0
endsnippet

# 083
snippet removeDuplicatesFromSortedList "(ListNode *)Given a sorted linked list, delete all duplicates such that each element appear only once(ListNode *head)" b
/* code by 王江 DC-Melo */
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
ListNode *deleteDuplicates(ListNode *head) {
	if(head == NULL) return head;
	ListNode *last = head;
	ListNode *temp = head->next;
	while(temp != NULL) {
		if(temp->val == last->val) {
			last->next = temp->next;
		} else {
			last = temp;
		}
		temp = temp->next;
	}
	return head;
}
$0
endsnippet

# 084
snippet findLargestRectangleinHistogram "(int)max=Largest Rectangle in Histogram(vector<int> &height)" b
/* code by 王江 DC-Melo */
int Max(int a, int b){return a > b ? a : b;}
int largestRectangleArea(vector<int> &height) {
	height.push_back(0);
	stack<int> stk;
	int i = 0;
	int maxArea = 0;
	while(i < height.size())
	{
		if(stk.empty() || height[stk.top()] <= height[i])
		{
			stk.push(i++);
		}
		else 
		{
			int t = stk.top();
			stk.pop();
			maxArea = Max(maxArea, height[t] * (stk.empty() ? i : i - stk.top() - 1));
		}
	}
	return maxArea;
}
$0
endsnippet

# 085
snippet maxiRectangleInMatrix "(int)max=find the largest rectangle containing only 1's and return its area.(vector<vector<char> > &matrix)" b
/* code by 王江 DC-Melo */
bool** rectangle;
int maximalRectangle(vector<vector<char> > &matrix) {
	if(matrix.size()==0||matrix[0].size()==0) return 0;
	int n = matrix.size();
	int m = matrix[0].size();
	rectangle = new bool*[n];
	int max=0;
	for(int i=0;i<n;i++) { rectangle[i] = new bool[m]; }
	for(int k=0;k<n;k++) {
		for(int l=0;l<m;l++) {
			rectangle[k][l]=(matrix[k][l]=='1');
			for(int i=k;i<n;i++) {
				bool end = false;
				for(int j=l;j<m;j++) {
					if(i==k&&j==l) {
						if(rectangle[i][j]) {
							int area = 1;
							if(area > max)
							max = area;
						} else {
							end = true;
							break;
						}
					} else if(i==k) {
						rectangle[i][j] = rectangle[i][j-1] && (matrix[i][j]=='1');
					} else if(j==l) {
						rectangle[i][j] = rectangle[i-1][j] && (matrix[i][j]=='1');
					} else {
						rectangle[i][j] = rectangle[i][j-1] && rectangle[i-1][j] && (matrix[i][j]=='1');
					}
					if(rectangle[i][j]) {
						int area = (i-k+1)*(j-l+1);
						if(area > max) max = area;
					} else {
						break;
					}
				}
				if(end) {
					break;
				}
			}
		}
	}
	return max;
}
$0
endsnippet

# 086
snippet partitionList "(ListNode *)Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.(ListNode *head, int x)" b
/* code by 王江 DC-Melo */
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
ListNode *partition(ListNode *head, int x) {
	ListNode *list1 = new ListNode(0);
	ListNode *first = list1;
	ListNode *list2 = new ListNode(0);
	ListNode *second = list2;
	while(head != NULL) {
		if(head->val < x) {
			first->next = head;
			first = first->next;
		} else {
			second->next = head;
			second = second->next;
		}
		head = head->next;
	}
	first->next = list2->next;
	second->next = NULL;
	return list1->next;
}
$0
endsnippet

# 087
snippet scrambleString "Given a string s1, we may represent it as a binary tree by partitioning it to two non-empty substrings recursively." b
/* code by 王江 DC-Melo */
bool isScramble(string s1, string s2) {
	int len = s1.length();
	if(len!=s2.length()) { return false; }
	if(len==0) { return true; }
	bool result[len][len][len];
	for(int i=0;i<len;++i) {
		for(int j=0;j<len;++j) {
			result[0][i][j] = (s1[i]==s2[j]);
		}
	}
	for(int k=2;k<=len;++k) {
		for(int i=len-k;i>=0;--i) {
		  for(int j=len-k;j>=0;--j) {
			  bool r = false;
			  for(int m=1;m<k && !r;++m) {
				  r = (result[m-1][i][j] && result[k-m-1][i+m][j+m]) || (result[m-1][i][j+k-m] && result[k-m-1][i+m][j]);
			  }
			  result[k-1][i][j] = r;
		  }
		}
	}
	return result[len-1][0][0];
}
$0
endsnippet

# 088
snippet mergeSortedArray "comment " b
/* code by 王江 DC-Melo */
void merge(int A[], int m, int B[], int n) {
	int i=0,j=0;
	int k=0;
	int C[m+n+1];
	while(i<m && j<n) {
		if(A[i]<B[j]) C[k++]=A[i++];
		else C[k++]=B[j++];
	}
	while(i<m) C[k++]=A[i++];
	while(j<n) C[k++]=B[j++];
	for(i=0;i<k;i++) A[i]=C[i];
}
$0
endsnippet

# 089
snippet grayCode "An n-bit gray code sequence is a sequence of 2n integers" b
/* code by 王江 DC-Melo */
vector<int> grayCode(int n) {
	vector<int> result;
	result.push_back(0);
	for(int i=0; i<n;i++) {
		int highest = 1<<i;
		int len = result.size();
		for(int i=len -1; i>=0; i--)
			result.push_back(highest+result[i]);
	}
	return result;
}
$0
endsnippet

# 090
snippet subsetsII "(vector<vector<int> >)=Given a collection of integers that might contain duplicates, nums, return all possible subsets(vector<int> &S)" b
/* code by 王江 DC-Melo */
    vector<vector<int> > v;
    vector<vector<int> > subsetsWithDup(vector<int> &S) {
        sort(S.begin(),S.end());
        generate(vector<int>(), S, 0);
        return v;
    }
    void generate(vector<int> res, vector<int> &S, int i) {
        if(i == S.size()) {
            for(int i = 0; i < v.size(); i++) {
                if(v[i] == res) { return; }
            }
            v.push_back(res);
            return;
        } else {
            generate(res, S, i+1);
            res.push_back(S[i]);
            generate(res, S, i+1);
        }
    }
$0
endsnippet

# 091
snippet decodeWays "comment " b
/* code by 王江 DC-Melo */

$0
endsnippet

# 092
snippet reverseLinkedListWindowMN "Reverse a linked list from position m to n. Do it in-place and in one-pass." b
/* code by 王江 DC-Melo */
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
ListNode *reverseBetween(ListNode *head, int m, int n) {
	if (head == NULL) return NULL;
	ListNode *q = NULL;
	ListNode *p = head;
	for(int i = 0; i < m - 1; i++) {
		q = p;
		p = p->next;
	}
	ListNode *end = p;
	ListNode *pPre = p;
	p = p->next;
	for(int i = m + 1; i <= n; i++) {
		ListNode *pNext = p->next;
		p->next = pPre;
		pPre = p;
		p = pNext;
	}
	end->next = p;
	if (q) q->next = pPre;
	else head = pPre;
	return head;
}
$0
endsnippet

# 093
snippet restoreIPAddresses "Given a string containing only digits, restore it by returning all possible valid IP address combinations." b
/* code by 王江 DC-Melo */
private:
    vector<string> ret;
    int pos[4];
public:
    bool check(string &s, int beg, int end) {
        string ip(s, beg, end - beg + 1);
        if (ip.size() == 1) return "0" <= ip && ip <= "9";
        else if (ip.size() == 2) return "10" <= ip && ip <= "99";
        else if (ip.size() == 3) return "100" <= ip && ip <= "255";
        else return false;
    }
    void dfs(int dep, int maxDep, string &s, int start) {
        if (dep == maxDep) {
            if (start == s.size()) {
                int beg = 0;
                string addr;
                for(int i = 0; i < maxDep; i++) {
                    string ip(s, beg, pos[i] - beg + 1);
                    beg = pos[i] + 1;
                    addr += i == 0 ? ip : "." + ip;
                }
                ret.push_back(addr);    
            }
            return;
        }
        for(int i = start; i < s.size(); i++)
            if (check(s, start, i)) {
                pos[dep] = i;
                dfs(dep + 1, maxDep, s, i + 1);               
            }
    }
    vector<string> restoreIpAddresses(string s) {
        ret.clear();
        dfs(0, 4, s, 0);
        return ret;
    }
$0
endsnippet

# 094
snippet binaryTreeInorderTraversal "Given a binary tree, return the inorder traversal of its nodes’ values." b
/* code by 王江 DC-Melo */
/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
    vector<int> result;
    void dfs(TreeNode *root) {
        if(root == NULL) return;
        else {
            dfs(root->left);
            result.push_back(root->val);
            dfs(root->right);
        }
    }
    vector<int> inorderTraversal(TreeNode *root) {
        dfs(root);
        return result;
    }
$0
endsnippet

# 095
snippet uniqueBinarySearchTreesII "Given an integer n, generate all structurally unique BST's (binary search trees) that store values 1 ... n." b
/* code by 王江 DC-Melo */
/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
vector<TreeNode *> generateTrees(int n) { return createTree(1,n); }
vector<TreeNode *> createTree(int start, int end) {
	vector<TreeNode *> results;
	if(start>end) {
		results.push_back(NULL);
		return results;
	}
	for(int k=start;k<=end;k++) {
		vector<TreeNode *> left = createTree(start,k-1);
		vector<TreeNode *> right = createTree(k+1,end);
		for(int i=0;i<left.size();i++) {
			for(int j=0;j<right.size();j++) {
				TreeNode * root = new TreeNode(k);
				root->left = left[i];
				root->right = right[j];
				results.push_back(root);
			}
		}
	}
	return results;
}
void dfs(TreeNode *root) {
	if(root == NULL) return;
	else {
		cout<< root->val << " ";
		dfs(root->left);     
		dfs(root->right);
	}
}
$0
endsnippet

# 096
snippet uniqueBinarySearchTrees "Given n, how many structurally unique BST's (binary search trees) that store values 1 ... n?" b
/* code by 王江 DC-Melo */
int numTrees(int n) {
	if(n<=0) return 0;
	vector<int> res(n+1);
	res[0] = 1;
	res[1] = 1;
	for(int i=2;i<=n;i++) {
		for(int j=0;j<i;j++) {
			res[i] += res[j]*res[i-j-1];
		}
	}
	return res[n];
}
$0
endsnippet

# 097
snippet isInterleavingString "Given s1, s2, s3, find whether s3 is formed by the interleaving of s1 and s2." b
/* code by 王江 DC-Melo */
bool isInterleave(string s1, string s2, string s3) {
	if (s1.size() + s2.size() != s3.size()) { return false; }
	bool a[1000][1000];
	a[0][0] = true;
	for (int i = 1; i <= s1.size(); ++i) {
		a[i][0] = a[i-1][0] && (s1[i-1] == s3[i-1]);
	}
	for (int i = 1; i <= s2.size(); ++i) {
		a[0][i] = a[0][i-1] && (s2[i-1] == s3[i-1]);
	}
	for (int i = 1; i <= s1.size(); ++i) {
		for (int j = 1; j <= s2.size(); ++j) {
			a[i][j] = (a[i-1][j] && s1[i-1] == s3[i+j-1]) || (a[i][j-1] && s2[j-1] == s3[i+j-1]);
		}
	}
	return a[s1.size()][s2.size()];
}
$0
endsnippet

# 098
snippet isValidateBinarySearchTree "Given the root of a binary tree, determine if it is a valid binary search tree (BST)." b
/* code by 王江 DC-Melo */
/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
int tmp;
bool tag;
bool key;
bool isValidBST(TreeNode *root) {
	tag = false;
	key = true;
	check(root);
	return key;
}
void check(TreeNode *root) {
	if(key == false) return;
	if(root == NULL) return;
	check(root->left);
	if(tag == false) {
		tmp = root->val;
		tag = true;
	} else {
		if(root->val <= tmp) key = false;
		else tmp = root->val;
	}
	check(root->right);
}
$0
endsnippet

# 099
snippet recoverBinarySearchTree "Two elements of a binary search tree (BST) are swapped by mistake" b
/* code by 王江 DC-Melo */
/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
TreeNode *node1;
TreeNode *node2;
TreeNode *pre;
void recoverTree(TreeNode *root) {
	node1 = node2 = pre = NULL;
	findout(root);
	swap(node1->val, node2->val);
	return;
}
void findout(TreeNode *root) {
	if (root->left != NULL) findout(root->left);
	if (pre != NULL) {
		if (pre->val > root->val) {
			if (node1 == NULL) node1 = pre, node2 = root;
			else node2 = root;
		}
	}
	pre = root;
	if (root->right != NULL) findout(root->right);
}
$0
endsnippet

# 100
snippet isSameTree "Given two binary trees, write a function to check if they are the same or not" b
/* code by 王江 DC-Melo */
/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
bool dfs(TreeNode *p, TreeNode *q) {
	if( p == NULL && q == NULL) return true;
	else if( p == NULL || q == NULL) return false;
	else {
		if( p->val == q->val) return dfs(p->left,q->left) && dfs(p->right,q->right);
	}
	return false;
}
bool isSameTree(TreeNode *p, TreeNode *q) {
	return dfs(p,q);
}
$0
endsnippet

# 101
snippet isSymmetricTree "Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center)." b
/* code by 王江 DC-Melo */
/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
bool dfs(TreeNode *left,TreeNode *right) {
	if(!left && !right) return true;
	if((left && !right) || (!left && right) || (left->val!=right->val)) return false;
	return dfs(left->left,right->right) && dfs(left->right,right->left);
}
bool isSymmetric(TreeNode *root) {
	if(root==NULL || (!root->left && !root->right)) return true;
	return dfs(root->left,root->right);
}
$0
endsnippet

# 102
snippet binaryTreeLevelOrderTraversal "comment " b
/* code by 王江 DC-Melo */

/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */

class Solution 
{
public:
    vector<vector<int> > levelOrder(TreeNode *root) 
    {
        vector<vector<int> > result;
        vector<int> temp;
        queue<TreeNode *> q;

        int count = 1;
        int nextCount = 0;

        if(root == NULL)
            return result;

        q.push(root);
        while(!q.empty())
        {
            temp.push_back(q.front()->val);
            count--;

            if(q.front()->left)
            {
                q.push(q.front()->left);
                nextCount++;
            }
            if(q.front()->right)
            {
                q.push(q.front()->right);
                nextCount++;
            }
            q.pop();

            if(count == 0)
            {
                result.push_back(temp);
                temp.resize(0);
                count = nextCount;
                nextCount = 0;
            }
        }
        return result;
    }
$0
endsnippet

# 103
snippet zTraversalBinaryTree "(vector<vector<int> >)Binary Tree Zigzag Level Order Traversal(TreeNode *root)" b
/* code by 王江 DC-Melo */
/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
vector<vector<int> > zigzagLevelOrder(TreeNode *root) {
vector<vector<int> >result;
if (!root) return result;
vector<int>vec;
queue<TreeNode*>q1;
TreeNode *temp = root;
enum Dir{L,R};
Dir dir = L;
q1.push(root);

while (!q1.empty()) {
	queue<TreeNode *>q2;
	while (!q1.empty()) {
		temp = q1.front();
		q1.pop();
		if (temp->left)
			q2.push(temp->left);
		if (temp->right)
			q2.push(temp->right);
		vec.push_back(temp->val);
	}
	if (dir == R) {
		reverse(vec.begin(), vec.end());
		dir = L;
	} else dir = R;
	result.push_back(vec);
	vec.clear();
	q1 = q2;
}
return result;
}
$0
endsnippet

# 104
snippet maximumDepthOfBinaryTree "(int)Given a binary tree, find its maximum depth.(TreeNode *root)" b
/* code by 王江 DC-Melo */
/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution 
{
public:
    int maxDepth(TreeNode *root) {
        if(root == NULL) return 0;
        else return max(maxDepth(root->left),maxDepth(root->right))+1;
    }
$0
endsnippet

# 105
snippet constructBinaryTreefromPreorderAndInorderTraversal "(TreeNode *)Given preorder and inorder traversal of a tree, construct the binary tree.(vector<int> &preorder, vector<int> &inorder)" b
/* code by 王江 DC-Melo */

/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution 
{
public:
    vector<int> preorder;
    vector<int> inorder;
    TreeNode *construct(vector<int>::iterator preIte, vector<int>::iterator leftIte, vector<int>::iterator rightIte)
    {
        TreeNode *node;
        if(leftIte == rightIte)
        {
            return NULL;
        }
        else
        {
            node = new TreeNode(*preIte);
            vector<int>::iterator midIte = find(leftIte,rightIte,*preIte);
            if(midIte != inorder.end())
            {
                node->left = construct(preIte+1,leftIte,midIte);
                node->right = construct(preIte+(midIte-leftIte)+1,midIte+1,rightIte);
            }
        }
        return node;
    }

    TreeNode *buildTree(vector<int> &preorder, vector<int> &inorder) 
    {
        this->preorder = preorder;
        this->inorder = inorder;
        return construct(preorder.begin(),inorder.begin(),inorder.end());
    }
$0
endsnippet

# 106
snippet constructBinaryTreeFromInorderAndPostorderTraversal "Given inorder and postorder traversal of a tree, construct the binary tree." b
/* code by 王江 DC-Melo */

/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution 
{
public:
    vector<int> inorder;
    vector<int> postorder;
    TreeNode *construct(vector<int>::iterator postIte, vector<int>::iterator leftIte, vector<int>::iterator rightIte)
    {
        TreeNode *node;
        if(leftIte == rightIte)
        {
            return NULL;
        }
        else
        {
            node = new TreeNode(*postIte);
            vector<int>::iterator midIte = find(leftIte,rightIte,*postIte);
            if(midIte != inorder.end())
            {
                node->left = construct(postIte-(rightIte-midIte),leftIte,midIte);
                node->right = construct(postIte-1,midIte+1,rightIte);
            }
        }
        return node;
    }

    TreeNode *buildTree(vector<int> &inorder, vector<int> &postorder) 
    {
        this->inorder = inorder;
        this->postorder = postorder;
        return construct(postorder.end()-1,inorder.begin(),inorder.end());
    }
$0
endsnippet

# 107
snippet binaryTreeLevelOrderTraversalII "eturn the bottom-up level order traversal of its nodes values" b
/* code by 王江 DC-Melo */

/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution 
{
public:
    vector<vector<int> > levelOrderBottom(TreeNode *root) {
        vector<vector<int> > result;
        vector<int> temp;
        queue<TreeNode *> q;
        int count = 1;
        int nextCount = 0;
        if(root == NULL) return result;
        q.push(root);
        while(!q.empty()) {
            temp.push_back(q.front()->val);
            count--;

            if(q.front()->left) {
                q.push(q.front()->left);
                nextCount++;
            }
            if(q.front()->right) {
                q.push(q.front()->right);
                nextCount++;
            }
            q.pop();
            if(count == 0) {
                result.push_back(temp);
                temp.resize(0);
                count = nextCount;
                nextCount = 0;
            }
        }
        for(int i=0,j=result.size()-1;i<j;i++,j--) swap(result[i],result[j]);
        return result;
    }
$0
endsnippet

# 108
snippet convertSortedArrayToBinarySearchTree "convert it to a height balanced BST." b
/* code by 王江 DC-Melo */

/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
    TreeNode* createTree(vector<int> &num,int left, int right) {
        if(left > right) return NULL;
        int mid = (left+right)/2;
        TreeNode *leftNode = createTree(num, left, mid - 1);
        TreeNode *rightNode = createTree(num, mid + 1, right);
        TreeNode *node = new TreeNode(num[mid]);
        node->left = leftNode;
        node->right = rightNode;
        return node;
    }
    TreeNode *sortedArrayToBST(vector<int> &num) { return createTree(num,0,num.size()-1); }
$0
endsnippet

# 109
snippet convertSortedListToBinarySearchTree "convert linked list to a height balanced BST." b
/* code by 王江 DC-Melo */

/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */

    TreeNode* createTree(vector<int> &num,int left, int right) {
        if(left > right) return NULL;
        int mid = (left+right)/2;
        TreeNode *leftNode = createTree(num, left, mid - 1);
        TreeNode *rightNode = createTree(num, mid + 1, right);
        TreeNode *node = new TreeNode(num[mid]);
        node->left = leftNode;
        node->right = rightNode;
        return node;
    }

    TreeNode *sortedListToBST(ListNode *head) {
        vector<int> num;
        while(head!=NULL) {
            num.push_back(head->val);
            head = head->next;
        }
        return createTree(num,0,num.size()-1);
    }
$0
endsnippet

# 110
snippet isBalancedBinaryTree "(bool)Given a binary tree, determine if it is height-balanced.(TreeNode *root)" b
/* code by 王江 DC-Melo */
/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
int isBalancedUtil(TreeNode* root, bool& isValid) {
	if(root == NULL) return 0;
	if(!isValid) return -1;
	int leftHeight = isBalancedUtil(root->left, isValid);
	int rightHeight = isBalancedUtil(root->right, isValid);
	if(abs(leftHeight-rightHeight) > 1) isValid = false;
	return max(leftHeight, rightHeight)+1;
}
bool isBalanced(TreeNode *root) {
	bool ans = true;
	isBalancedUtil(root, ans);
	return ans;
}
$0
endsnippet

# 111
snippet minimumDepthOfBinaryTree "Given a binary tree, find its minimum depth" b
/* code by 王江 DC-Melo */

/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
int minDepth(TreeNode *root) {
	if(root == NULL) return 0;
  
	if(root->left == NULL) return minDepth(root->right)+1;
	else if(root->right == NULL) return minDepth(root->left)+1;
	else return min(minDepth(root->left), minDepth(root->right))+1;
}
$0
endsnippet

# 112
snippet findPathSumOfTree "he tree has a root-to-leaf path such that adding up all the values" b
/* code by 王江 DC-Melo */

/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
bool dfs(TreeNode *node, int sum, int curSum) {
	if (node == NULL) return false;
	if (node->left == NULL && node->right == NULL) return curSum + node->val == sum;
	return dfs(node->left, sum, curSum + node->val) || dfs(node->right, sum, curSum + node->val);
}
bool hasPathSum(TreeNode *root, int sum) { return dfs(root, sum, 0); }
$0
endsnippet

# 113
snippet findAllPathSumII "where each path's sum equals the given sum." b
/* code by 王江 DC-Melo */

/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
vector<vector<int> > result;
void dfs(TreeNode *node, int sum, vector<int> curPath, int curSum) {
	if (node == NULL) return;
	curPath.push_back(node->val);
	if (node->left == NULL && node->right == NULL) {
		if(curSum + node->val == sum) result.push_back(curPath);
		return;
	}
	dfs(node->left, sum, curPath, curSum + node->val);
	dfs(node->right, sum, curPath, curSum + node->val);
}
vector<vector<int> > pathSum(TreeNode *root, int sum) {
	vector<int> curPath;
	dfs(root,sum,curPath,0);
	return result;
}
$0
endsnippet

# 114
snippet convertBinaryTreeToLinkedList "Given a binary tree, flatten it to a linked list in-place." b
/* code by 王江 DC-Melo */

/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
TreeNode *pre;
Solution() {
	pre = NULL;
}
void flatten(TreeNode *root) {
	if(root==NULL) return;
	TreeNode *lastright=root->right;
	if(pre) {
		pre->left=NULL;
		pre->right=root;
	}
	pre=root;
	flatten(root->left);
	flatten(lastright);
}
$0
endsnippet

# 115
snippet countDistinctSubsequences "Given a string S and a string T, count the number of distinct subsequences of T in S." b
/* code by 王江 DC-Melo */

int numDistinct(string S, string T) {
	vector<vector<int> > cnt(T.length()+1,vector<int>(S.length()+1));
	for(int j=0; j<S.length(); j++) {
		cnt[0][j] = 1;
	}
	for(int i=1; i<T.length(); i++) {
		cnt[i][0] = 0;
	}
	for(int i=1; i<=T.length(); i++) {
		for(int j=1; j<=S.length(); j++) {
			if(T[i-1] != S[j-1]) {
				cnt[i][j] = cnt[i][j-1];    // The old way to match
			} else {    
				// Match, it allows us to have a new way to match
				cnt[i][j] = cnt[i][j-1] + cnt[i-1][j-1];    // old way + new way
			}
		}
	}
	return cnt[T.length()][S.length()];
}
$0
endsnippet

# 116
snippet populatingNextRightPointersInEachNode "Populate each next pointer to point to its next right node " b
/* code by 王江 DC-Melo */

/**
 * Definition for binary tree with next pointer.
 * struct TreeLinkNode {
 *  int val;
 *  TreeLinkNode *left, *right, *next;
 *  TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) {}
 * };
 */
void connect(TreeLinkNode *root) {
	if(root == NULL || root->left == NULL) return;
	TreeLinkNode *p = root;
	while(p != NULL) {
		p->left->next = p->right;
		if(p->next) p->right->next = p->next->left;
		p = p->next;
	}
	connect(root->left);
}
$0
endsnippet

# 117
snippet populatingNextRightPointersInEachNodeII "Follow up for problem Populating Next Right Pointers in Each Node." b
/* code by 王江 DC-Melo */

/**
 * Definition for binary tree with next pointer.
 * struct TreeLinkNode {
 *  int val;
 *  TreeLinkNode *left, *right, *next;
 *  TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) {}
 * };
 */
void broadSearch(TreeLinkNode* queueS) {
	if(queueS == NULL) return;
	TreeLinkNode* newQueueH = NULL;
	TreeLinkNode* newQueueT = NULL;
	while(queueS) {
		if(queueS->left) {
			if(newQueueH == NULL) newQueueH = queueS->left;
			if(newQueueT == NULL) newQueueT = queueS->left;
			else{
				newQueueT->next = queueS->left;
				newQueueT = queueS->left;
			}
		}
		if(queueS->right) {
			if(newQueueH == NULL) newQueueH = queueS->right;
			if(newQueueT == NULL) newQueueT = queueS->right;
			else{
				newQueueT->next = queueS->right;
				newQueueT = queueS->right;
			}

		}
		queueS = queueS->next;
	}
	broadSearch(newQueueH );
}
void connect(TreeLinkNode *root) {
	TreeLinkNode* queueS = root;
	broadSearch(queueS);
}
$0
endsnippet

# 118
snippet pascalsTriangle "Given a non-negative integer numRows, generate the first numRows of Pascal’s triangle." b
/* code by 王江 DC-Melo */
vector<vector<int> > generate(int numRows) {
	vector<vector<int> > result;
	if(numRows == 0) return result;
	vector<int> temp;
	temp.push_back(1);
	result.push_back(temp);
	if(numRows == 1) return result;
	temp.push_back(1);
	result.push_back(temp);
	if(numRows == 2) return result;
	for(int i=2;i<numRows;i++) {
		vector<int> temp;
		temp.push_back(1);
		for(int j=0;j<i-1;j++) {
			temp.push_back(result[i-1][j] + result[i-1][j+1]);
		}
		temp.push_back(1);
		result.push_back(temp);
	}
	return result;
}
$0
endsnippet

# 119
snippet pascalsTriangleII "Given a non-negative index k where k ≤ 33, return the kth index row of the Pascal's triangle." b
/* code by 王江 DC-Melo */
vector<int> getRow(int rowIndex) {
	vector<vector<int> > result;
	vector<int> temp;
	temp.push_back(1);
	result.push_back(temp);
	if(rowIndex == 0) return result[0];
	temp.push_back(1);
	result.push_back(temp);
	if(rowIndex == 1) return result[1];
	for(int i=2;i<rowIndex+1;i++) {
		vector<int> temp;
		temp.push_back(1);
		for(int j=0;j<i-1;j++) {
			temp.push_back(result[i-1][j] + result[i-1][j+1]);
		}
		temp.push_back(1);
		result.push_back(temp);
	}
	return result[rowIndex];
}
$0
endsnippet

# 120
snippet minimumPathSumFromTopToBottomTriangle "Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below." b
/* code by 王江 DC-Melo */
int minimumTotal(vector<vector<int> > &triangle) {
	vector< vector<int> >::size_type length = triangle.size();
	if(length == 0){ return 0; }
	int i, j;
	for(i=1;i<length;i++) {
		vector<int>::size_type length_inner = triangle[i].size();
		for(j=0;j<length_inner;j++) {
			if(j == 0) {
				triangle[i][j] = triangle[i][j] + triangle[i-1][j];
			} else if(j == length_inner - 1) {
				triangle[i][j] = triangle[i][j] + triangle[i-1][j-1];
			} else {
				triangle[i][j] = (triangle[i][j] + triangle[i-1][j-1] < triangle[i][j] + triangle[i-1][j] ? triangle[i][j] + triangle[i-1][j-1]:triangle[i][j] + triangle[i-1][j]);
			}
		}
	}
	int min_path = triangle[length-1][0];
	for(i=1;i<triangle[length-1].size();i++) {
		min_path = (min_path < triangle[length-1][i]?min_path:triangle[length-1][i]);
	}
	return min_path;
}
$0
endsnippet

# 121
snippet maximumProfitBestTimeToBuyAndSellStock "Design an algorithm to find the maximum profit" b
/* code by 王江 DC-Melo */
int maxProfit(vector<int>& prices) {
	if(prices.size() == 0) return 0;
	int low = prices[0];
	int ans = 0;
	for(int i=1; i<prices.size(); i++) {
	  if(prices[i] < low) low = prices[i];
	  else if(prices[i] - low > ans) ans = prices[i] - low;
	}
	return ans;
}
$0
endsnippet

# 122
snippet maximumProfitBestTimeToBuyAndSellStockII "design an algorithm to find the maximum profit." b
/* code by 王江 DC-Melo */
    int maxProfit(vector<int> &prices) {
        int m = prices.size();
        if(m == 0) return 0;
        int ret = 0;
        int buy = prices[0];
        int last = prices[0];
        for(int i = 1; i < m; i ++) {
            if(prices[i] < last) {
                ret += (last - buy);
                buy = prices[i];
            }
            last = prices[i];
        }
        ret += (last - buy);
        return ret;
    }
$0
endsnippet

# 123
snippet maximumProfitBestTimeToBuyAndSellStockIII "design an algorithm to find the maximum profit." b
/* code by 王江 DC-Melo */
int maxProfit(vector<int> &prices) {
	int size = prices.size();
	if (size == 0) return 0;
	vector<int> f1(size);
	vector<int> f2(size);
	int minV = prices[0];
	for (int i = 1; i < size; i++) {
		minV = std::min(minV, prices[i]);
		f1[i] = std::max(f1[i-1], prices[i] - minV);
	}
	int maxV = prices[size-1];
	f2[size-1] = 0;
	for (int i = size-2; i >= 0; i--) {
		maxV = std::max(maxV, prices[i]);
		f2[i] = std::max(f2[i+1], maxV - prices[i]);
	}
	int sum = 0;
	for (int i = 0; i < size; i++) sum = std::max(sum, f1[i] + f2[i]);
	return sum;
}
$0
endsnippet

# 124
snippet maximumSumbinaryTreeMaximumPathSum "Given a non-empty binary tree, find the maximum path sum." b
/* code by 王江 DC-Melo */

/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */

#define INT_MAX ((int)(~0U>>1))
#define INT_MIN (-INT_MAX - 1)

class Solution 
{
public:
    int max_sum;
    int max_path_sum(TreeNode*root) {
        if (!root) return 0;
        int i_left = max_path_sum(root->left);
        int i_right = max_path_sum(root->right);
        int sum = root->val;
        if (i_left > 0) sum += i_left;
        if (i_right > 0) sum += i_right;
        max_sum = max(sum,max_sum);
        return (max(i_left, i_right) > 0) ? (max(i_left, i_right) + root->val) : root->val;
    }
    int maxPathSum(TreeNode *root) {
        max_sum = INT_MIN;
        if (!root) return 0;
        max_path_sum(root);
        return max_sum;
    }
}
$0
endsnippet

# 125
snippet isValidPalindrome "Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases." b
/* code by 王江 DC-Melo */
    bool isPalindrome(string s) {
        if(s.length() == 0) return true;
        for(int i=0,j=s.length()-1;i<j;i++,j--) {
            while( (s[i]<'0' 
                || (s[i]>'9' && s[i]<'A') 
                || (s[i]>'Z' && s[i]<'a')
                || (s[i]>'z') )
                && i<j )
                i++;
            while((s[j]<'0' 
                || (s[j]>'9' && s[j]<'A') 
                || (s[j]>'Z' && s[j]<'a')
                || (s[j]>'z') )
                && i<j )
                j--;
            if(s[i] != s[j]
                && s[i]-'A' != s[j]-'a' 
                && s[i]-'a' != s[j]-'A')
                return false;
        }
        return true;
    }
$0
endsnippet

# 126
snippet shortestTransformationWordLadderII "find all shortest transformation sequence(s) from start to end" b
/* code by 王江 DC-Melo */
vector<vector<string>> findLadders(string start, string end, unordered_set<string> &dict) {
	  vector<vector<string> >ans;
	  if(start == end) return ans;
	  unordered_set<string>current , next;
	  unordered_set<string> flag;
	  unordered_map<string,vector<string> > father;
	  current.insert(start);
	  bool found = false;
	  while(!current.empty() && !found) {
		  for(const auto &x : current) { flag.insert(x); }
		  for(auto x : current) {
			  for(int i = 0 ; i < x.size() ; ++i) {
				  for(int j = 'a' ; j <= 'z' ; ++j) {
					  if(x[i] == j) continue;
					  string tmp = x;
					  tmp[i] = j;
					  if(tmp == end) found = true;
					  if(dict.find(tmp) != dict.end() && flag.find(tmp) == flag.end()) {
						  next.insert(tmp);
						  father[tmp].push_back(x);
					  }
				 }
			  }
		  }
		  current.clear();
		  swap(current, next);
	  }
	  if(found) {
		  vector<string> c;
		  dfs(ans , father , c , start , end);
	  }
	  return ans;
}
void dfs(vector<vector<string> >&ans, 
		 unordered_map<string,vector<string> >& father ,
		 vector<string>& c , 
		 string& start ,
		 string& now) {
	c.push_back(now);
	if(now == start) {
		ans.push_back(c);
		reverse(ans.back().begin() , ans.back().end());
		c.pop_back();
		return;
	}
	auto que = father.find(now) -> second;
	for(auto& x : que) {
		dfs(ans , father , c , start , x);
	}
	c.pop_back();
}
$0
endsnippet

# 127
snippet shortestTransformationwordLadder " find the length of shortest transformation sequence from beginWord to endWord" b
/* code by 王江 DC-Melo */
int ladderLength(string start, string end, unordered_set<string> &dict) {
	if(start.size() != end.size()) return 0;
	if(start.empty() || end.empty())return 0;
	queue<string> path;
	path.push(start);
	int level = 1;
	int count = 1;
	dict.erase(start);
	while(dict.size() > 0 && !path.empty()) {
		string curword = path.front();
		path.pop();count--;
		for(int i = 0; i < curword.size(); i++) {
			string tmp = curword;
			for(char j='a'; j<='z'; j++) {
				if(tmp[i]==j)continue;
				tmp[i] = j;
				if(tmp==end)return level+1;
				if(dict.find(tmp) != dict.end()) path.push(tmp);
				dict.erase(tmp);
			}
		}
		if(count==0) {
			count = path.size();
			level++;
		}
	}
	return 0;
}
$0
endsnippet

# 128
snippet longestConsecutiveSequence "find the length of the longest consecutive elements sequence" b
/* code by 王江 DC-Melo */
int longestConsecutive(vector<int> &num) {
	map<int, int> hmap;
	hmap.clear();
	int n = num.size();
	for(int i=0; i<n; i++) {
		hmap.insert(pair<int, int>(num[i], i));
	}
	int ans=0, cnt=0;
	map<int, int>::iterator it;
	for(int i=0; i<num.size(); i++) {
		int cur = num[i];
		it = hmap.find(num[i]);
		cnt++;
		if(it!=hmap.end()) {
			map<int, int>::iterator iter;
			while(1) {
				iter = hmap.find(++cur);
				if(iter==hmap.end()) break;
				cnt++;    
				hmap.erase(iter);
			}
			cur=num[i];
			while(1) {
				iter = hmap.find(--cur);
				if(iter==hmap.end()) break;
				cnt++;    
				hmap.erase(iter);
			}
			if(ans<cnt)
				ans = cnt;           
			cnt=0;
		}
		cnt=0;
	}
	return ans;
}
$0
endsnippet

# 129
snippet sumRootToLeafNumbers "Find the total sum of all root-to-leaf numbers" b
/* code by 王江 DC-Melo */
int result;
void dfs(TreeNode *node,int tempVal) {
	tempVal = tempVal*10 + node->val;
	if(node->left || node->right) {
		if(node->left) dfs(node->left,tempVal);
		if(node->right) dfs(node->right,tempVal);
	}
	else result += tempVal;
}
int sumNumbers(TreeNode *root) {
	result = 0;
	if(root) dfs(root,0);
	else return 0;
	return result;
}
$0
endsnippet

# 130
snippet repalceSurroundedRegions "flipping all'O's into'X's in that surrounded region" b
/* code by 王江 DC-Melo */
void process(int i,int j,vector<vector<char> >& board) {
	int m=board.size();
	int n=board[0].size();
	typedef pair<int,int> point;
	queue<point> Q;
	Q.push(point(i,j));
	board[i][j]='E';
	while(!Q.empty()) {
		point tmp=Q.front();
		Q.pop();
		int x=tmp.first,y=tmp.second;
		//extending
		if (x!=0&&board[x-1][y]=='O') {
			Q.push(point(x-1,y));
			board[x-1][y]='E';   //extended;
		}
		if (x!=m-1&&board[x+1][y]=='O') {
			Q.push(point(x+1,y));
			board[x+1][y]='E';   //extended;
		}
		if (y!=0&&board[x][y-1]=='O') {
			Q.push(point(x,y-1));
			board[x][y-1]='E';   //extended;
		}
		if (y!=n-1&&board[x][y+1]=='O') {
			Q.push(point(x,y+1));
			board[x][y+1]='E';   //extended;
		}
	}
}
void solve(vector<vector<char> >& board) {
	int m=board.size();
	if (m==0) return;
	int n=board[0].size();
	int i,j;
	for(i=0;i<m;i++) {
		if (board[i][0]=='O') process(i,0,board);
		if (board[i][n-1]=='O') process(i,n-1,board);
	}
	for(j=0;j<n;j++) {
		if (board[0][j]=='O') process(0,j,board);
		if (board[m-1][j]=='O') process(m-1,j,board);
	}
	for(i=0;i<m;i++)
		for(j=0;j<n;j++) {
			if(board[i][j]=='O') board[i][j]='X';
			else if (board[i][j]=='E') board[i][j]='O';
		}
}   
$0
endsnippet

# 131
snippet palindromePartitioning "Given a string s, partition s such that every substring of the partition is a palindrome." b
/* code by 王江 DC-Melo */
class Solution 
{
public:
    string s;
    vector<vector<bool> > DP;
    vector<vector<string> > result;
    void solve(int index, vector<string> tempResult) {
        if(index == s.size()) result.push_back(tempResult);
        else {
            for(int i = index;i<DP[index].size();i++) {
                if(DP[index][i]) {
                    tempResult.push_back(s.substr(index,i-index+1));
                    solve(i+1,tempResult);
                    tempResult.pop_back();
                }
            }
        }
    }

    vector<vector<string> > partition(string s) {
        DP.resize(s.size(),vector<bool>(s.size(),false));
        for(int i=0;i<DP.size();i++) {
            DP[i][i]=true;
            if( i<DP.size()-1 && s.at(i) == s.at(i+1) ) DP[i][i+1] = true;
        }
        for(int len=3;len<=s.size();len++) {
            for(int i=0;i+len<=s.size();i++) {
                int j=i+len-1;
                if( DP[i+1][j-1] && s[i] == s[j] ) {
                    DP[i][j]=true;
                }
            }
        }
        this->s = s;
        solve(0,vector<string>());
        return result;
    }
}
$0
endsnippet

# 132
snippet minimumCutsPalindromePartitioningII "Return the minimum cuts needed for a palindrome partitioning of s." b
/* code by 王江 DC-Melo */
int minCut(string s) {
	int n = s.size();
	vector<int> res(n+1);
	for(int i = 0 ; i< n + 1 ; ++i) {
		res[i] = i - 1;
	}
	vector<vector<bool> > p(n, vector<bool>(n, false));
	for(int i = 0; i< n; ++i) {
		for(int j = 0; j <= i ; ++j) {
			if(s[i] == s[j] && (i - j < 2 || p[j + 1][i - 1])) {
				p[j][i] = true;
				res[i + 1] = min(res[i + 1], res[j] + 1);
			}
		}
	}
	return res[n];
}
$0
endsnippet

# 133
snippet copyCloneGraph "a deep copy (clone) of the graph" b
/* code by 王江 DC-Melo */
/**
 * Definition for undirected graph.
 * struct UndirectedGraphNode {
 *     int label;
 *     vector<UndirectedGraphNode *> neighbors;
 *     UndirectedGraphNode(int x) : label(x) {};
 * };
 */
UndirectedGraphNode *cloneGraph(UndirectedGraphNode *node) {
	if( node == NULL ) return NULL;
	unordered_map<UndirectedGraphNode * , UndirectedGraphNode *> otn;
	otn[node] = new UndirectedGraphNode(node -> label);
	queue<UndirectedGraphNode *> que;
	que.push(node);
	while(!que.empty()) {
		UndirectedGraphNode* node = que.front() ; que.pop();
		int size = node -> neighbors.size();
		for(int i = 0 ; i < size ; i ++) {
			if(otn.find(node -> neighbors[i]) == otn.end()) {
				UndirectedGraphNode * tmp = new UndirectedGraphNode(node -> neighbors[i] -> label);
				otn[node] -> neighbors.push_back(tmp);
				otn[node -> neighbors[i]] = tmp;
				que.push(node -> neighbors[i]);
			} else {
				otn[node] -> neighbors.push_back(otn[node -> neighbors[i]]);
			}
		}
	}
	return otn[node];
}
$0
endsnippet

# 134
snippet gasStationIndex "Return the starting gas station's index" b
/* code by 王江 DC-Melo */
int canCompleteCircuit(vector<int> &gas, vector<int> &cost) {
	vector<int> remainder;
	int sum =0;
	for(int i = 0; i < gas.size(); i++) {
		remainder.push_back(gas[i]-cost[i]);
		sum += gas[i]-cost[i];
	}
	if(sum < 0) {
		return -1;
	} else {
		int start;
		int cur = 0;
		do {
			start = cur;
			int tmp = remainder[cur++];
			while(tmp >= 0 && cur<gas.size()) {
				tmp += remainder[cur++];
				if(tmp < 0) {
					break;
				}
			}
			if(tmp >= 0 && cur == gas.size()) {
				return start;
			}
		}
		while(cur<gas.size());
		return -1;
	}
}
$0
endsnippet

# 135
snippet minimumCandiesMustGiveCandy "minimum candies you must give" b
/* code by 王江 DC-Melo */

/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
ListNode *sortList(ListNode *head) {
	if(!head||!head->next) return head;
	return mergeSort(head);
}
ListNode * mergeSort(ListNode *head) {
	if(!head||!head->next)  return head;
	ListNode *p=head, *q=head, *pre=NULL;
	while(q&&q->next!=NULL) {
		q=q->next->next;
		pre=p;
		p=p->next;  //divide into two parts
	}
	pre->next=NULL;
	ListNode *lhalf=mergeSort(head);
	ListNode *rhalf=mergeSort(p);  //recursive
	return merge(lhalf, rhalf);   //merge
}

ListNode * merge(ListNode *lh, ListNode *rh) {
	ListNode *temp=new ListNode(0);
	ListNode *p=temp;
	while(lh&&rh) {
		if(lh->val<=rh->val) {
			p->next=lh;
			lh=lh->next;
		} else {
			p->next=rh;
			rh=rh->next;
		}
		p=p->next;
	}
	if(!lh) p->next=rh;
	else p->next=lh;
	p=temp->next;
	temp->next=NULL;
	delete temp;
	return p;
}
$0
endsnippet

# 136
snippet findSingleNumberInArray "every element appears twice except for one. Find that single one" b
/* code by 王江 DC-Melo */
int singleNumber(vector<int>& nums) {
	set<int> S;
	for(int i=0;i<nums.size();i++) {
		if(S.count(nums[i])>0) S.erase(nums[i]);
		else S.insert(nums[i]);
	}
	return *S.begin();
}
$0
endsnippet

# 137
snippet singleNumberII "comment " b
/* code by 王江 DC-Melo */
int singleNumber(vector<int>& nums) {
	multiset<int> S;
	for(int i=0;i<nums.size();i++) {
		if(S.count(nums[i])>1) S.erase(nums[i]);
		else S.insert(nums[i]);
	}
	return *S.begin();
}
$0
endsnippet

# 138
snippet copyListWithRandomPointer "comment " b
/* code by 王江 DC-Melo */

/**
 * Definition for singly-linked list with a random pointer.
 * struct RandomListNode {
 *     int label;
 *     RandomListNode *next, *random;
 *     RandomListNode(int x) : label(x), next(NULL), random(NULL) {}
 * };
 */
class Solution 
{
public:
    RandomListNode *copyRandomList(RandomListNode *head) 
    {
        if(head == NULL)
            return NULL;

        map<RandomListNode*, RandomListNode*> mp;
        RandomListNode *newList = new RandomListNode(head->label);
        newList->random = head->random;
        mp.insert(map<RandomListNode*, RandomListNode*>::value_type(head,newList));

        for(RandomListNode *node = head, *temp = newList; node->next != NULL; node = node->next,temp = temp->next)
        {
            temp->next = new RandomListNode(node->next->label);
            temp->next->random = node->next->random;
            mp.insert(map<RandomListNode*, RandomListNode*>::value_type(node->next,temp->next));
        }

        for(RandomListNode *node = newList;node != NULL;node = node->next)
        {
            if(node->random != NULL)
                node->random = mp.find(node->random)->second;
        }

        return newList;
    }
$0
endsnippet

# 139
snippet wordBreak "comment " b
/* code by 王江 DC-Melo */

class Solution 
{
public:
   bool wordBreak(string s, unordered_set<string> &dict) 
   {
        int n = s.size();
        vector<bool> dp(n + 1, false);
        dp[0] = true;
        for (int i = 0; i < n; i++) 
        {
            if (dp[i]) 
            {
                for (int len = 1; i + len - 1 < n; len++) 
                {
                    if (dict.count(s.substr(i, len)) > 0)
                        dp[i + len] = true;
                }
            }
        }
        return dp[n];
    }
$0
endsnippet

# 140
snippet wordBreakII "comment " b
/* code by 王江 DC-Melo */

class Solution
{
public:
    vector<string> result;

    void printStack(stack<string> stk)
    {
        string output = "";
        while(!stk.empty())
        {
            if(output == "")
                output += stk.top();
            else
                output = output + " " + stk.top();
            stk.pop();
        }
        result.push_back(output);
    }

    void check(vector<vector<int> > &v, int t, stack<string> stk, string s)
    {
        if(t == -1)
        {
            printStack(stk);
            return ;
        }
        else
        {
            for(vector<string>::size_type st = 0; st < v[t].size(); st ++)
            {
                stk.push(s.substr(v[t][st]+1, t-v[t][st]));
                check(v, v[t][st], stk, s);
                stk.pop();
            }
        }

    }

    vector<vector<int> > buildv(string s, unordered_set<string> &dict)
    {
        vector<vector<int> > v(s.length());
        for(string::size_type st1 = 0; st1 < s.length(); st1 ++)
        {
            for(string::size_type st2 = 0; st2 <= st1; st2 ++)
            {
                if(dict.find(s.substr(st2, st1-st2+1)) != dict.end())
                {
                    if(st2 == 0)
                        v[st1].push_back(-1);
                    else if(!v[st2-1].empty())
                        v[st1].push_back(st2-1);
                }
            }
        }
        return v;
    }

    vector<string> wordBreak(string s, unordered_set<string> &dict) 
    {
        vector<vector<int> > v = buildv(s, dict);
        stack<string> stk;
        check(v, v.size()-1, stk, s);

        return result;
    }
$0
endsnippet

# 141
snippet linkedListCycle "comment " b
/* code by 王江 DC-Melo */

/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution 
{   
public:
    bool hasCycle(ListNode *head) 
    {
          ListNode *fast,*slow;
         if(head==NULL) 
            return false;
         slow=head;
         fast=head->next;
         while(fast!=NULL && fast->next!=NULL)
         {
             if(slow==fast) 
                return true;
             slow=slow->next;
             fast=fast->next->next;
         }
         return false;
    }
$0
endsnippet

# 142
snippet linkedListCycleII "comment " b
/* code by 王江 DC-Melo */

/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution 
{
public:
    ListNode *detectCycle(ListNode *head) 
    {
        if(head == NULL)
            return NULL;
        ListNode* fast = head->next;
        ListNode* slow = head;
        while(fast != NULL && fast->next != NULL)
        {
            if(fast == slow)
                break;
             slow=slow->next;
             fast=fast->next->next;
        }
        if(fast == NULL || fast->next == NULL)
            return NULL;

        fast = head;
        slow = slow->next;
        while(fast != slow)
        {
            fast = fast->next;
            slow = slow->next;
        }
        return slow;
    }
$0
endsnippet

# 143
snippet reorderList "comment " b
/* code by 王江 DC-Melo */

/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution 
{
public:
    void reverseList(ListNode *&head) 
    {
        ListNode *h = new ListNode(0);
        ListNode *tmp;
        while (head != NULL) 
        {
            tmp = head->next;
            head->next = h->next;
            h->next = head;
            head = tmp;
        }
        head = h->next;
    }

    void twistList(ListNode *&l1, ListNode *&l2) 
    {
        ListNode *p1, *p2, *tmp;
        p1 = l1; p2 = l2;
        while (p1 != NULL && p2 != NULL) {
            tmp = p2->next;
            p2->next = p1->next;
            p1->next = p2;
            p1 = p1->next->next;
            p2 = tmp;
        }
    }   

    void reorderList(ListNode *head) 
    {
        if (head == NULL || head->next == NULL || head->next->next == NULL) 
        {
            return;
        }
        ListNode *slow, *fast;
        slow = head; fast = head;
        while (fast != NULL && fast->next != NULL) 
        {
            slow = slow->next;
            if (fast->next->next == NULL) 
            {
                break;
            }
            fast = fast->next->next;
        }
        ListNode *l2 = slow->next;
        slow->next = NULL;
        reverseList(l2);
        twistList(head, l2);
    }
$0
endsnippet

# 144
snippet binaryTreePreorderTraversal "comment " b
/* code by 王江 DC-Melo */

/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution 
{
public:
    vector<int> result;

    void dst(TreeNode *node)
    {
        if(node == NULL)
            return;
        else
        {
            result.push_back(node->val);
            dst(node->left);
            dst(node->right);
        }
    }

    vector<int> preorderTraversal(TreeNode *root) 
    {
        dst(root);
        return result;
    }
$0
endsnippet

# 145
snippet binaryTreePostorderTraversal "comment " b
/* code by 王江 DC-Melo */

/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution 
{
public:
    vector<int> result;

    void dst(TreeNode *node)
    {
        if(node == NULL)
            return;
        else
        {
            dst(node->left);
            dst(node->right);
            result.push_back(node->val);
        }
    }

    vector<int> postorderTraversal(TreeNode *root) 
    {
        dst(root);
        return result;
    }
$0
endsnippet

# 146
snippet lRUCache "comment " b
/* code by 王江 DC-Melo */

struct CacheNode
{
    int key;
    int value;
    CacheNode(int k , int v) : key(k) , value(v){}
};

class LRUCache
{
public:
    LRUCache(int capacity) 
    {
        size = capacity;
    }
  
    int get(int key) 
    {
        if(cacheMap.find(key) != cacheMap.end())
        {
           auto it = cacheMap[key];
           cacheList.splice(cacheList.begin() , cacheList , it);
           cacheMap[key] = cacheList.begin();
           return cacheList.begin()->value;
        }
        else
        {
            return -1;
        }
    }
  
    void set(int key, int value) 
    {
        if (cacheMap.find(key) == cacheMap.end())
        {
            if(cacheList.size() == size)
            {
                cacheMap.erase(cacheList.back().key);
                cacheList.pop_back();
            }
            cacheList.push_front(CacheNode(key , value));
            cacheMap[key] = cacheList.begin();
        }
        else
        {
           auto it = cacheMap[key];
           cacheList.splice(cacheList.begin() , cacheList , it);
           cacheMap[key] = cacheList.begin();
           cacheList.begin()->value = value;
        }
    }
private:
    int size;
    list<CacheNode> cacheList;
    unordered_map<int , list<CacheNode>::iterator > cacheMap;
$0
endsnippet

# 147
snippet insertionSortList "comment " b
/* code by 王江 DC-Melo */

/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution 
{
public:
    ListNode *insertionSortList(ListNode *head) 
    {
        if (head == NULL) 
            return head;
      
        ListNode* curr = head -> next;
        head -> next = NULL;
      
        while(curr != NULL)
        {
            ListNode* tmpHead = head;
            ListNode* prev = NULL;
            ListNode* next = curr -> next;
            while(tmpHead != NULL && tmpHead -> val <= curr -> val)
            {
                prev = tmpHead;
                tmpHead = tmpHead -> next;
            }
          
            if(prev != NULL)
            {
                //insert
                if(prev -> next)
                {
                    curr -> next = prev -> next;
                    prev -> next = curr;
                }
                else
                {
                    prev -> next = curr;
                    curr -> next = NULL;
                }
            }
            else
            {
                curr -> next = head;
                head = curr;
            }
            curr = next;
        }
        return head;
    }
$0
endsnippet

# 148
snippet sortList "comment " b
/* code by 王江 DC-Melo */

/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution 
{
public:
    ListNode *sortList(ListNode *head) 
    {
        if(!head||!head->next)
            return head;
        return mergeSort(head);
    }

    ListNode * mergeSort(ListNode *head)
    {
        if(!head||!head->next)   //just one element
            return head;
        ListNode *p=head, *q=head, *pre=NULL;
        while(q&&q->next!=NULL)
        {
            q=q->next->next;
            pre=p;
            p=p->next;  //divide into two parts
        }
        pre->next=NULL;
        ListNode *lhalf=mergeSort(head);
        ListNode *rhalf=mergeSort(p);  //recursive
        return merge(lhalf, rhalf);   //merge
    }

    ListNode * merge(ListNode *lh, ListNode *rh)
    {
        ListNode *temp=new ListNode(0);
        ListNode *p=temp;

        while(lh&&rh)
        {
            if(lh->val<=rh->val)
            {
                p->next=lh;
                lh=lh->next;
            }
            else
            {
                p->next=rh;
                rh=rh->next;
            }
            p=p->next;
        }
      
        if(!lh)
            p->next=rh;
        else
            p->next=lh;
        p=temp->next;
        temp->next=NULL;
        delete temp;
        return p;
    }
$0
endsnippet

# 149
snippet maxPointsOnALine "comment " b
/* code by 王江 DC-Melo */

/**
 * Definition for a point.
 * struct Point {
 *     int x;
 *     int y;
 *     Point() : x(0), y(0) {}
 *     Point(int a, int b) : x(a), y(b) {}
 * };
 */
class Solution 
{
public:
    int maxPoints(vector<Point> &points) 
    {
        unordered_map<float,int> mp;
        int maxNum = 0;
        for(int i = 0; i < points.size(); i++)
        {
            mp.clear();
            mp[INT_MIN] = 0;
            int duplicate = 1;
            for(int j = 0; j < points.size(); j++)
            {
                if(j == i) continue;
                if(points[i].x == points[j].x && points[i].y == points[j].y)
                {
                    duplicate++;
                    continue;
                }
                float k = points[i].x == points[j].x ? INT_MAX : (float)(points[j].y - points[i].y)/(points[j].x - points[i].x);
                mp[k]++;
            }
            unordered_map<float, int>::iterator it = mp.begin();
            for(; it != mp.end(); it++)
                if(it->second + duplicate > maxNum)
                    maxNum = it->second + duplicate;
        }
        return maxNum;
    }
$0
endsnippet

# 150
snippet evaluateReversePolishNotation "comment " b
/* code by 王江 DC-Melo */

class Solution 
{
public:
    int evalRPN(vector<string>& tokens) 
    {
        stack<int> fuckYou;
        for(int i=0;i<tokens.size();i++)
        {
            if(tokens[i] != "+" && tokens[i] != "-" && tokens[i] != "*" && tokens[i] != "/")
            {
                stringstream ss(tokens[i]);
                int temp;
                ss >> temp; 
                fuckYou.push(temp);
            }
            else
            {
                int b = fuckYou.empty()? 0:fuckYou.top();
                fuckYou.pop();
                int a = fuckYou.empty()? 0:fuckYou.top();
                fuckYou.pop();
                if(tokens[i] == "+")
                    fuckYou.push(a+b);
                if(tokens[i] == "-")
                    fuckYou.push(a-b);
                if(tokens[i] == "*")
                    fuckYou.push(a*b);
                if(tokens[i] == "/")
                    fuckYou.push(a/b);
            }
        }
        return fuckYou.top();
    }
$0
endsnippet

# 151
snippet reverseWordsInAString "comment " b
/* code by 王江 DC-Melo */

class Solution 
{
public:
    void reverseWords(string & s)
    {
        string ss;
        int i = s.length()-1;
        while(i>=0)
        {
            while(i>=0&&s[i] == ' ')
            {
                i --;
            }
            if(i<0) break;
            if(ss.length()!=0)
                ss.push_back(' ');
            string temp ;
            for(;i>=0&&s[i]!=' ';i--)
                temp.push_back(s[i]);
            reverse(temp.begin(),temp.end());
            ss.append(temp);
        }
        s=ss;
    }
$0
endsnippet

# 152
snippet maximumProductSubarray "comment " b
/* code by 王江 DC-Melo */

class Solution 
{
public:
    int maxProduct(int A[], int n) 
    {
        if(n==0) 
            return 0;
        if(n==1) 
            return A[0];
        int curMax = A[0];
        int curMin = A[0];
        int ans = A[0];
        for(int i=1;i<n;i++)
        {
            int temp = curMin *A[i];
            curMin = min(A[i], min(temp, curMax*A[i]));
            curMax = max(A[i], max(temp, curMax*A[i]));
            ans = max(ans, curMax);
        }
        return ans;
    }
$0
endsnippet

# 153
snippet findMinimumInRotatedSortedArray "comment " b
/* code by 王江 DC-Melo */

class Solution 
{
public:
    int findMin(vector<int> &num) 
    {
        if(num.size() == 1)
            return num[0];

        int midPos = num.size()/2;
        int left = 0;
        int right = num.size()-1;

        int minEle = num[0];
        while(left < midPos && midPos < right)
        {
            if(num[left] > num[midPos])
            {
                right = midPos;
                midPos = (left+right)/2;
            }
            else if(num[midPos] > num[right])
            {
                left = midPos;
                midPos = (left+right)/2;
            }
            else
            {
                minEle = num[left];
                break;
            }
        }

        if(num[left] < num[right])
            minEle = num[left];
        else
            minEle = num[right];

        return minEle;
    }
$0
endsnippet

# 154
snippet findMinimumInRotatedSortedArrayII "comment " b
/* code by 王江 DC-Melo */

class Solution 
{
public:
    int findMin(vector<int> &num) 
    {
        if(num.empty())
            return 0;
        else if(num.size() == 1)
            return num[0];
        else
        {
            for(vector<int>::size_type st = 1; st < num.size(); st ++)
            {
                if(num[st-1] > num[st])
                    return num[st];
            }
            return num[0];
        }
    }
$0
endsnippet

# 155
snippet minStack "comment " b
/* code by 王江 DC-Melo */

class MinStack 
{
private:
    std::stack<int> stack;  
    std::stack<int> min_stack; 
public:
    void push(int x) 
    {
        stack.push(x);
        if (min_stack.empty() || ((!min_stack.empty()) && x <= min_stack.top())) 
        {
            min_stack.push(x);  
        }  
    }

    void pop() 
    {
        if (!stack.empty()) 
        {  
            if (stack.top() == min_stack.top())  
                min_stack.pop();  
            stack.pop();  
        }  
    }

    int top() 
    {
        if (!stack.empty())  
            return stack.top();
    }

    int getMin() 
    {
        if (!min_stack.empty())  
            return min_stack.top(); 
    }
$0
endsnippet

# 160
snippet intersectionOfTwoLinkedLists "comment " b
/* code by 王江 DC-Melo */

/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution 
{
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) 
    {
        if(headA == NULL || headB == NULL)
            return NULL;
        int countA = 0;
        ListNode *TA = headA;
        while(TA->next != NULL)
        {
            TA = TA->next;
            countA++;
        }

        int countB = 0;
        ListNode *TB = headB;
        while(TB->next != NULL)
        {
            TB = TB->next;
            countB++;
        }

        if(TA != TB)
            return NULL;

        int temp;
        if(countA > countB)
        {
            temp = countA - countB;
            while(temp--)
                headA = headA->next;
        }
        else
        {
            temp = countB - countA;
            while(temp--)
                headB = headB->next;
        }

        while(headA != headB)
        {
            headA = headA->next;
            headB = headB->next;
        }

        return headA;
    }
$0
endsnippet

# 162
snippet findPeakElement "comment " b
/* code by 王江 DC-Melo */

class Solution 
{
public:
    int findPeakElement(const vector<int> &num) 
    {
        int left=0,right=num.size()-1;
        while(left<=right){
            if(left==right)
                return left;
            int mid=(left+right)/2;
            if(num[mid]<num[mid+1])
                left=mid+1;
            else
                right=mid;
        }
        return 0;
    }
$0
endsnippet

# 164
snippet maximumGap "comment " b
/* code by 王江 DC-Melo */

class Solution 
{
public:
       int maximumGap(vector<int> &num) 
       {
        if(num.size() < 2)
          return 0;
        int min_value = num[0];
        int max_value = num[0];
        for(vector<int>::iterator iter = num.begin(); iter != num.end(); iter++) 
        {
            min_value = min(*iter, min_value);
            max_value = max(*iter, max_value);
        }
        int range = ceil(double(max_value - min_value) / (num.size() - 1));
        vector<vector<int> >buckets(num.size());
        for(vector<int>::iterator iter = num.begin(); iter != num.end(); iter++) 
        {
            int index = (*iter - min_value) / range;
            if(buckets[index].empty()) 
            {
                buckets[index].push_back(*iter);
                buckets[index].push_back(*iter);

            } 
            else 
            {
                if(*iter < buckets[index][0]) 
                {
                    buckets[index][0] = *iter;
                }
                if(*iter > buckets[index][1]) 
                {
                    buckets[index][1] = *iter;
                }
            }
        }
        int gap = 0;
         int pre = 0;
        for(int i = 1; i < buckets.size(); i++) 
        {
            if(buckets[i].empty())
              continue;
            gap = max(gap, buckets[i][0] - buckets[pre][1]);
            pre = i;
        }
        return gap;
    }
$0
endsnippet

# 165
snippet compareVersionNumbers "comment " b
/* code by 王江 DC-Melo */

class Solution 
{
public:
    int compareVersion(string version1, string version2) 
    {
        int lev1=0,lev2=0;
        int id1=0,id2=0;
        while(id1!=version1.length()||id2!=version2.length()){
            lev1=0;
            while(id1<version1.length()){
                if(version1[id1]=='.'){
                    ++id1;
                    break;
                }
                lev1=lev1*10+(version1[id1]-'0');
                ++id1;
            }
          
            lev2=0;
            while(id2<version2.length()){
                if(version2[id2]=='.'){
                    ++id2;
                    break;
                }
                lev2=lev2*10+(version2[id2]-'0');
                ++id2;
            }
          
            if(lev1>lev2){
                return 1;
            }else if(lev1<lev2){
                return -1;
            }
        }
        return 0;
    }
$0
endsnippet

# 166
snippet fractionToRecurringDecimal "comment " b
/* code by 王江 DC-Melo */

class Solution {
public:
    string fractionToDecimal(int numerator, int denominator) {
        return Helper(numerator, denominator);
    }
    string Helper(long long numerator, long long denominator)
    {
        //convert to 64_int in case INT_MIN/-1 overflow
      
        //special case
        if(denominator == 0)
            return "";
        else if(numerator == 0)
            return "0";
      
        string ret = "";
      
        if((numerator<0) ^ (denominator<0))
        {//one of them is negative, with bit or
            ret += '-';
            numerator = abs(numerator);
            denominator = abs(denominator);
        }
      
        //integer part
        if(numerator/denominator == 0)
        //integer part is 0
            ret += '0';
        else
        {
            long long quotient = numerator/denominator;
            ret += std::to_string(quotient);
            if(numerator%denominator == 0)
            //divisible
                return ret;
            else
            //not divisible, numerator as remainder 
                numerator -= (quotient*denominator);
        }
      
        //decimal part
        ret += '.';
        string demical;
        map<long long, int> m;    //<remainder, index> pair
        long long r = numerator;
        while(r)
        {
            if(m.find(r) != m.end())
            {//remainder
                ret.insert(m[r], 1, '(');   //insert (iterator p, size_t n, char c);
                ret += ')';
                break;    
            }
            m[r] = ret.size();
            r *= 10;    //next digit
            ret += std::to_string(r/denominator);
            r %= denominator;
        }
        return ret;
    }
$0
endsnippet

# 167
snippet twoSumII---Input-array-is-sorted "comment " b
/* code by 王江 DC-Melo */

class Solution 
{
public:
    vector<int> twoSum(vector<int>& numbers, int target) 
    {
        int left=0,right=numbers.size()-1;
        while(numbers[left]+numbers[right] != target)
        {
            if(numbers[left]+numbers[right] < target)
                left++;
            else
                right--;
        }
        vector<int> result;
        result.push_back(left+1);
        result.push_back(right+1);
        return result;
    }
};



$0
endsnippet

# 168
snippet excelSheetColumnTitle "comment " b
/* code by 王江 DC-Melo */

class Solution 
{
public:
    string convertToTitle(int n) 
    {
        if(n < 1)
            return "";
        else
        {
            string result = "";
            while(n)
            {
                n --;
                char c = n%26 + 'A';
                result += c;
                n /= 26;
            }
            reverse(result.begin(), result.end());
            return result;
        }
    }
$0
endsnippet

# 169
snippet majorityElement "comment " b
/* code by 王江 DC-Melo */

class Solution 
{
public:
    int majorityElement(vector<int> &num) 
    {
        int n = num.size();  
        sort(num.begin(),num.end());  
        return num[n/2]; 
    }
$0
endsnippet

# 171
snippet excelSheetColumnNumber "comment " b
/* code by 王江 DC-Melo */

class Solution 
{
public:
    int titleToNumber(string s) 
    {
        if(!s.length())
            return 0;

        int result = 0;
        for(int i=0;i<s.length();i++)
        {
            result *= 26;
            result += s[i] - 'A'+1;
        }
        return result;
    }
$0
endsnippet

# 172
snippet factorialTrailingZeroes "comment " b
/* code by 王江 DC-Melo */

class Solution 
{
public:
    int trailingZeroes(int n) 
    {
        int ret = 0;
        while(n)
        {
            ret += n/5;
            n /= 5;
        }
        return ret;
    }
$0
endsnippet

# 173
snippet binarySearchTreeIterator "comment " b
/* code by 王江 DC-Melo */

/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class BSTIterator 
{
private:
    stack<TreeNode*> sta;
public:
    BSTIterator(TreeNode *root) 
    {
        while(!sta.empty())
            sta.pop();
        while(root) 
        {
            sta.push(root);
            root = root->left;
        }
    }

    /** @return whether we have a next smallest number */
    bool hasNext() {
        return !sta.empty();
    }

    /** @return the next smallest number */
    int next() 
    {
        TreeNode *tmp=sta.top();
        sta.pop();
        int ret = tmp->val;
        tmp = tmp->right;
        while(tmp) 
        {
            sta.push(tmp);
            tmp = tmp->left;
        }
        return ret;
    }
};

/**
 * Your BSTIterator will be called like this:
 * BSTIterator i = BSTIterator(root);
 * while (i.hasNext()) cout << i.next();
$0
endsnippet
 # */::::::::::::::
# 174
snippet dungeonGame "comment " b
/* code by 王江 DC-Melo */

class Solution 
{
public:
    int calculateMinimumHP(vector<vector<int> > &dungeon) 
    {
        int m = dungeon.size();
        int n = dungeon[0].size();
        dungeon[m-1][n-1] = max(0-dungeon[m-1][n-1], 0);
        for (int i = m - 2; i >= 0; --i) 
        {
            dungeon[i][n-1] = max(dungeon[i+1][n-1]-dungeon[i][n-1], 0);
        }
        for (int j = n - 2; j >= 0; --j) 
        {
            dungeon[m-1][j] = max(dungeon[m-1][j+1]-dungeon[m-1][j], 0);
        }
        for (int i = m - 2; i >= 0; --i) 
        {
            for (int j = n - 2; j >= 0; --j) 
            {
                dungeon[i][j] = max(min(dungeon[i][j+1], dungeon[i+1][j])-dungeon[i][j], 0);
            }
        }
        return dungeon[0][0] + 1;
    }
$0
endsnippet

# 179
snippet largestNumber "comment " b
/* code by 王江 DC-Melo */

bool cmp(const string s1, const string s2) 
{
    return (s1 + s2) > (s2 + s1);
}

class Solution 
{
public:
    string largestNumber(vector<int> &num) 
    {
        vector<string> s_num(num.size());
        stringstream stream;
        for (int i = 0; i < num.size(); ++i) 
        {
            stream << num[i];
            stream >> s_num[i];
            stream.clear();
        }
        sort(s_num.begin(), s_num.end(), cmp);
        string tmp_res;
        for (int i = 0; i < s_num.size(); ++i) 
        {
            tmp_res += s_num[i];
        }
        string res;
        bool flag = false;
        for (int i = 0; i < tmp_res.size(); ++i) 
        {
            if (tmp_res[i] != '0') 
            {
                res.push_back(tmp_res[i]);
                flag = true;
            } 
            else if (flag) 
            {
                res.push_back(tmp_res[i]);
            }
        }
        if (!flag) 
            res.push_back('0');
        return res;
    }
$0
endsnippet

# 187
snippet repeatedDNASequences "comment " b
/* code by 王江 DC-Melo */

class Solution 
{
public:
    int getVal(char ch) 
    {
        if (ch == 'A') return 0;
        if (ch == 'C') return 1;
        if (ch == 'G') return 2;
        if (ch == 'T') return 3;
        return 0;
    }
  
    vector<string> findRepeatedDnaSequences(string s) 
    {
        set<string> st;
        vector<string> res;
        string str;
        if (s.length() < 10 || s == "") 
            return res;
        int mp[1024*1024] = {0};
        unsigned int val = 0;
        for (int i = 0; i < 9; ++i) 
        {
            val <<= 2;
            val |= getVal(s[i]);
        }
        for (int i = 9; i < s.length(); ++i) 
        {
            val <<= 14;
            val >>= 12;
            val |= getVal(s[i]);
            ++mp[val];
            if (mp[val] > 1) 
            {
                str = s.substr(i-9, 10);
                st.insert(str);
            }
        }
        for (set<string>::iterator i = st.begin(); i != st.end(); ++i) 
        {
            res.push_back(*i);
        }
        return res;
    }
$0
endsnippet

# 188
snippet bestTimeToBuyAndSellStockIV "comment " b
/* code by 王江 DC-Melo */

class Solution 
{
public:
    int maxProfit(int k, vector<int> &prices) 
    {
        if(prices.empty() || k == 0)
          return 0;

        if(k >= prices.size())
          return solveMaxProfit(prices);

        vector<int> global(k + 1, 0);
        vector<int> local(k + 1, 0);

        for(int i = 1; i < prices.size(); i++) 
        {
            int diff = prices[i] - prices[i - 1];
            for(int j = k; j >= 1; j--) 
            {
                local[j] = max(local[j] + diff, global[j - 1] + max(diff, 0));
                global[j] = max(global[j], local[j]);
            }
        }

        return global[k];
    }
private:
    int solveMaxProfit(vector<int> &prices) 
    {
        int res = 0;
        for(int i = 1; i < prices.size(); i++) 
        {
            int diff = prices[i] - prices[i - 1];
            if(diff > 0)
              res += diff;
        }
        return res;
    }
$0
endsnippet

# 189
snippet rotateArray "comment " b
/* code by 王江 DC-Melo */

class Solution 
{
public:
    void rotate(int nums[], int n, int k) 
    {  
        k = k % n;  
        if (k == 0) return;  
        int *temp = new int[n];  
        memcpy(temp, nums+(n-k), sizeof(int)*k);  
        memcpy(temp+k, nums, sizeof(int)*(n-k));  
        memcpy(nums, temp, sizeof(int)*n);  
        delete[] temp;  
    } 
$0
endsnippet

# 190
snippet reverseBits "comment " b
/* code by 王江 DC-Melo */

class Solution 
{
public:
    uint32_t reverseBits(uint32_t n) 
    {
        int result = 0;
        for(int i=0;i<32;i++)
        {
            result <<= 1;
            result += n & 1;
            n >>= 1;
        }
        return result;
    }
$0
endsnippet

# 191
snippet numberOf1Bits "comment " b
/* code by 王江 DC-Melo */

class Solution {
public:
    int hammingWeight(uint32_t n) {
        int result = 0;
        while(n)
        {
            result += n & 0b1? 1:0;
            n >>= 1;
        }
        return result;
      
    }
$0
endsnippet

# 198
snippet houseRobber "comment " b
/* code by 王江 DC-Melo */

class Solution 
{
public:
    int rob(vector<int>& nums) 
    {
        vector<int> DP(nums.size());

        if(nums.size()==0)
            return 0;
        if(nums.size()==1)
            return nums[0];

        DP[0] = nums[0];
        DP[1] = max(nums[0],nums[1]);
        for(int i=2;i<nums.size();i++)
        {
            DP[i] = max(DP[i-1],DP[i-2]+nums[i]);
        }
        return DP.back();
    }
$0
endsnippet

# 199
snippet binaryTreeRightSideView "comment " b
/* code by 王江 DC-Melo */

/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution 
{
public:
    vector<int> rightSideView(TreeNode *root) 
    {
        vector<int> ans;
        if (root == NULL) 
            return ans;
        queue<TreeNode*> que;
        que.push(root);
        TreeNode* curr;
        while(!que.empty()) 
        {
            int cnt = que.size();
            for (int i = 0; i < cnt; i++) 
            {
                curr = que.front(); que.pop();
                if (curr->left) 
                {
                    que.push(curr->left);
                }
                if (curr->right) 
                {
                    que.push(curr->right);
                }
            }
            ans.push_back(curr->val);
        }
        return ans;
    }
$0
endsnippet

# 200
snippet numberOfIslands "comment " b
/* code by 王江 DC-Melo */

class Solution 
{
public:
    void dfs(vector<vector<char>> &grid, int x, int y) 
    {
        if (x < 0 || x >= grid.size()) 
            return;
        if (y < 0 || y >= grid[0].size()) 
            return;
        if (grid[x][y] != '1') 
            return;
        grid[x][y] = 'X';
        dfs(grid, x + 1, y);
        dfs(grid, x - 1, y);
        dfs(grid, x, y + 1);
        dfs(grid, x, y - 1);
    }
  
    int numIslands(vector<vector<char>> &grid) 
    {
        if (grid.empty() || grid[0].empty()) 
            return 0;
        int N = grid.size(), M = grid[0].size();
        int cnt = 0;
        for (int i = 0; i < N; ++i) 
        {
            for (int j = 0; j < M; ++j) 
            {
                if (grid[i][j] == '1') 
                {
                    dfs(grid, i, j);
                    ++cnt;
                }
            }
        }
        return cnt;
    }
$0
endsnippet

# 201
snippet bitwiseANDOfNumbersRange "comment " b
/* code by 王江 DC-Melo */

class Solution 
{
public:
    int rangeBitwiseAnd(int m, int n) 
    {
        int offset = 0;
        while (m && n)
        {
            if (m == n)
            {
                return m << offset;
            }
            m >>= 1;
            n >>= 1;
            offset++;
        }
        return 0;
    }
$0
endsnippet

# 202
snippet happyNumber "comment " b
/* code by 王江 DC-Melo */

class Solution 
{
public:
    bool isHappy(int n) 
    {
        while(n>6)
        {
            int sum=0;
            while(n)
            {
                sum+=(n%10)*(n%10);
                n/=10;
            }
            n=sum;
        }
        return n==1;
    }
$0
endsnippet

# 203
snippet removeLinkedListElements "comment " b
/* code by 王江 DC-Melo */

/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution 
{
public:
    ListNode* removeElements(ListNode* head, int val) 
    {
        ListNode *temp = NULL;
        while(head != NULL && head->val == val)
        {
            temp = head;
            head = head->next;
            delete(temp);
        }

        if(head == NULL)
            return NULL;

        ListNode *cur = head->next ,*last = head;
        while(cur != NULL)
        {
            if(cur->val == val)
            {
                temp = cur;
                last->next = cur->next;
                cur = cur->next;
                delete temp;
            }
            else
            {
                last = cur;
                cur = cur->next;        
            }
        }
        return head;
    }
$0
endsnippet

# 204
snippet countPrimes "comment " b
/* code by 王江 DC-Melo */

class Solution 
{
public:
    int countPrimes(int n) 
    {
        vector<bool> flag(n,true);
        flag[0]=false;
        if(n<2)
            return 0;
        flag[1]=false;
        int count = 0;
        for(int i=2;i<n;i++)
        {
            if(flag[i])
            {
                count ++;
                for(int j=2;j*i<n;j++)
                    flag[j*i] = false;
            }
        }
        return count;
    }
$0
endsnippet

# 205
snippet isomorphicStrings "comment " b
/* code by 王江 DC-Melo */


class Solution 
{
public:
    bool isIsomorphic(string s, string t) 
    {
        map<char, char> m1;
        map<char, char> m2;
        bool flag = true;
        for(int i=0; i<s.size(); ++i)
        {
            if(m1.find(s[i])==m1.end() && m2.find(t[i])==m2.end())
            {
                m1[s[i]] = t[i];
                m2[t[i]] = s[i];
            }
            else if(m1.find(s[i])!=m1.end() && m2.find(t[i])!=m2.end())
            {
                if(m1[s[i]]!=t[i] || m2[t[i]]!=s[i])
                {
                    flag = false;
                    break;
                }
            }
            else
            {
                flag = false;
                break;
            }
        }
        return flag;
    }
$0
endsnippet

# 206
snippet reverseLinkedList "comment " b
/* code by 王江 DC-Melo */

/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution 
{
public:
    ListNode* reverseList(ListNode* head) 
    {
        if(head == NULL || head->next == NULL)
            return head;
        ListNode Result(0);
        ListNode *p = head;
        while (p) 
        {
            ListNode *q = p->next;
            p->next = Result.next;
            Result.next = p;
            p = q;
        }
        return Result.next;
    }
$0
endsnippet

# 207
snippet courseSchedule "comment " b
/* code by 王江 DC-Melo */

class Graph
{
    int V;
    list<int> *adj;
    queue<int> q;
    int* indegree;
public:
    Graph(int V);
    ~Graph();
    void addEdge(int v, int w);
    bool topological_sort();
};

/************************类定义************************/
Graph::Graph(int V)
{
    this->V = V;
    adj = new list<int>[V];

    indegree = new int[V];
    for(int i=0; i<V; ++i)
        indegree[i] = 0;
}

Graph::~Graph()
{
    delete [] adj;
    delete [] indegree;
}

void Graph::addEdge(int v, int w)
{
    adj[v].push_back(w); 
    ++indegree[w];
}

bool Graph::topological_sort()
{
    for(int i=0; i<V; ++i)
        if(indegree[i] == 0)
            q.push(i);
          
    int count = 0;
    while(!q.empty())
    {
        int v = q.front();
        q.pop();

        ++count;
        list<int>::iterator beg = adj[v].begin();
        for( ; beg!=adj[v].end(); ++beg)
            if(!(--indegree[*beg]))
                q.push(*beg);
    }

    if(count < V)
        return false;
    else
        return true;
}


class Solution 
{
public:
    bool canFinish(int numCourses, vector<vector<int> >& prerequisites) 
    {
        Graph g(numCourses);
        for(int i=0; i<prerequisites.size(); ++i)
            g.addEdge(prerequisites[i][1], prerequisites[i][0]);

        return g.topological_sort();
    }
};
$0
endsnippet

# 208
snippet implementTrie-(Prefix-Tree) "comment " b
/* code by 王江 DC-Melo */

class TrieNode 
{
public:
    // Initialize your data structure here.
    TrieNode() 
    {
        sonNode.resize(26,NULL);
        isWordFlag = false;
    }

    TrieNode* findChar(char c)
    {
        return sonNode[c-'a'];
    }

    TrieNode* setChar(char c)
    {
        sonNode[c-'a'] = new TrieNode();
        return sonNode[c-'a'];
    }

    void setWordFlag()
    {
        isWordFlag = true;
    }

    bool isWord()
    {
        return isWordFlag;
    }
private:
    bool isWordFlag;
    vector<TrieNode*> sonNode;
};

class Trie 
{
public:
    Trie() 
    {
        root = new TrieNode();
    }

    // Inserts a word into the trie.
    void insert(string s) 
    {
        TrieNode *temp;
        TrieNode *node = root;
        for(int i=0;i<s.size();i++)
        {
            temp = node->findChar(s[i]);
            if(temp == NULL)
                node = node->setChar(s[i]);
            else
                node = temp;
        }
        node->setWordFlag();
    }

    // Returns if the word is in the trie.
    bool search(string key) 
    {
        TrieNode *node = root;
        for(int i=0;i<key.size();i++)
        {
            node = node->findChar(key[i]);
            if(node == NULL)
                return false;
        }
        return node->isWord();
    }

    // Returns if there is any word in the trie
    // that starts with the given prefix.
    bool startsWith(string prefix) 
    {
        TrieNode *node = root;
        for(int i=0;i<prefix.size();i++)
        {
            node = node->findChar(prefix[i]);
            if(node == NULL)
                return false;
        }
        return true;
    }

private:
    TrieNode* root;
};

// Your Trie object will be instantiated and called as such:
// Trie trie;
// trie.insert("somestring");
$0
endsnippet
# // trie.search("key");::::::::::::::
# 209
snippet minimumSizeSubarraySum "comment " b
/* code by 王江 DC-Melo */

class Solution 
{
public:
    int minSubArrayLen(int s, vector<int>& nums) 
    {
        int length = nums.size()+1;
        int startIndex = 0, endIndex = 0;
        int sum = 0;
        while(endIndex < nums.size())
        {
            while(endIndex < nums.size() && sum < s)
            {
                sum += nums[endIndex];
                endIndex += 1;
            }
            while(startIndex < endIndex && sum >= s)
            {
                if( sum >= s)
                    length = min(length,endIndex - startIndex);
                sum -= nums[startIndex];
                startIndex += 1;
            }
        }
        return length <= nums.size()? length:0;
    }
$0
endsnippet

# 210
snippet courseScheduleII "comment " b
/* code by 王江 DC-Melo */

#include <iostream>
#include <list>
#include <queue>
#include <vector>
using namespace std;

class Graph
{
    int V;             // 顶点个数
    vector<list<int> > adj;    // 邻接表
    queue<int> q;      // 维护一个入度为0的顶点的集合
    vector<int> indegree;     // 记录每个顶点的入度
public:
    Graph(int V);                   // 构造函数
    ~Graph();                       // 析构函数
    void addEdge(int v, int w);     // 添加边
    vector<int> topological_sort();        // 拓扑排序
};

/************************类定义************************/
Graph::Graph(int V)
{
    this->V = V;
    adj.resize(V);

    indegree.resize(V,0);  // 入度全部初始化为0
    // for(int i=0; i<V; ++i)
    //     indegree[i] = 0;
}

Graph::~Graph()
{
    // delete [] adj;
    // delete [] indegree;
}

void Graph::addEdge(int v, int w)
{
    adj[v].push_back(w); 
    ++indegree[w];
}

vector<int> Graph::topological_sort()
{
    for(int i=0; i<V; ++i)
        if(indegree[i] == 0)
            q.push(i);         // 将所有入度为0的顶点入队

    vector<int> order;             // 计数，记录当前已经输出的顶点数 
    while(!q.empty())
    {
        int v = q.front();      // 从队列中取出一个顶点
        q.pop();

        order.push_back(v);
        // 将所有v指向的顶点的入度减1，并将入度减为0的顶点入栈
        list<int>::iterator beg = adj[v].begin();
        for( ; beg!=adj[v].end(); ++beg)
            if(!(--indegree[*beg]))
                q.push(*beg);   // 若入度为0，则入栈
    }

    if(order.size() < V)
        order.resize(0);       // 没有输出全部顶点，有向图中有回路

    return order;
}


class Solution 
{
public:
    vector<int> findOrder(int numCourses, vector<pair<int, int> >& prerequisites) 
    {
        Graph g(numCourses);
        for(int i=0; i<prerequisites.size(); ++i)
            g.addEdge(prerequisites[i].second, prerequisites[i].first);

        return g.topological_sort();
    }
$0
endsnippet

# 211
snippet addAndSearchWord---Data-structure-design "comment " b
/* code by 王江 DC-Melo */

class TrieNode 
{
public:
    // Initialize your data structure here.
    TrieNode()
    {
        sonNode.resize(26,NULL);
        isWordFlag = false;
    }

    TrieNode* findChar(char c)
    {
        return sonNode[c-'a'];
    }

    TrieNode* setChar(char c)
    {
        sonNode[c-'a'] = new TrieNode();
        return sonNode[c-'a'];
    }
  
    void setWordFlag()
    {
        isWordFlag = true;
    }

    bool isWord()
    {
        return isWordFlag;
    }
   
     TrieNode* findSon(int n)
    {
        return sonNode[n];
    }

private:
    bool isWordFlag;
    vector<TrieNode*> sonNode;
};

class WordDictionary 
{
public:
    WordDictionary() 
    {
        root = new TrieNode();
    }

    // Adds a word into the data structure.
    void addWord(string word) 
    {
        TrieNode *temp;
        TrieNode *node = root;
        for(int i=0;i<word.size();i++)
        {
            temp = node->findChar(word[i]);
            if(temp == NULL)
            {
                node = node->setChar(word[i]);
            }
            else
                node = temp;
        }
        node->setWordFlag();
    }

    // Returns if the word is in the data structure. A word could
    // contain the dot character '.' to represent any one letter.
    bool search(string word) 
    {
        return searchByBackTracking(root,word,0);
    }

    bool searchByBackTracking(TrieNode *node, const string &word, int n)
    {
        if(node == NULL)
            return false;

        if(n == word.size())
            return node->isWord();
        bool result = false;
        if(word[n] == '.')
        {
            for(int i=0;i<26;i++)
            {
                result = result || searchByBackTracking(node->findSon(i),word,n+1);
            }
        }
        else
        {
            result = result || searchByBackTracking(node->findChar(word[n]),word,n+1);
        }
        return result;
    }

private:
    TrieNode* root;
};

// Your WordDictionary object will be instantiated and called as such:
// WordDictionary wordDictionary;
// wordDictionary.addWord("word");
$0
endsnippet
# // wordDictionary.search("pattern");::::::::::::::
# 213
snippet houseRobberII "comment " b
/* code by 王江 DC-Melo */

class Solution {
public:
    int rob(vector<int>& nums) {
        if(nums.size() == 0)
            return 0;
        if(nums.size() == 1)
            return nums[0];
        if(nums.size() == 2)
            return max(nums[0], nums[1]);
      
        vector<int> dp(nums.size(),0);
        dp[0] = nums[0];
        dp[1] = max(nums[0],nums[1]);
      
        for(int i=2;i<nums.size()-1;i++){
            dp[i] = max(dp[i-2]+nums[i],dp[i-1]);
        }
      
        int max1 = dp[nums.size()-2];
      
        dp[1] = nums[1];
        dp[2] = max(nums[1],nums[2]);
      
        for(int i=3;i<nums.size();i++){
            dp[i] = max(dp[i-2]+nums[i],dp[i-1]);
        }
      
        int max2 = dp[nums.size()-1];
      
        return max(max1, max2);
      
    }
$0
endsnippet
# }; ::::::::::::::
# 214
snippet shortestPalindrome "comment " b
/* code by 王江 DC-Melo */

class Solution {
public:
    string shortestPalindrome(string s) {
        string str = s;
        reverse(str.begin(), str.end());
        str = s+ "#" + str;
        int len1 = s.size(), len2 = str.size();
        vector<int> vec(len2, 0);
        for(int i = 1; i < len2; i++)
        {
            int k = vec[i-1];
            while(k > 0 && str[k] != str[i]) k = vec[k-1];
            vec[i] = (k += str[i] == str[k]);
        }
        return str.substr(len1+1, len1-vec[len2-1]) + s;
    }
$0
endsnippet

# 215
snippet kthLargestElementInAnArray "comment " b
/* code by 王江 DC-Melo */

class Solution 
{
public:
    int findKthLargest(vector<int>& nums, int k) 
    {
        int L = 0, R = nums.size()-1;
        while(L < R)
        {
            int left = L, right = R;
            int key = nums[left];
            while(left < right)
            {
                while(left < right && nums[right] < key)
                    right--;
                nums[left] = nums[right];
                while(left < right && nums[left] >= key)
                    left++;
                nums[right] = nums[left];
            } 
            nums[left] = key;
            if(left == k -1)
                return nums[k-1];
            else if (left > k-1)
                R = left - 1;
            else
                L = left + 1;
        }
        return nums[k-1];
    }
$0
endsnippet

# 217
snippet containsDuplicate "comment " b
/* code by 王江 DC-Melo */

class Solution 
{
public:
    bool containsDuplicate(vector<int>& nums) 
    {
        return nums.size() > set<int>(nums.begin(), nums.end()).size();        
    }
$0
endsnippet

# 219
snippet containsDuplicateII "comment " b
/* code by 王江 DC-Melo */

class Solution 
{
public:
    bool containsNearbyDuplicate(vector<int>& nums, int k)
    {
        set<int> s;
        int start = 0, end = 0;
      
        for(int i=0;i<nums.size();i++)
        {
            if( s.find(nums[i]) == s.end() )
            {
                s.insert(nums[i]);
                end++;
            }
            else
            {
                return true;
            }
          
            if(end - start > k)
            {
                s.erase(nums[start]);
                start++;
            }
        }
        return false;
    }
$0
endsnippet

# 220
snippet containsDuplicateIII "comment " b
/* code by 王江 DC-Melo */

class Solution 
{
public:
    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) 
    {
        if(t < 0 | k <1)
            return false;

        int i,key;
        unordered_map<int,int> dict;

        for(i =0; i < nums.size(); i++)
        {
            key = nums[i]/max(1,t);
            //map<int,int>::iterator it;
            if( (dict.find(key) != dict.end() && abs(nums[i] - dict[key]) <= t) ||
                (dict.find(key-1) != dict.end() && abs((long)nums[i] - (long)dict[key-1]) <= t) ||
                (dict.find(key+1) !=dict.end() && abs(nums[i] - dict[key+1]) <= t))
            {                           
                return true;
            }

            dict.insert(pair<int,int>(key,nums[i]));

            if(i >= k)
            {   
                dict.erase(nums[i-k]/max(1,t)); //删除窗口大小之外的键值
            }

        }
        return false;       
    }
};
$0
endsnippet

# 223
snippet rectangleArea "comment " b
/* code by 王江 DC-Melo */

class Solution 
{
public:
    int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) 
    {
        int width;
        int height;
      
        if( A<E )
        {
            if( C<=E )
            {
                width = 0;
            }
            else
            {
                if( C<=G )
                {
                    width = C-E;    
                }
                else
                {
                    width = G-E;
                }
            }
        }
        else
        {
            if( A<G )
            {
                if( C<=G )
                {
                    width = C-A;
                }
                else
                {
                    width = G-A;
                }
            }
            else
            {
                width = 0;  
            }
        }
      
        if( B<F )
        {
            if( D<=F )
            {
                height = 0;
            }
            else
            {
                if( D<=H )
                {
                    height = D-F;    
                }
                else
                {
                    height = H-F;
                }
            }
        }
        else
        {
            if( B<H )
            {
                if( D<=H )
                {
                    height = D-B;
                }
                else
                {
                    height = H-B;
                }
            }
            else
            {
                height = 0;  
            }
        }
      
        return ( (C-A)*(D-B) + (G-E)*(H-F) ) - width*height;
    }
$0
endsnippet

# 224
snippet basicCalculator "comment " b
/* code by 王江 DC-Melo */

class Solution 
{
public:
    int calculate(string s) 
    {
        stack<int> numbers; //存储操作数
        stack<char> operators; //存储操作符，包含左括号
        int tempNumber = 0;
      
        for(int i=0;i<s.size();i++)
        {
            /* 当获取一个操作数时，如果符号栈顶为运算符+或-，且?数栈不为空，则立即计算，将结果压入数栈，否则直接压入数栈。*/
            if(s[i]>='0' && s[i]<='9')
            {
                tempNumber = tempNumber*10 + (s[i]-'0');
                if(i+1 == s.size() || (s[i+1]<'0' || s[i-1]>'9') )
                {
                    if(numbers.size()>0)
                    {
                        switch(operators.top())
                        {
                            case '+':
                                tempNumber = numbers.top() + tempNumber;
                                numbers.pop();operators.pop();
                                break;
                            case '-':
                                tempNumber = numbers.top() - tempNumber;
                                numbers.pop();operators.pop();
                                break;
                        }
                    }
                    numbers.push(tempNumber);
                    tempNumber = 0;
                }
            }
            /* 获取)时，符号栈顶必为(，将其出栈，然后运算，直到找到另一个(。*/
            switch(s[i])
            {
                case ' ':break;
                case '+':operators.push('+');break;
                case '-':operators.push('-');break;
                case '(':operators.push('(');break;
                case ')':
                    if(operators.size()>0 && operators.top() == '(')
                        operators.pop();
                    if(operators.size()>0 && operators.top() != '(')
                    {
                        tempNumber = numbers.top();numbers.pop();
                        switch(operators.top())
                        {
                            case '+':
                                tempNumber = numbers.top() + tempNumber;
                                numbers.pop();operators.pop();
                                break;
                            case '-':
                                tempNumber = numbers.top() - tempNumber;
                                numbers.pop();operators.pop();
                                break;
                        }
                        numbers.push(tempNumber);
                        tempNumber = 0;
                    }
                    break;
            }
        }
        return numbers.top();
    }
$0
endsnippet

# 225
snippet implementStackUsingQueues "comment " b
/* code by 王江 DC-Melo */

class Stack 
{
public:
    queue<int> queue1;  
    queue<int> queue2;
  
    // Push element x onto stack.
    void push(int x) 
    {
        if(!queue1.empty())
        {
            queue1.push(x);
        }
        else
        {
            queue2.push(x);
        }
    }

    // Removes the element on top of the stack.
    void pop() 
    {
        if(!queue1.empty())
        {
            while(queue1.size() > 1)
            {
                queue2.push(queue1.front());
                queue1.pop();
            }
            queue1.pop();
        }
        else
        {
            while(queue2.size() > 1)
            {
                queue1.push(queue2.front());
                queue2.pop();
            }
            queue2.pop();
        }
    }

    // Get the top element.
    int top() 
    {
        if(!queue1.empty())
            return queue1.back();
        else
            return queue2.back();
    }

    // Return whether the stack is empty.
    bool empty() 
    {
        return queue1.empty() && queue2.empty();
    }
$0
endsnippet

# 226
snippet invertBinaryTree "comment " b
/* code by 王江 DC-Melo */

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution 
{
public:
    TreeNode* invertTree(TreeNode* root) 
    {
        if(root == NULL)
            return NULL;
        else
        {
            TreeNode* left = invertTree(root->right);
            TreeNode* right = invertTree(root->left);
            root->left = left;
            root->right = right;
            return root;
        }
    }
$0
endsnippet

# 230
snippet kthSmallestElementInABST "comment " b
/* code by 王江 DC-Melo */

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution 
{
public:
    int kthSmallest(TreeNode* root, int k) 
    {
        return InOrder(root,k);
    }
    int InOrder(TreeNode* root,int &k)
    {
        if(root)
        {
            int r1 = InOrder(root->left,k);
            k--;
            if(k==0)
                return root->val;
            int r2 = InOrder(root->right,k);
            return r1+r2;
        }
        return 0;
    }
$0
endsnippet

# 231
snippet powerOfTwo "comment " b
/* code by 王江 DC-Melo */

class Solution {
public:
    bool isPowerOfTwo(int n) 
    {
        if(n <= 0) return false;
        return (n & (n-1)) == 0;
    }
$0
endsnippet

# 232
snippet implementQueueUsingStacks "comment " b
/* code by 王江 DC-Melo */

class Queue 
{
public:
    stack<int> stack1;
    stack<int> stack2;
  
    // Push element x to the back of queue.
    void push(int x) 
    {
        while(!stack2.empty())
        {
            stack1.push(stack2.top());
            stack2.pop();
        }
        stack1.push(x);
    }

    // Removes the element from in front of queue.
    void pop(void) 
    {
        while(!stack1.empty())
        {
            stack2.push(stack1.top());
            stack1.pop();
        }
        stack2.pop();
    }

    // Get the front element.
    int peek(void) 
    {
        while(!stack1.empty())
        {
            stack2.push(stack1.top());
            stack1.pop();
        }
        return stack2.top();
    }

    // Return whether the queue is empty.
    bool empty(void) 
    {
        return stack1.empty() && stack2.empty();
    }
$0
endsnippet

# 234
snippet palindromeLinkedList "comment " b
/* code by 王江 DC-Melo */

/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution 
{
public:
    bool isPalindrome(ListNode* head) 
    {
        if (!head || !(head -> next)) 
            return true;
        ListNode* slow = head;
        ListNode* fast = head;
        while (fast && fast -> next) 
        {
            slow = slow -> next;
            fast = fast -> next -> next;
        }
        if (fast) 
        {
            slow -> next = reverseList(slow -> next);
            slow = slow -> next;
        }
        else slow = reverseList(slow);
        while (slow) 
        {
            if (head -> val != slow -> val)
                return false;
            head = head -> next;
            slow = slow -> next;
        }
        return true;
    }
    ListNode* reverseList(ListNode* node) 
    {
        ListNode* pre = NULL;
        while (node) 
        {
            ListNode* next = node -> next;
            node -> next = pre;
            pre = node;
            node = next;
        }
        return pre;
    }
$0
endsnippet

# 235
snippet lowestCommonAncestorOfABinarySearchTree "comment " b
/* code by 王江 DC-Melo */

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution 
{
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) 
    {
        if(root == NULL || p == NULL || q == NULL)
            return NULL;
        if(p->val > q->val)
            swap(p,q);
        if( root->val >= p->val && root->val <= q->val )
            return root;
        else if( root->val < p->val && root->val < q->val )
            return lowestCommonAncestor(root->right,p,q);
        else if( root->val > p->val && root->val > q->val )
            return lowestCommonAncestor(root->left,p,q);
        return NULL;
    }
$0
endsnippet

# 237
snippet deleteNodeInALinkedList "comment " b
/* code by 王江 DC-Melo */

/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution 
{
public:
    void deleteNode(ListNode* node) 
    {
        ListNode* temp = node->next;
        node->val = node->next->val;
        node->next = node->next->next;
        delete temp;
    }
$0
endsnippet

# 238
snippet productOfArrayExceptSelf "comment " b
/* code by 王江 DC-Melo */

class Solution 
{
public:
    vector<int> productExceptSelf(vector<int>& nums) 
    {
        vector<int> result(nums.size(),0);
        result[nums.size()-1] = 1;
        for(int i=nums.size()-2;i>=0;i--)
            result[i] = result[i+1]*nums[i+1];
        int left=1;
        for(int i=1;i<nums.size();i++)
        {
            left *= nums[i-1];
            result[i] *= left;
        }
        return result;
    }
$0
endsnippet

# 241
snippet differentWaysToAddParentheses "comment " b
/* code by 王江 DC-Melo */

class Solution
{
public:
    vector<int> diffWaysToCompute(string input)
    {
        vector<int> num; //数字
        vector<char> sign; //操作符
        int tempNumber=0;
        int len=input.size();
        for(int i=0;i<len;)
        {
            if(input[i]>='0'&&input[i]<='9') //数字
            {
                // 提取字符串里的数字
                tempNumber=0;
                while(i<len&&input[i]>='0'&&input[i]<='9')
                {
                    tempNumber = tempNumber*10 + input[i]-'0';
                    i++;
                }
                num.push_back(tempNumber);
            }
            else if(input[i]==' ')
                i++;
            else
            {
                // 提取操作符
                sign.push_back(input[i]);
                i++;
            }
        }
      
        int numSum = num.size();
        vector<int> res;
        vector<vector<multiset<int> > > temp;
        multiset<int> tempSet;
        vector<multiset<int> >temVec;
        for(int i=0; i<numSum; ++i)
            temVec.push_back(tempSet);
        for(int i=0; i<numSum; ++i)
            temp.push_back(temVec);
        for(int i=0; i<numSum; ++i)
            temp[i][i].insert(num[i]);
        for(int i=1; i<numSum; ++i)
        {
            if(sign[i-1]=='+')
                temp[i-1][i].insert(num[i-1]+num[i]);
            else if(sign[i-1]=='-')
                temp[i-1][i].insert(num[i-1]-num[i]);
            else
                temp[i-1][i].insert(num[i-1]*num[i]);
        }
        for(int i=2; i<numSum; ++i)
        {
            for(int j=0; j+i<numSum; ++j)
            {
                multiset<int>::iterator ite=temp[j][j].begin();
                for(multiset<int>::iterator ite2=temp[j+1][i+j].begin(); ite2!=temp[j+1][i+j].end(); ++ite2)
                {
                    if(sign[j]=='+')
                        temp[j][i+j].insert(*ite+(*ite2));
                    else if(sign[j]=='-')
                        temp[j][i+j].insert(*ite-(*ite2));
                    else
                        temp[j][i+j].insert(*ite*(*ite2));
                    }
                ite=temp[i+j][i+j].begin();
                for(multiset<int>::iterator ite2=temp[j][i+j-1].begin(); ite2!=temp[j][i+j-1].end(); ++ite2)
                {
                    if(sign[i+j-1]=='+')
                        temp[j][i+j].insert(*ite2+(*ite));
                    else if(sign[j+i-1]=='-')
                        temp[j][i+j].insert(*ite2-(*ite));
                    else
                        temp[j][i+j].insert(*ite2*(*ite));
                    }
                for(int k=j+1; k<i+j-1; ++k)
                {
                    for(multiset<int>::iterator ite2=temp[j][k].begin(); ite2!=temp[j][k].end(); ++ite2)
                    {
                        for(multiset<int>::iterator ite3=temp[k+1][j+i].begin(); ite3!=temp[k+1][j+i].end(); ++ite3)
                        {
                            if(sign[k]=='+')
                                temp[j][i+j].insert(*ite2+(*ite3));
                            else if(sign[k]=='-')
                                temp[j][i+j].insert(*ite2-(*ite3));
                            else
                                temp[j][i+j].insert(*ite2*(*ite3));
                            }
                    }
                }
            }
        }
        for(multiset<int>::iterator ite2=temp[0][numSum-1].begin();ite2!=temp[0][numSum-1].end();++ite2)
            res.push_back(*ite2);
        return res;
    }
$0
endsnippet

# 242
snippet validAnagram "comment " b
/* code by 王江 DC-Melo */

class Solution {
public:
    bool isAnagram(string s, string t) {
        vector<int> count(256,0);
        for(int i=0;i<s.size();i++)
            count[s[i]] += 1;
        for(int i=0;i<t.size();i++)
            count[t[i]] -= 1;
        for(int i=0;i<count.size();i++)
            if(count[i] != 0) 
                return false;
        return true;
    }
$0
endsnippet

# 257
snippet binaryTreePaths "comment " b
/* code by 王江 DC-Melo */

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution 
{
public:
    int dfs(TreeNode *root, vector<string> &result, string temp)
    {
        temp += to_string(root->val);
        if(!root->right && !root->left)
        {
            result.push_back(temp);
            return 0;
        }
        if(root->left)
            dfs(root->left,result,temp+"->");
        if(root->right)
            dfs(root->right,result,temp+"->");
        return 0;
    }
  
    vector<string> binaryTreePaths(TreeNode* root) 
    {
        vector<string> result;
        string temp;
        if(root)
            dfs(root,result,temp);
        return result;
    }
$0
endsnippet

# 258
snippet addDigits "comment " b
/* code by 王江 DC-Melo */

class Solution {
public:
    int addDigits(int num) {
        int ans = num % 9;
        if(ans == 0 && num > 0)
            ans = 9;
        return ans;
    }
$0
endsnippet

# 260
snippet singleNumberIII "comment " b
/* code by 王江 DC-Melo */

class Solution 
{
public:
    vector<int> singleNumber(vector<int>& nums) 
    {
        int XOR = 0;
        for(int i=0;i<nums.size();i++)
            XOR ^= nums[i];
          
        int one = 1;
        while( (one & XOR) == 0)
            one = one << 1;
          
        vector<int> result(2,0);
        for(int i=0;i<nums.size();i++)
        {
            if( (one & nums[i]) == 0)
                result[0] ^= nums[i];
            else
                result[1] ^= nums[i];
        }
        return result;
    }
$0
endsnippet

# 263
snippet uglyNumber "comment " b
/* code by 王江 DC-Melo */

class Solution {
public:
    // 如果能被2,3,5除尽，就是Ugly Number
    bool isUgly(int num) 
    {
        if ( num == 0 ) 
            return false;
        if ( num == 1 ) 
            return true;
        while ( num % 2 == 0 ) 
            num /= 2;
        while ( num % 3 == 0 ) 
            num /= 3;
        while ( num % 5 == 0 ) 
            num /= 5;
      
        return num == 1;
    }
$0
endsnippet

# 264
snippet uglyNumberII "comment " b
/* code by 王江 DC-Melo */

class Solution {
public:
    int nthUglyNumber(int n) {
        vector<int> res(1, 1);
        int i2 = 0, i3 = 0, i5 = 0;
        while (res.size() < n) {
            int m2 = res[i2] * 2; 
            int m3 = res[i3] * 3; 
            int m5 = res[i5] * 5;
            int mn = min(m2, min(m3, m5));
            if (mn == m2) ++i2;
            if (mn == m3) ++i3;
            if (mn == m5) ++i5;
            res.push_back(mn);
        }
        return res.back();
    }
$0
endsnippet

# 273
snippet integerToEnglishWords "comment " b
/* code by 王江 DC-Melo */

class Solution 
{
public:
    vector<string> strList1 = {"Zero","One","Two","Three","Four","Five","Six","Seven","Eight","Nine","Ten","Eleven","Twelve","Thirteen","Fourteen","Fifteen","Sixteen","Seventeen","Eighteen","Nineteen"};
    vector<string> strList2 = {"Zero","Ten","Twenty","Thirty","Forty","Fifty","Sixty","Seventy","Eighty","Ninety"};
    vector<string> strList3 = {""," Thousand"," Million"," Billion"};
  
    string translate(int num)
    {
        if(num == 0)
            return "";
        string result;
        int hundred = num/100;
        int decade = (num%100)/10;
        int unit = num%10;

        if(hundred != 0)
            result += strList1[hundred] + " Hundred";
      
        num %= 100;
        if(num>0)
        {
            if(hundred != 0)
                result += " ";
              
            if(num<20)
                result += strList1[num];
            else
            {
                result += strList2[decade];
                if(unit != 0)
                    result += " " + strList1[unit];
            }
        }
        return result;
    }
    string numberToWords(int num) 
    {
        if(num == 0)
            return "Zero";
          
        string result;
        int temp;
        int base = 1000000000;
        for(int i = 3;i>=0;i--)
        {
            temp = (num/base)%1000;
            if(temp !=0)
            {
                if(result.size() != 0)
                    result += " ";
                result += translate(temp) + strList3[i];
            }
            base /= 1000;
        }
        return result;
    }
$0
endsnippet

# 274
snippet hIndex "comment " b
/* code by 王江 DC-Melo */

bool cmp(int i, int j){
    return i>j;
}

class Solution {
public:
    int hIndex(vector<int>& citations) {
        sort(citations.begin(),citations.end(),cmp);
        int i;
        for(i=0;i<citations.size();i++){
            if(citations[i]<(i+1))
                return i;
        }
        return i;
    }
};
$0
endsnippet

# 278
snippet firstBadVersion "comment " b
/* code by 王江 DC-Melo */

// Forward declaration of isBadVersion API.
bool isBadVersion(int version);

class Solution {
public:
    int firstBadVersion(int n) {
        int i=1;
        int j=n;
        while(i<=j)
        {
            int mid=(j-i)/2+i;
            if(isBadVersion(mid))
            {
                j=mid-1;
            }
            else
            {
                i=mid+1;
            }
        }
        return i;
    }
$0
endsnippet

# 283
snippet moveZeroes "comment " b
/* code by 王江 DC-Melo */

class Solution {
public:
    void moveZeroes(vector<int>& nums) 
    {
        int count = 0;
        for(int i=0;i<nums.size();i++)
        {
            if(nums[i] == 0)
            {
                count += 1;
            }
            else
            {
                swap(nums[i-count],nums[i]);
            }
        }
    }
$0
endsnippet

# 287
snippet findTheDuplicateNumber "comment " b
/* code by 王江 DC-Melo */

class Solution 
{
public: 
    int findDuplicate(vector<int>& nums) 
    {
        int min = 0, max = nums.size() - 1;
        while(min <= max)
        {
            // 找到中间那个数
            int mid = min + (max - min) / 2;
            int cnt = 0;
            // 计算总数组中有多少个数小于等于中间数
            for(int i = 0; i < nums.size(); i++)
            {
                if(nums[i] <= mid)
                {
                    cnt++;
                }
            }
            // 如果小于等于中间数的数量大于中间数，说明前半部分必有重复
            if(cnt > mid)
            {
                max = mid - 1;
            // 否则后半部分必有重复
            } 
            else 
            {
                min = mid + 1;
            }
        }
        return min;
    }
$0
endsnippet

# 290
snippet wordPattern "comment " b
/* code by 王江 DC-Melo */

class Solution 
{
public:
    bool wordPattern(string pattern, string str) 
    {
        vector<string> strList;
        string temp;
        for(int i=0;i<str.size();i++)
        {
            if(str[i] != ' ')
                temp += str[i];
            else
            {
                strList.push_back(temp);
                temp = "";
            }
        }
        strList.push_back(temp);
      
        if(pattern.size() != strList.size())
            return false;
          
        unordered_map<char,string> table1;
        for(int i=0;i<pattern.size();i++)
        {
            if(table1.find(pattern[i]) == table1.end())
                table1[pattern[i]] = strList[i];
            else
            {
                if(table1[pattern[i]] != strList[i])
                    return false;
            }
        }
      
        unordered_map<string,char> table2;
        for(int i=0;i<strList.size();i++)
        {
            if(table2.find(strList[i]) == table2.end())
                table2[strList[i]] = pattern[i];
            else
            {
                if(table2[strList[i]] != pattern[i])
                    return false;
            }
        }
        return true;
    }
$0
endsnippet

# 292
snippet nimGame "comment " b
/* code by 王江 DC-Melo */

class Solution 
{
public:
    bool canWinNim(int n) 
    {
        return n % 4 != 0;
    }
$0
endsnippet

# 299
snippet bullsAndCows "comment " b
/* code by 王江 DC-Melo */

class Solution 
{
public:
    string getHint(string secret, string guess) 
    {
        string result;
        int c = 0;
        for(int i=0;i<secret.size();i++)
        {
            if(secret[i] == guess[i])
                c++;
        }
        result = to_string(c)+"A";
      
        vector<int> tableS(10),tableG(10);
        for(int i=0;i<secret.size();i++)
        {
            tableS[secret[i]-'0']++;
            tableG[guess[i]-'0']++;
        }
        int t = 0;
        for(int i=0;i<10;i++)
        {
            if(tableS[i] > tableG[i])
                t += tableG[i];
            else
                t += tableS[i];
        }
        result += to_string(t-c) + "B";
        return result;
    }
$0
endsnippet

# 300
snippet longestIncreasingSubsequence "comment " b
/* code by 王江 DC-Melo */

class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {        
        int maxlen = 0;
      
        vector<int> dp(nums.size());
        for(int i=0;i<nums.size();i++){
            int max_dp = 0;
            for(int j=0;j<i;j++){
                if(nums[i] > nums[j])
                    max_dp = max(dp[j], max_dp);
            }
            dp[i] = max_dp + 1;
            maxlen = max(dp[i], maxlen);
        }
        return maxlen;
    }
};
$0
endsnippet

# 303
snippet rangeSumQuery---Immutable "comment " b
/* code by 王江 DC-Melo */

class NumArray 
{
public:
    vector<int> sums;
    NumArray(vector<int> &nums) 
    {
        int sum = 0;
        for(int i=0;i<nums.size();i++)
        {
            sum += nums[i];
            sums.push_back(sum);
        }
    }

    int sumRange(int i, int j) 
    {
        if(i>0)
            return sums[j] - sums[i-1];
        return sums[j];
    }
};


// Your NumArray object will be instantiated and called as such:
// NumArray numArray(nums);
// numArray.sumRange(0, 1);
$0
endsnippet
# // numArray.sumRange(1, 2);::::::::::::::
# 304
snippet rangeSumQuery2D---Immutable "comment " b
/* code by 王江 DC-Melo */

class NumMatrix {
public:
    vector<vector<int>> dp;
    int row;
    int col;
    NumMatrix(vector<vector<int>> matrix) {
        row = matrix.size();
        col = row>0?matrix[0].size():0;
        dp = vector<vector<int>>(row+1, vector<int>(col+1,0));
      
        //
        for(int i=1;i<row+1;i++)
            for(int j=1;j<col+1;j++)
                dp[i][j] = matrix[i-1][j-1] + dp[i][j-1] + dp[i-1][j] - dp[i-1][j-1];
    }
  
    int sumRegion(int row1, int col1, int row2, int col2) {
        return dp[row2+1][col2+1] - dp[row2+1][col1] - dp[row1][col2+1] + dp[row1][col1];
    }
};

/**
 * Your NumMatrix object will be instantiated and called as such:
 * NumMatrix obj = new NumMatrix(matrix);
 * int param_1 = obj.sumRegion(row1,col1,row2,col2);
$0
endsnippet
 # */::::::::::::::
# 309
snippet bestTimeToBuyAndSellStockWith-Cooldown "comment " b
/* code by 王江 DC-Melo */

class Solution {
public:
    int maxProfit(vector<int>& prices){
        if (prices.size() <= 1) return 0;
        vector<int> s0(prices.size(), 0);
        vector<int> s1(prices.size(), 0);
        vector<int> s2(prices.size(), 0);
        s1[0] = -prices[0];
        s0[0] = 0;
        s2[0] = INT_MIN;
        for (int i = 1; i < prices.size(); i++) {
            s0[i] = max(s0[i - 1], s2[i - 1]);
            s1[i] = max(s1[i - 1], s0[i - 1] - prices[i]);
            s2[i] = s1[i - 1] + prices[i];
        }
        return max(s0[prices.size() - 1], s2[prices.size() - 1]);
    }
$0
endsnippet

# 318
snippet maximumProductOfWordLengths "comment " b
/* code by 王江 DC-Melo */

class Solution 
{
public:
    int maxProduct(vector<string>& words) 
    {
        vector<int> bitmap(words.size(),0);
        for(int i=0;i<words.size();i++)
        {
            for(int j=0;j<words[i].size();j++)
            {
                bitmap[i] |= 1<<(words[i][j]-'a');
            }
        }
        int max = 0;
        int temp;
        for(int i=0;i<words.size();i++)
        {
            for(int j=i+1;j<words.size();j++)
            {
                if( (bitmap[i] & bitmap[j]) == 0)
                {
                    temp = words[i].size()*words[j].size();
                    max = temp>max?temp:max;
                }
            }
        }
        return max;
    }
$0
endsnippet

# 319
snippet bulbSwitcher "comment " b
/* code by 王江 DC-Melo */

class Solution 
{
public:
    int bulbSwitch(int n) 
    {
        return sqrt(n);
    }
$0
endsnippet

# 324
snippet wiggleSortII "comment " b
/* code by 王江 DC-Melo */

class Solution {
public:
    void wiggleSort(vector<int>& nums) {
        int n = nums.size();
  
        // Find a median.
        auto midptr = nums.begin() + n / 2;
        nth_element(nums.begin(), midptr, nums.end());
        int mid = *midptr;

        // Index-rewiring.
        #define A(i) nums[(1+2*(i)) % (n|1)]

        // 3-way-partition-to-wiggly in O(n) time with O(1) space.
        int i = 0, j = 0, k = n - 1;
        while (j <= k) {
            if (A(j) > mid)
                swap(A(i++), A(j++));
            else if (A(j) < mid)
                swap(A(j), A(k--));
            else
                j++;
        }
    }
};
$0
endsnippet

# 326
snippet powerOfThree "comment " b
/* code by 王江 DC-Melo */

class Solution 
{
public:
    bool isPowerOfThree(int n) 
    {
        while (n && (n % 3 == 0)) n /= 3;
        return n == 1;
    }
$0
endsnippet

# 328
snippet oddEvenLinkedList "comment " b
/* code by 王江 DC-Melo */

/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* oddEvenList(ListNode* head) 
    {
        ListNode *oddList = new ListNode(0);
        ListNode *evenList = new ListNode(0);
      
        ListNode *oddIte = oddList;
        ListNode *evenIte = evenList;
      
        for(int i=1;head != NULL;i++)
        {
            if(i & 0x01) // 计数，判断奇偶
            {
                oddIte->next = head;
                oddIte = oddIte->next;
                head = head->next;
                oddIte->next = NULL;
            }
            else
            {
                evenIte->next = head;
                evenIte = evenIte->next;
                head = head->next;
                evenIte->next = NULL;
            }
        }
      
        oddIte->next = evenList->next; //偶数链接到奇数链后
        head = oddList->next;
      
        delete oddList, evenList; // 回收两个头节点
        return oddList->next;
    }
$0
endsnippet

# 338
snippet countingBits "comment " b
/* code by 王江 DC-Melo */

/* 每个数向右移1位（除以2）后，
二进制表示里的'1'的个数要么与原来相等（偶数，末位是'0')，
要么少了一个（奇数，末位是'1')。

所以在程序循环中，若计算array[i]的'1'的个数，因为之前已经计算过array[i/2]，
此时只需判断array[i]的奇偶性，就可以计算array[i]的'1'的个了。
*/

class Solution {
public:
    vector<int> countBits(int num) 
    {
        vector<int> results = vector<int>(num+1, 0);
        for(int i=1;i<=num;i++)
        {
            results[i] = results[ i >> 1 ] + (i & 1);
        }
        return results;
    }
$0
endsnippet

# 342
snippet powerOfFour "comment " b
/* code by 王江 DC-Melo */

class Solution 
{
public:
    bool isPowerOfFour(int num) 
    {
        return num>0 && !(num&(num-1)) && (num & 0x55555555);
    }
$0
endsnippet

# 343
snippet integerBreak "comment " b
/* code by 王江 DC-Melo */

class Solution {
public:
    int integerBreak(int n) {
        if(n == 2)
            return 1;
        else if(n == 3)
            return 2;
        else if(n%3 == 0)
            return pow(3, n/3);
        else if(n%3 == 1)
            return 2 * 2 * pow(3, (n - 4) / 3);
        else 
            return 2 * pow(3, n/3);
    }
$0
endsnippet

# 344
snippet reverseString "comment " b
/* code by 王江 DC-Melo */

class Solution 
{
public:
    string reverseString(string s) 
    {
        string result(s);
        for(int i=0;i<s.size();i++)
        {
            result[s.size()-1-i] = s[i];
        }
        return result;
    }
$0
endsnippet

# 345
snippet reverseVowelsOfAString "comment " b
/* code by 王江 DC-Melo */

class Solution 
{
public:
    void swap(string &str,int pos1,int pos2)  
    {  
        char temp = str[pos2];  
        str[pos2] = str[pos1];  
        str[pos1] = temp;  
    }  
  
    string reverseVowels(string s) 
    {
        char base[10]={'a','e','i','o','u','A','E','I','O','U'};
        set<char> seting(base,base+10);
        int startpos=0,endpos=s.size()-1;
        while(startpos < endpos )
        {
            while( startpos < endpos && seting.find(s[startpos]) == seting.end())
                startpos++;
            while( startpos < endpos && seting.find(s[endpos]) == seting.end())
                endpos--;
            if(startpos < endpos)    
                swap(s,startpos++,endpos--);    
        }
        return s;
    };
$0
endsnippet

# 347
snippet topKFrequentElements "comment " b
/* code by 王江 DC-Melo */

bool cmp(pair<int ,int> p1 , pair<int, int> p2)
{
    return p1.first > p2.first;
}
class Solution 
{
public:
    vector<int> topKFrequent(vector<int>& nums, int k) 
    {
        map<int, int> count;
        for(auto i:nums)
            count[i]++;
          
        vector<pair<int, int> > table;
        for(auto i:count)
            table.push_back(pair<int, int>(i.second, i.first));
        sort(table.begin(), table.end(), cmp);
      
        vector<int> result;
        for(int i=0;i<k;i++)
            result.push_back(table[i].second);
        return result;
    }
$0
endsnippet

# 349
snippet intersectionOfTwoArrays "comment " b
/* code by 王江 DC-Melo */

class Solution 
{
public:
    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) 
    {
        sort(nums1.begin(),nums1.end());
        sort(nums2.begin(),nums2.end());
        vector<int> result;
        int i=0,j=0;
        while(i<nums1.size() && j<nums2.size())
        {
            if(nums1[i]==nums2[j])
            {
                //去重
                if(result.empty() || result.back() != nums1[i])
                    result.push_back(nums1[i]);
                i++;
                j++;
            }
            else if(nums1[i]<nums2[j])
                i++;
            else
                j++;
        }
        return result;
    }
$0
endsnippet

# 350
snippet intersectionOfTwoArraysII "comment " b
/* code by 王江 DC-Melo */

class Solution 
{
public:
    vector<int> intersect(vector<int>& nums1, vector<int>& nums2) 
    {
        sort(nums1.begin(),nums1.end());
        sort(nums2.begin(),nums2.end());
        vector<int> result;
        int i=0,j=0;
        while(i<nums1.size() && j<nums2.size())
        {
            if(nums1[i]==nums2[j])
            {
                result.push_back(nums1[i]);
                i++;
                j++;
            }
            else if(nums1[i]<nums2[j])
                i++;
            else
                j++;
        }
        return result;   
    }
$0
endsnippet

# 357
snippet countNumbersWithUniqueDigits "comment " b
/* code by 王江 DC-Melo */

class Solution 
{
public:
    int countNumbersWithUniqueDigits(int n) 
    {
        int result=0;
        for(int i=0;i<n&&i<=10;i++)
        {
            int temp = 9;
            for(int j=0;j<i;j++)
            {
                temp *=9-j;
            }
            result += temp;
        }
        result += 1;
        return result;
    }
$0
endsnippet

# 367
snippet validPerfectSquare "comment " b
/* code by 王江 DC-Melo */

class Solution {
public:
    bool isPerfectSquare(int num) {
        if(num < 1) return false;
        if(num == 1) return true;
        int left = 0, right = num/2;
        while(left <= right)
        {
            long mid = (left+right)/2;
            long val = mid*mid;
            if(val == num) return true;
            else if(val > num) right = mid-1;
            else left = mid+1;
        }
        return false;
    }
$0
endsnippet

# 371
snippet sumOfTwoIntegers "comment " b
/* code by 王江 DC-Melo */

class Solution {
public:
    int getSum(int a, int b) {
        return a+b;
    }
$0
endsnippet

# 374
snippet guessNumberHigherOrLower "comment " b
/* code by 王江 DC-Melo */

// Forward declaration of guess API.
// @param num, your guess
// @return -1 if my number is lower, 1 if my number is higher, otherwise return 0
int guess(int num);

class Solution 
{
public:
    int guessNumber(int n) 
    {
        int low = 1, high = n;
        while(low <= high)
        {
            int mid = (high-low)/2+low, val = guess(mid);
            if(val == 0) return mid;
            else val==-1?high=mid-1:low=mid+1;
        }
        return -1;
    }
$0
endsnippet

# 378
snippet kthSmallestElementInASortedMatrix "comment " b
/* code by 王江 DC-Melo */

class Solution 
{
public:
    int kthSmallest(vector<vector<int>>& matrix, int k) 
    {
        vector<int> vec(matrix.size()*matrix[0].size());
        for(int i=0;i<matrix.size();i++)
            for(int j=0;j<matrix[0].size();j++)
                vec[i*matrix[0].size()+j]=matrix[i][j];
        sort(vec.begin(),vec.end());
        return vec[k-1];
    }
$0
endsnippet

# 382
snippet linkedListRandomNode "comment " b
/* code by 王江 DC-Melo */

/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution 
{
public:
    /** @param head The linked list's head.
        Note that the head is guaranteed to be not null, so it contains at least one node. */
    Solution(ListNode* head) 
    {
        this->head = head;
        this->len = 1;
        ListNode* temp = head;
        while(temp->next)
        {
            len++;
            temp = temp->next;
        }
    }
  
    /** Returns a random node's value. */
    int getRandom() 
    {
        int step = rand()%len;
        ListNode* temp = this->head;;
        for(int i=0;i<step;i++)
            temp = temp->next;
        return temp->val;
    }
    int len;
    ListNode* head;
};

/**
 * Your Solution object will be instantiated and called as such:
 * Solution obj = new Solution(head);
 * int param_1 = obj.getRandom();
$0
endsnippet
 # */::::::::::::::
# 383
snippet ransomNote "comment " b
/* code by 王江 DC-Melo */

class Solution {
public:
    bool canConstruct(string ransomNote, string magazine) 
    {
        int table[256];
        for(int i=0;i<256;i++)
            table[i] = 0;
        for(int i=0;i<ransomNote.size();i++)
            table[ransomNote[i]]--;
        for(int i=0;i<magazine.size();i++)
            table[magazine[i]]++;
        for(int i=0;i<256;i++)
            if(table[i] < 0)
                return false;
        return true;
    }
$0
endsnippet

# 384
snippet shuffleAnArray "comment " b
/* code by 王江 DC-Melo */

class Solution 
{
public:
    vector<int> nums;
    Solution(vector<int> nums):nums(nums) 
    {
      
    }
  
    /** Resets the array to its original configuration and return it. */
    vector<int> reset() 
    {
        return this->nums;
    }
  
    /** Returns a random shuffling of the array. */
    vector<int> shuffle() 
    {
        vector<int> shuffle(nums);
        int pos;
        for(int i=0;i<shuffle.size();i++)
        {
            pos = rand()%(shuffle.size()-i) + i;
            swap(shuffle[i],shuffle[pos]);
        }
        return shuffle;
    }
};

/**
 * Your Solution object will be instantiated and called as such:
 * Solution obj = new Solution(nums);
 * vector<int> param_1 = obj.reset();
 * vector<int> param_2 = obj.shuffle();
$0
endsnippet
 # */::::::::::::::
# 387
snippet firstUniqueCharacterInAString "comment " b
/* code by 王江 DC-Melo */

class Solution 
{
public:
    int firstUniqChar(string s) 
    {
        int table[26];
        memset(table,0,sizeof(table));
      
        for(int i=0;i<s.size();i++)
        {
            table[s[i]-'a'] += 1;
        }
        for(int i=0;i<s.size();i++)
        {
            if(table[s[i]-'a'] == 1)
                return i;
            // cout<<i<<" "<<s[i]<<" "<<table[s[i]]<<endl;
        }
        return -1;
    }
$0
endsnippet

# 389
snippet findTheDifference "comment " b
/* code by 王江 DC-Melo */

class Solution 
{
public:
    char findTheDifference(string s, string t) 
    {
        int count[26];
        for(int i=0;i<26;i++)
        {
            count[i] = 0;
        }
        for(int i=0;i<s.size();i++)
        {
            count[s[i]-'a']++;
        }
        for(int i=0;i<t.size();i++)
        {
            count[t[i]-'a'] -=1;
        }
        for(int i=0;i<26;i++)
        {
            if(count[i] < 0)
                return 'a'+i;
        }
        return 0;
    }
$0
endsnippet

# 391
snippet perfectRectangle "comment " b
/* code by 王江 DC-Melo */

bool cmp(pair<int, int> p1, pair<int, int> p2)
{
    if(p1.first == p2.first)
    {
        return p1.second<p2.second;
    }
    return p1.first<p2.first;
}
class Solution 
{
public:
    bool isRectangleCover(vector<vector<int>>& rectangles) 
    {
        vector<pair<int, int> > pointsList(rectangles.size()*4,pair<int, int>(0,0));
        int acreage = 0;
        for(int i=0;i<rectangles.size();i++)
        {
            //bottom-left point
            pointsList[i*4].first = rectangles[i][0];
            pointsList[i*4].second = rectangles[i][1];
            //top-right point
            pointsList[i*4+1].first = rectangles[i][2];
            pointsList[i*4+1].second = rectangles[i][3];
            //top-left point
            pointsList[i*4+2].first = rectangles[i][0];
            pointsList[i*4+2].second = rectangles[i][3];
            //bottom-right point
            pointsList[i*4+3].first = rectangles[i][2];
            pointsList[i*4+3].second = rectangles[i][1];
          
            acreage += (rectangles[i][2]-rectangles[i][0]) * (rectangles[i][3]-rectangles[i][1]);
      
            // cout<<pointsList[i*4].first<<" "<<pointsList[i*4].second<<endl;
            // cout<<pointsList[i*4+1].first<<" "<<pointsList[i*4+1].second<<endl;
            // cout<<pointsList[i*4+2].first<<" "<<pointsList[i*4+2].second<<endl;
            // cout<<pointsList[i*4+3].first<<" "<<pointsList[i*4+3].second<<endl<<endl;
        }
        // cout<<acreage<<endl;
        sort(pointsList.begin(),pointsList.end(),cmp);
      
        vector<pair<int, int> > vertex(1,pointsList[0]);
        // cout<<pointsList[0].first<<" "<<pointsList[0].second<<endl;
        for(int i=1;i<pointsList.size();i++)
        {
            // cout<<pointsList[i].first<<" "<<pointsList[i].second<<endl;
            if(pointsList[i] == vertex.back())
                vertex.erase(vertex.end()-1);
            else
                vertex.push_back(pointsList[i]);
        }
      
        if(vertex.size()!=4)
            return false;
          
        sort(vertex.begin(),vertex.end(),cmp);
        if(acreage != (vertex[2].first-vertex[0].first)*(vertex[1].second-vertex[0].second))
            return false;
        return true;
    }
$0
endsnippet

# 392
snippet isSubsequence "comment " b
/* code by 王江 DC-Melo */

class Solution 
{
public:
    bool isSubsequence(string s, string t) 
    {
        int i=0,j=0;
        while(i<s.size() && j<t.size())
        {
            // cout<<s[i]<<" "<<t[j]<<endl;
            if(s[i] == t[j])
                i++;
            j++;
        }
        if(i == s.size())
            return true;
        return false;
    }
$0
endsnippet

# 394
snippet decodeString "comment " b
/* code by 王江 DC-Melo */

class Solution {
public:
    string DFS(string s, int &k)
    {
        string ans;
        int cnt = 0;
        while(k < s.size())
        {
            if(isdigit(s[k])) cnt = cnt*10 + (s[k++]-'0');
            else if(s[k]=='[')
            {
                string tem = DFS(s, ++k);
                for(int i = 0; i < cnt; i++) ans += tem;
                cnt = 0;
            }
            else if(s[k]==']')
            {
                k++;
                return ans;
            }
            else ans += s[k++];
        }
        return ans;
    }
  
    string decodeString(string s) {
        int k = 0;
        return DFS(s, k);
    }
$0
endsnippet

# 396
snippet rotateFunction "comment " b
/* code by 王江 DC-Melo */

class Solution 
{
public:
    int maxRotateFunction(vector<int>& A) 
    {
        int n = A.size();
        if(n<=0)
            return 0;
        vector<int> F(n,0);
        int sum = 0;
        for(int i=0;i<n;i++)
        {
            F[0] += i*A[i];
            sum += A[i];
        }
        int max = F[0];
        for(int i=1;i<n;i++)
        {
            F[i] = F[i-1] + sum - A[n-i] - (n-1)*A[n-i];
            if(F[i] > max)
                max = F[i];
        }
        return max;
    }
$0
endsnippet

# 399
snippet evaluateDivision "comment " b
/* code by 王江 DC-Melo */

class Solution 
{
public:
    double DFS(unordered_map<string, unordered_map<string, double> > &graph, unordered_map<string, bool> &visited, double res, string dividend, string &divisor)
    {
        if(dividend == divisor)
        {
            return res;
        }
        visited[dividend] = true;
        for(unordered_map<string,double>::iterator ite = graph[dividend].begin();ite!=graph[dividend].end();ite++)
        {
            if(!visited[ite->first])
            {
                double t = DFS(graph,visited,res * ite->second,ite->first,divisor);
                if(t!=-1)
                    return t;
            }
        }
        return -1;
    }
  
    double calc(unordered_map<string, unordered_map<string,double> > &graph, unordered_map<string, bool> visited, pair<string,string> &querie)
    {
        if(graph.find(querie.first) == graph.end() 
        || graph.find(querie.second) == graph.end())
            return -1.0;
        if(querie.first == querie.second)
            return 1.0;
        return DFS(graph,visited,1,querie.first,querie.second);
    }
  
    vector<double> calcEquation(vector<pair<string, string>> equations, vector<double>& values, vector<pair<string, string>> queries) 
    {
        unordered_map<string, unordered_map<string,double> > graph;
        unordered_map<string, bool> visited;
        for(int i=0;i<equations.size();i++)
        {
            graph[equations[i].first][equations[i].second] = values[i];
            graph[equations[i].second][equations[i].first] = 1.0 / values[i];
            visited[equations[i].first] = false;
            visited[equations[i].second] = false;
        }
        vector<double> result;
        for(int i=0;i<queries.size();i++)
        {
            result.push_back(calc(graph,visited,queries[i]));
        }
        return result;
    }
$0
endsnippet

# 400
snippet nthDigit "comment " b
/* code by 王江 DC-Melo */

class Solution {
public:
    int findNthDigit(int n) {
        long digit = 1, ith = 1, base = 9;
        while(n > base*digit)
        {
            n -= base*(digit++);
            ith += base;
            base *= 10;
        }
        return to_string(ith+(n-1)/digit)[(n-1)%digit]-'0';
    }
$0
endsnippet

# 401
snippet binaryWatch "comment " b
/* code by 王江 DC-Melo */

class Solution 
{
public:
    //计算一个整数中二进制1的个数
    int numberOf1(int i)
    {
        int count = 0;
        while (i)
        {
            count++;
            i = (i - 1) & i;
        }
        return count;
    }
  
    vector<string> readBinaryWatch(int num) 
    {
        int t = 0;
        string q = to_string(t);
        q += "0";
        cout<<q<<endl;
      
        vector<vector<string> > timeList;
        for(int i=0;i<13;i++)
        {
            vector<string> temp;
            timeList.push_back(temp);
        }
      
        for(int hour=0;hour<12;hour++)
        {
            int ledOfHour = numberOf1(hour);
            for(int minute=0;minute<60;minute++)
            {
                int ledOfMinute = numberOf1(minute);
                string minuteStr = to_string(minute);
                if(minuteStr.size() == 1)
                    minuteStr = "0" + minuteStr;
                  
                string timeStr = to_string(hour) + ":" + minuteStr;
                timeList[ledOfHour + ledOfMinute].push_back(timeStr);
            }    
        }
        return timeList[num];
    }
$0
endsnippet

# 404
snippet sumOfLeftLeaves "comment " b
/* code by 王江 DC-Melo */

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution 
{
public:
    int sum;
  
    int traversal(TreeNode* root, bool isLeft)
    {  
        if(root)
        {
            if( !root->left && !root->right && isLeft)
                return root->val;
            return traversal(root->left, true) + traversal(root->right, false);
        }
        else
            return 0;
    }
  
    int sumOfLeftLeaves(TreeNode* root) 
    {
        return traversal(root,false);
    }
$0
endsnippet

# 405
snippet convertANumberToHexadecimal "comment " b
/* code by 王江 DC-Melo */

class Solution 
{
public:
    string toHex(int num) 
    {
        char *str = new char[8];
        sprintf(str, "%x", num);
        return string(str);
    }
$0
endsnippet

# 406
snippet queueReconstructionByHeight "comment " b
/* code by 王江 DC-Melo */

bool cmp(pair<int,int> p1,pair<int,int> p2)
{
    if(p1.first > p2.first)
        return true;
    if(p1.first == p2.first && p1.second < p2.second)
        return true;
    return false;
}
  
class Solution 
{
public:
    vector<pair<int, int>> reconstructQueue(vector<pair<int, int>>& people) 
    {
        sort(people.begin(),people.end(),cmp);
        vector<pair<int, int>> result;
        for(int i=0;i<people.size();i++)
        {
            if(people[i].second >= result.size())
                result.push_back(people[i]);
            else
                result.insert(result.begin()+people[i].second, people[i]);
        }
        return result;
    }
$0
endsnippet

# 409
snippet longestPalindrome "comment " b
/* code by 王江 DC-Melo */

class Solution 
{
public:
    int longestPalindrome(string s) 
    {
        bool table[256];
        memset(table,0,sizeof(table));
      
        int result = 0;
      
        for(int i=0;i<s.size();i++)
        {
            if(table[s[i]])
            {
                table[s[i]] = false;
                result += 2;
            }
            else
                table[s[i]] = true;
        }
        if(s.size() > result)
            result++;
        return result;
    }
$0
endsnippet

# 412
snippet fizzBuzz "comment " b
/* code by 王江 DC-Melo */

class Solution 
{
public:
    vector<string> fizzBuzz(int n) 
    {
        vector<string> result;
      
        for(int i=1;i<=n;i++)
        {
            if( i % 15 == 0 )
            {
                result.push_back("FizzBuzz");
            }
            else if( i % 3 == 0)
            {
                result.push_back("Fizz");
            }
            else if( i % 5 == 0)
            {
                result.push_back("Buzz");
            }
            else
            {
                result.push_back(to_string(i));
            }
        }
        return result;
    }
$0
endsnippet

# 413
snippet arithmeticSlices "comment " b
/* code by 王江 DC-Melo */

class Solution 
{
public:
    int numberOfArithmeticSlices(vector<int>& A) 
    {
        if(A.size() < 3)
            return 0;
        vector<int> diff;
        for(int i=0;i<A.size()-1;i++)
            diff.push_back(A[i+1]-A[i]);
        int count = 0, tempCount = 0;
        for(int i=0;i<diff.size()-1;i++)
        {
            if(diff[i] == diff[i+1])
                tempCount++;
            else
            {
                count += tempCount*(tempCount+1)/2;
                tempCount = 0;
            }
        }
        count += tempCount*(tempCount+1)/2;
      
        return count;
    }
$0
endsnippet

# 414
snippet thirdMaximumNumber "comment " b
/* code by 王江 DC-Melo */

class Solution 
{
public:
    int thirdMax(vector<int>& nums) 
    {
        set<int> num;
        for(int i=0;i<nums.size();i++)
        {
            num.insert(nums[i]);
        }
        set<int>::reverse_iterator it=num.rbegin();
        if(num.size()<3)
           return *it; 
         
        it++;
        it++;
        return *it;
    }
$0
endsnippet

# 415
snippet addStrings "comment " b
/* code by 王江 DC-Melo */

class Solution 
{
public:
    string addStrings(string num1, string num2) 
    {
        int bit1=0,bit2=0,bitResult=0; //num1的当前运算位，num2的当前运算位，当前位运算结果
        int bit=0,carry=0;//当前位运算后的值（不含进位），当前位运算结果的进位
      
        int resultSize;//结果字符串尺寸
        //结果字符串尺寸与较大的字符串相同
        if(num1.size() > num2.size())
            resultSize = num1.size();
        else
            resultSize = num2.size();
      
        int k = resultSize-1;//结果字符串的当前位指针
        string numResult(resultSize,'0');//结果字符串
      
        int i=num1.size()-1, j=num2.size()-1;//num1的当前位指针，num2的当前位指针
        while(k>=0)
        {
            //当num1的当前位指针小于0时，说明num1以运算完成，当前位用0参与运算。
            if(i>=0)
                bit1 = num1[i]-'0';
            else
                bit1 = 0;
          
            //num2与num1同理
            if(j>=0)
                bit2 = num2[j]-'0';
            else
                bit2 = 0;
              
            bitResult = bit1 + bit2 + carry; // 当前位运算结果，包含上一次的进位
            bit = bitResult % 10; //当前位值，去掉进位
            carry = bitResult / 10; //当前位的进位
            numResult[k] = char(bit + '0');  //为结果字符串的当前位赋值
            i--;j--;k--;
        }
        // 如果结果字符串的最大位产生进位
        if(carry >0 )
            numResult = "1" + numResult;
        return numResult;
    }
$0
endsnippet

# 419
snippet battleshipsInABoard "comment " b
/* code by 王江 DC-Melo */

class Solution 
{
public:
    int countBattleships(vector<vector<char>>& board) 
    {
        int count = 0;
        for(int i=0;i<board.size();i++)
        {
            for(int j=0;j<board[i].size();j++)
            {
                if(board[i][j] == 'X')
                {
                    if( (i==0 || board[i-1][j] != 'X') 
                    && (j==0 || board[i][j-1] != 'X') )
                        count++;
                }
            }
        }
        return count;
    }
$0
endsnippet

# 423
snippet reconstructOriginalDigitsFromEnglish "comment " b
/* code by 王江 DC-Melo */

class Solution 
{
public:
    string originalDigits(string s) 
    {
        vector<int> countLetter(26,0);
        for(int i=0;i<s.size();i++)
            countLetter[s[i]-'a']++;
        vector<int> countNum(10,0);
        countNum[0] = countLetter['z'-'a'];
        countNum[2] = countLetter['w'-'a'];
        countNum[4] = countLetter['u'-'a'];
        countNum[6] = countLetter['x'-'a'];
        countNum[8] = countLetter['g'-'a'];
        countNum[1] = countLetter['o'-'a']-countNum[0]-countNum[2]-countNum[4];
        countNum[3] = countLetter['h'-'a']-countNum[8];
        countNum[5] = countLetter['f'-'a']-countNum[4];
        countNum[7] = countLetter['v'-'a']-countNum[5];
        countNum[9] = (countLetter['n'-'a']-countNum[1]-countNum[7])/2;
      
        string result;
        for(int i=0;i<countNum.size();i++)
            for(int j=0;j<countNum[i];j++)
                result += i +'0';
        return result;
    }
$0
endsnippet

# 424
snippet longestRepeatingCharacterReplacement "comment " b
/* code by 王江 DC-Melo */

class Solution 
{
public:
    int characterReplacement(string s, int k) 
    {
        int len = s.length();
        int maxlen = 0,tl=0;//tl是tmp_len，当前字符的最长重复值
        for (int i = 0; i < len; ++i) 
        {
            if (i > 0 && s[i] == s[i-1]) 
                continue;
            char cur_letter = s[i];
            int count = k;
            int j;
            for (j = i+1; j < len; ++j) 
            {
                if (s[j] != cur_letter) 
                    count--;
                if (count < 0) 
                    break;
            }
            if(j==len&&count>0)
                tl=j-i+min(count,i);
            else 
                tl=j-i;
            maxlen = max(maxlen, tl);
        }
        return maxlen;
    }
$0
endsnippet

# 434
snippet numberOfSegmentsInAString "comment " b
/* code by 王江 DC-Melo */

class Solution 
{
public:
    int countSegments(string s) 
    {
        bool flag = false;
        int count = 0;
        for(int i=0;i<s.size();i++)
        {
            if(s[i] != ' ' && flag == false)
            {
                flag = true;
                count ++;
            }
            if(s[i] == ' ')
            {
                flag = false;
            }
        }
        return count;
    }
$0
endsnippet

# 435
snippet nonOverlappingIntervals "comment " b
/* code by 王江 DC-Melo */

/**
 * Definition for an interval.
 * struct Interval {
 *     int start;
 *     int end;
 *     Interval() : start(0), end(0) {}
 *     Interval(int s, int e) : start(s), end(e) {}
 * };
 */
class Solution {
public:
    int eraseOverlapIntervals(vector<Interval>& intervals) {
      
    }
$0
endsnippet

# 436
snippet findRightInterval "comment " b
/* code by 王江 DC-Melo */

/**
 * Definition for an interval.
 * struct Interval {
 *     int start;
 *     int end;
 *     Interval() : start(0), end(0) {}
 *     Interval(int s, int e) : start(s), end(e) {}
 * };
 */

bool cmp(pair<Interval,int> a,pair<Interval,int> b)
{
    return a.first.start <= b.first.start || (a.first.start==b.first.start&&a.first.end<=b.first.end);
}

class Solution 
{
public:
    vector<int> findRightInterval(vector<Interval>& intervals) 
    {
        int n=intervals.size();
        vector<int> ans(n,-1);
        vector<pair<Interval,int>> h;
        for(int i=0;i<n;i++)
            h.push_back(pair<Interval,int>(intervals[i],i));
        sort(h.begin(),h.end(),cmp);
        int i,j;
        for(i=0;i<n;i++)
        {
            for(j=i+1;j<n;j++)
            {
                if(h[j].first.start>=h[i].first.end)
                {
                    ans[h[i].second]=h[j].second;
                    break;
                }
            }
        }
        return ans;
    }
$0
endsnippet

# 437
snippet pathSumIII "comment " b
/* code by 王江 DC-Melo */

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution 
{
public:
    int dfs(TreeNode* root, int &sum, int tempSum)
    {
        if(!root)
            return 0;
        tempSum += root->val;
        int flag = 0;
        if(tempSum == sum)
            flag = 1;
        return flag + dfs(root->left,sum,tempSum) + dfs(root->right,sum,tempSum);
    }
  
    int pathSum(TreeNode* root, int sum) 
    {
        if(!root)
            return 0;
        return dfs(root, sum, 0) + pathSum(root->left, sum) + pathSum(root->right, sum);
    }
$0
endsnippet

# 438
snippet findAllAnagramsInAString "comment " b
/* code by 王江 DC-Melo */

class Solution 
{
public:
    vector<int> findAnagrams(string s, string p) 
    {
        vector<int> hash1(256), hash2(256);
        for(auto ch: p) 
            hash1[ch]++;
        int lenp = p.size(), lens = s.size();
        vector<int> ans;
        for(int i = 0; i < lens; i++)
        {
            hash2[s[i]]++;
            if(i >= lenp) 
                hash2[s[i-lenp]]--;
            if(hash1 == hash2) 
                ans.push_back(i-lenp+1);
        }
        return ans;
    }
$0
endsnippet

# 441
snippet arrangingCoins "comment " b
/* code by 王江 DC-Melo */

class Solution 
{
public:
    int arrangeCoins(int n) 
    {
        for(long long i=sqrt(2*(long long)n);i>0;i--)
        {
            if((1+i)*i/2 <= n)
                return i;
        }
        return 0;
    }
$0
endsnippet

# 447
snippet numberOfBoomerangs "comment " b
/* code by 王江 DC-Melo */

class Solution 
{
public:
    int combination(int n)
    {
        return n*(n-1);
    }
  
    int distance(pair<int,int> &point1, pair<int,int> &point2)
    {
        int a = abs(point1.first - point2.first);
        int b = abs(point1.second - point2.second); 
        return a*a + b*b;
    }
  
    int numberOfBoomerangs(vector<pair<int, int>>& points) 
    {
        int result = 0;
        for(int i=0;i<points.size();i++)
        {
            unordered_map<int,int> table;
            unordered_map<int,int>::iterator ite;
            for(int j=0;j<points.size();j++)
            {
                int d = distance(points[i],points[j]);
                // cout<<"a:"<<points[i].first<<","<<points[i].second<<" b:"<<points[j].first<<","<<points[j].second<<" d:"<<d<<endl;
                // ite = table.find(d); 
                // if(ite == table.end())
                //     table.insert(pair<int,int>(d,1));
                // else
                //     ite->second += 1;
                table[d]++;
            }
            for(ite=table.begin();ite!=table.end();ite++)
            {
                // cout<<"d:"<<ite->first<<" n:"<<ite->second<<endl;
                result += combination(ite->second);
                // cout<<"result = "<<result<<endl;
            }
                // cout<<endl;
        }
        return result;
    }
$0
endsnippet

# 448
snippet findAllNumbersDisappearedInAnArray "comment " b
/* code by 王江 DC-Melo */

class Solution 
{
public:
    vector<int> findDisappearedNumbers(vector<int>& nums) 
    {
        vector<int> result(nums.size(),-1);
        for(int i=0;i<nums.size();i++)
            result[nums[i]-1] = 1;
        int flag = 0;
        for(int i=0;i<result.size();i++)
        {
            if(result[i] == -1)
            {
                result[flag] = i+1;
                flag++;
            }
        }
        result.erase(result.begin()+flag, result.end());
        return result;
    }
$0
endsnippet

# 452
snippet minimumNumberOfArrowsToBurstBalloons "comment " b
/* code by 王江 DC-Melo */

bool cmp(pair<int, int> p1, pair<int, int> p2)
{
    if(p1.second<p2.second)
        return true;
    if(p1.second>p2.second)
        return false;
    return p1.first<p2.first;
}

class Solution 
{
public:
    int findMinArrowShots(vector<pair<int, int>>& points) 
    {
        if(points.size()==0)
            return 0;
        sort(points.begin(), points.end(), cmp);
        int shots=1;
        int x = points[0].second;
        for(auto i:points)
        {
            if(x<i.first)
            {
                x = i.second;
                shots++;
            }
        }
        return shots;
    }
$0
endsnippet

# 453
snippet minimumMovesToEqualArrayElements "comment " b
/* code by 王江 DC-Melo */

class Solution 
{
public:
    int minMoves(vector<int>& nums) 
    {
        int min = nums[0];
        for(int i=0;i<nums.size();i++)
        {
            if(nums[i] < min)
                min = nums[i];
        }
        int steps=0;
        for(int i=0;i<nums.size();i++)
        {
            steps += nums[i]-min;
        }
        return steps;
    }
$0
endsnippet

# 455
snippet assignCookies "comment " b
/* code by 王江 DC-Melo */

class Solution 
{
public:
    int findContentChildren(vector<int>& g, vector<int>& s) 
    {
        int n = g.size(),m = s.size();  
        sort(g.begin(),g.end());  
        sort(s.begin(),s.end());
      
        int i=0,j=0;
        while(i<n && j<m)
        {
            if(g[i] <= s[j])
                i++;
            j++;
        }
        return i;
    }
$0
endsnippet

# 459
snippet repeatedSubstringPattern "comment " b
/* code by 王江 DC-Melo */

class Solution 
{
public:
    bool ok(string str, int i)
    {
        string t(str,0,i);
        for(int j=i;j<str.size();j+=i)
        {
            if(t!=str.substr(j,i))
            return false;
        }
        return true;
    }
    bool repeatedSubstringPattern(string str) 
    {
        int n=str.size();
        for(int i=1;i<=n/2;i++)
        {
            if(n%i!=0) continue;
            if(ok(str,i))
            return true;
        }
        return false;
    }
$0
endsnippet

# 461
snippet hammingDistance "comment " b
/* code by 王江 DC-Melo */

class Solution 
{
public:
    int hammingDistance(int x, int y) 
    {
        int distance = 0;
        while(x||y)
        {
            if((x&1)^(y&1)==1) 
                distance += 1;
            x>>=1;
            y>>=1;
        }
        return distance;
    }
$0
endsnippet

# 462
snippet minimumMovesToEqualArrayElementsII "comment " b
/* code by 王江 DC-Melo */

class Solution 
{
public:
    int minMoves2(vector<int>& nums) 
    {
        sort(nums.begin(),nums.end());
        int m = nums[nums.size()/2];
        int moves = 0;
        for(int i=0;i<nums.size();i++)
            moves += abs(nums[i]-m);
        return moves;
    }
$0
endsnippet

# 463
snippet islandPerimeter "comment " b
/* code by 王江 DC-Melo */

class Solution 
{
public:
    int islandPerimeter(vector<vector<int>>& grid) 
    {
        int result = 0;
      
        for(int i=0;i<grid.size();i++)
        {
            for(int j=0;j<grid[0].size();j++)
            {
                if(grid[i][j] == 1)
                {
                    if( j-1 < 0                 || grid[i][j-1] == 0)
                        result += 1;
                    if( j+1 == grid[0].size()   || grid[i][j+1] == 0)
                        result += 1;
                    if( i-1 < 0                 || grid[i-1][j] == 0)
                        result += 1;
                    if( i+1 == grid.size()      || grid[i+1][j] == 0)
                        result += 1;
                }
            }
        }
      
        return result;
    }
$0
endsnippet

# 471
snippet simplifyPath "comment " b
/* code by 王江 DC-Melo */

class Solution 
{
public:
    string simplifyPath(string path) 
    {
        stack<string> s;
        string str;
        for(int i = 0; i < path.size(); i++)
        {
            if (path[i] == '/')
            {
                if (str == "..")
                {
                    if (!s.empty())
                        s.pop();
                }
                else if (str != "." && str != "")
                {
                    s.push(str);
                }

                str = "";
            }
            else
            {
                str += path[i];
            }
        }
      
        if (str == "..")
        {
            if (!s.empty())
                s.pop();
        }
        else if (str != "." && str != "")
            s.push(str);
      
        if (s.empty())
            return "/";
      
        string ret;
        while(!s.empty())
        {
            ret = "/" + s.top() + ret;
            s.pop();
        }
      
        return ret;
    }
$0
endsnippet

# 476
snippet numberComplement "comment " b
/* code by 王江 DC-Melo */

class Solution 
{
public:
    int findComplement(int num) 
    {
        int result = ~num;
        int count = 0;
        while(num>0)
        {
            num>>=1;
            count++;
        }
        return result ^ (INT_MAX<<count);
    }
$0
endsnippet

# 485
snippet maxConsecutiveOnes "comment " b
/* code by 王江 DC-Melo */

class Solution 
{
public:
    int findMaxConsecutiveOnes(vector<int>& nums) 
    {
        int max = 0,temp=0;;
        for(int i=0;i<nums.size();i++)
        {
            if(nums[i] == 1)
                temp++;
            else
            {
                if(temp>max)
                    max = temp;
                temp = 0;
            }
        }
        if(temp>max)
            max = temp;
        return max;
    }
$0
endsnippet

# 496
snippet nextGreaterElementI "comment " b
/* code by 王江 DC-Melo */

class Solution {
public:
    vector<int> nextGreaterElement(vector<int>& findNums, vector<int>& nums) {
        map<int, int> max;
        for(int i=0;i<nums.size();i++){
            for(int j=i+1;j<nums.size();j++){
                if(nums[j] > nums[i]){
                    max[nums[i]] = nums[j];
                    break;
                }
            }
        }
      
        vector<int> result(findNums.size(),0);
        for(int i=0;i<findNums.size();i++){
            if(max.find(findNums[i]) == max.end()){
                result[i] = -1;
            }else
                result[i] = max[findNums[i]];
        }
        return result;
    }
};
$0
endsnippet

# 498
snippet diagonalTraverse "comment " b
/* code by 王江 DC-Melo */

class Solution {
public:
    vector<int> findDiagonalOrder(vector<vector<int>>& matrix) {
        int row = matrix.size();
        int col = row>0?matrix[0].size():0;
        vector<int> result(row*col,0);
        int cur = 0;
        bool right = false;
        int i,j,minn,start;
        for(int sum = 0;sum<row + col - 1;sum++){
            if(right){
                minn = min(row,sum+1);
                start = max(sum-col+1,0);
                for(i=start;i<minn;i++){
                    result[cur] = matrix[i][sum-i];
                    cur++;
                }
            }else{
                minn = min(col,sum+1);
                start = max(sum-row+1,0);
                for(j=start;j<minn;j++){
                    result[cur] = matrix[sum-j][j];
                    cur++;
                }
            }
            right = !right;
        }
        return result;
    }
};
$0
endsnippet

# 503
snippet nextGreaterElementII "comment " b
/* code by 王江 DC-Melo */

class Solution {
public:
    vector<int> nextGreaterElements(vector<int>& nums) {
        vector<int> max;
        for(int i=0;i<nums.size();i++){
            int find = false;
            for(int j=(i+1)%nums.size();j!=i;j=(j+1)%nums.size()){
                if(nums[j] > nums[i]){
                    max.push_back(nums[j]);
                    find = true;
                    break;
                }
            }
            if(!find)
                max.push_back( -1);
        }
        return max;
    }
};
$0
endsnippet

# 506
snippet relativeRanks "comment " b
/* code by 王江 DC-Melo */

bool cmp(pair<int,int> i, pair<int,int> j){
    return j.first < i.first;
}

class Solution {
public:
    vector<string> findRelativeRanks(vector<int>& nums) {
        vector<pair<int, int> > mapp;
        for(int i=0;i<nums.size();i++){
            mapp.push_back(pair<int,int>(nums[i],i));
        }
        sort(mapp.begin(), mapp.end(), cmp);
      
        vector<string> str(nums.size());
        for(int i=0;i<mapp.size();i++){
            str[mapp[i].second] = to_string(i + 1);
        }
        if(mapp.size() > 0)
            str[mapp[0].second] = "Gold Medal";
        if(mapp.size() > 1)
            str[mapp[1].second] = "Silver Medal";
        if(mapp.size() > 2)
            str[mapp[2].second] = "Bronze Medal";
        return str;
    }
};
$0
endsnippet

# 523
snippet continuousSubarraySum "comment " b
/* code by 王江 DC-Melo */

class Solution {
public:
    bool checkSubarraySum(vector<int>& nums, int k) {
        bool flag = false;
        if(k==0)
            flag = true;
        vector<int> dp(nums.size(),0);
        for(int i=0;i<nums.size();i++){
            int sum = nums[i];
            for(int j=i+1;j<nums.size();j++){
                sum += nums[j];
                if(flag){
                    if(sum - k == 0)
                        return true;
                }
                else{
                    if (sum % k == 0)
                    return true;
                }
            }
        }
        return false;
    }
};
$0
endsnippet

# 645
snippet setMismatch "comment " b
/* code by 王江 DC-Melo */

class Solution {
public:
    vector<int> findErrorNums(vector<int>& nums) {
        vector <int> ans;
        for (int i = 0; i < nums.size(); i++) {
            int index = abs(nums[i]) - 1;
            if (nums[index] > 0) {
                nums[index] *= -1;
            }
            else {
                ans.push_back(index + 1);
            }
        }
        for (int i = 0; i < nums.size(); i++) {
            if (nums[i] > 0) {
                ans.push_back(i + 1);
            }
        }
        return ans;
    }
$0
endsnippet

# 674
snippet longestContinuousIncreasingSubsequence "comment " b
/* code by 王江 DC-Melo */

class Solution {
public:
    int findLengthOfLCIS(vector<int>& nums) {
        if(nums.size() == 0)
            return 0;
      
        int max = 1;
      
        for(int i=0;i<nums.size();i++){
            // cout << "i=" << i << ':' << endl;
            int temp = 1;
            for(int j=i;j+1<nums.size();j++){
                // cout << "  j=" << j << ':' << nums[j] << "," << nums[j+1] << endl;
                if(nums[j+1] > nums[j])
                    temp += 1;
                else
                    break;
            }
            if(temp > max)
                max = temp;
        }
        return max;
    }
};

$0
endsnippet

# 680
snippet validPalindromeII "comment " b
/* code by 王江 DC-Melo */

class Solution {
public:
    bool validPalindrome(string s) {
        bool skipFlag = true;
        bool result = true;
        for(int cur1=0, cur2=s.size()-1; cur1 < cur2; cur1++,cur2--){
            if(s[cur1] != s[cur2]){
                if(skipFlag && s[cur1+1] == s[cur2]){
                    cur1 ++;
                    skipFlag = false;
                }
                else{
                    result = false;
                    break;
                }
            }
        }
        if(result)
            return result;
      
        skipFlag = true;
        result = true;
        for(int cur1=0, cur2=s.size()-1; cur1 < cur2; cur1++,cur2--){
            if(s[cur1] != s[cur2]){
                if(skipFlag && s[cur1] == s[cur2-1]){
                    cur2 --;
                    skipFlag = false;
                }
                else{
                    result = false;
                    break;
                }
            }
        }
        return result;
    }
};
$0
endsnippet

# 746
snippet minCostClimbingStairs "comment " b
/* code by 王江 DC-Melo */

class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        vector<int> dp(cost.size(),0);
        int dp1 = cost[0];
        int dp2 = cost[1];
        int cur;
        for(int i=2;i<cost.size();i++){
           cur = min(dp1,dp2) + cost[i];
            dp1 = dp2;
            dp2 = cur;
        }
      
        return min(dp1,dp2);
    }
};
$0
endsnippet

# 762
snippet primeNumberOfSetBitsInBinaryRepresentation "comment " b
/* code by 王江 DC-Melo */

class Solution {
public:
    int countPrimeSetBits(int L, int R) {
        int arr[11] = {2,3,5,7,11,13,17,19,23,29,31};
        set<int> primeSet(arr,arr+11);
        int prime = 0;
        for(int i=L;i<=R;i++){
            int temp=0;
            int num = i;
            while(num>0){
                if(num & 1)
                    temp += 1;
                num  = num >> 1;
            }
            if(primeSet.find(temp) != primeSet.end())
                prime += 1;
        }
        return prime;
    }
};
$0
endsnippet

# 824
snippet goatLatin "comment " b
/* code by 王江 DC-Melo */

class Solution {
public:
    string toGoatLatin(string S) {
        string result;
        int i = 0;
        int count = 0;
        bool vowel = false;
        string word;
        while(i<S.size()){
            if(S[i]==' '){
                i++;
                continue;
            }else if(S[i]=='a'||S[i]=='A'||S[i]=='e'||S[i]=='E'||S[i]=='i'
                     ||S[i]=='I'||S[i]=='o'||S[i]=='O'||S[i]=='u'||S[i]=='U'){
                int j=0;
                for(;i+j<S.size();j++)
                    if(S[i+j] == ' ')
                        break;
                word = S.substr(i, j);
                result.append(word);
                result.append("ma");
                result.append(count+1, 'a');
                result.append(1, ' ');
                count += 1;
                i += j;
            }else{
                int j=0;
                for(;i+j<S.size();j++)
                    if(S[i+j] == ' ')
                        break;
                word = S.substr(i+1, j-1);
                result.append(word);
                result.append(1,S[i]);
                result.append("ma");
                result.append(count+1, 'a');
                result.append(1, ' ');
                count += 1;
                i += j;
            }
        }
        return result.substr(0,result.size()-1);
    }
};
$0
endsnippet

# 825
snippet friendsOfAppropriateAges "comment " b
/* code by 王江 DC-Melo */

class Solution {
public:
    int numFriendRequests(vector<int>& ages) {
        sort(ages.begin(),ages.end());
        int count = 0;
        int edge;
        for(int i=0;i<ages.size();i++){
            int j;
            edge = ages[i] * 0.5 + 7;
            for(j=i-1;j>=0;j--)
                if(ages[j] > edge)
                    count ++;
                else
                    break;
          
            for(j=i+1;j<ages.size();j++)
                if(ages[j] == ages[i] && ages[j] > edge)
                    count ++;
                else
                    break;
        }
      
        return count;
    }
};
$0
endsnippet

# 826
snippet mostProfitAssigningWork "comment " b
/* code by 王江 DC-Melo */

bool cmp(pair<int,int> i, pair<int,int> j){
    return i.first < j.first;
}

class Solution {
public:
    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {
        vector<pair<int,int> > prolist(difficulty.size());
        for(int i=0;i<difficulty.size();i++){
            prolist[i].first = difficulty[i];
            prolist[i].second = profit[i];
        }
      
        sort(prolist.begin(),prolist.end(),cmp);
      
        // vector<int> pro(profit.size());
        int maxpro = 0;
        for(int i=0;i<profit.size();i++){
            maxpro = max(maxpro,prolist[i].second);
            prolist[i].second = maxpro;
        }
        int result = 0;
        int temppro = 0;
        for(int i=0;i<worker.size();i++){
            temppro = 0;
            for(int j=0;j<difficulty.size();j++){
                if(worker[i] >= prolist[j].first)
                    temppro = prolist[j].second;
                else
                    break;
            }
            result += temppro;
        }
        return result;
    }
};
$0
endsnippet

# 897
snippet increasingOrderSearchTree "comment " b
/* code by 王江 DC-Melo */

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode *nt;
    TreeNode *cur;
    TreeNode* increasingBST(TreeNode* root) {
        nt = new TreeNode(0);
        cur = nt;
        midOrder(root);
        return nt->right;
    }
  
    int midOrder(TreeNode* node){
        if(node == NULL)
            return 0;
        midOrder(node->left);
        cur->right = new TreeNode(node->val);
        cur = cur->right;
        midOrder(node->right);
        return 0;
    }
};
$0
endsnippet

# 906
snippet superPalindromes "comment " b
/* code by 王江 DC-Melo */

class Solution {
public:
    bool larger(string a, string b){
        if(a.size() < b.size())
            return false;
        if(a.size() > b.size())
            return true;
        for(int i = 0; i < a.size(); i++){
            if(a[i] != b[i]) {
                return a[i] > b[i];
            }
        }
        return false;
    }
  
    string square(string input){
        // 平方
        long long temp = stoll(input);
        long long result = temp*temp;
        return to_string(result);
    }
    bool isPar(string input){
        // 回文        
        for(int l=0, r=input.size()-1;l<=r;l++,r--){
            if(input[l] != input[r])
                return false;
        }
        return true;
    }
  
    int superpalindromesInRange(string L, string R) {
        int n = R.size();
        vector<vector<string>> pool; // 按相同位数存储回文串
        for(int i=0; i<n/2+1; i++){
            vector<string> cur;
            if(i == 0){
                cur = {"0", "1", "2", "3", "4", "5", "6", "7","8", "9"};
            }else if(i == 1){
                cur = {"00", "11", "22", "33", "44", "55", "66", "77", "88", "99"};
            }else{
                vector<string> &prev = pool[i-2];
                for(auto &p:prev){
                    for(auto &dig:pool[0]){
                        cur.push_back(dig + p + dig);
                    }
                }
            }
            pool.push_back(cur);
        }
      
        // 统计符合条件的super
        int count = 0;
        for(auto &strs:pool){
            for(auto &str:strs){
                string super = square(str);
                if(isPar(super) && (larger(super, L) || super == L ) && (larger(R, super) || super == R ) ){
                    count ++;
                }
            }
        }
        return count;
    }
  
  
};
$0
endsnippet

# 914
snippet xOfAKindInADeckOf-Cards "comment " b
/* code by 王江 DC-Melo */

class Solution {
public:
    int get_gcd(int a, int b) {
        int h = max(a, b);
        int l = min(a, b);
      
        if (l == 0) return h;
      
        int m = h % l;
      
        while (m) {
            h = l;
            l = m;
            m = h % l;
        }
        return l;
    }
  
    bool hasGroupsSizeX(vector<int>& deck) {
        map<int, int> count;
      
        for(auto i:deck){
            if(count.find(i) != count.end())
                count[i] += 1;
            else
                count[i] = 1;
        }
      
        int min_gcd = count.begin()->second;
        int last = min_gcd;
        for(auto i=count.begin();i!=count.end();i++){
            min_gcd = min(min_gcd, get_gcd(i->second,last));
            last = i->second;
        }
        return min_gcd>=2;
    }
};
$0
endsnippet

# 915
snippet partitionArrayIntoDisjointIntervals "comment " b
/* code by 王江 DC-Melo */

class Solution {
public:
    int partitionDisjoint(vector<int>& A) {
        vector<int> max_left(A.size());
        vector<int> min_right(A.size());
        max_left[0] = A[0];
        for(int i=1;i<max_left.size();i++){
            max_left[i] = max(A[i],max_left[i-1]);
        }
      
        min_right.back() = A.back();
        for(int i=min_right.size()-2;i>=0;i--){
            min_right[i] = min(A[i],min_right[i+1]);
        }
      
        for(int i=0;i<A.size()-1;i++){
            if(max_left[i]<=min_right[i+1])
                return i+1;
        }
        return 0;
    }
};
$0
endsnippet

# 917
snippet reverseOnlyLetters "comment " b
/* code by 王江 DC-Melo */

class Solution {
public:
    string reverseOnlyLetters(string S) {
        int l=0,r=S.size()-1;
        while(l<r){
            while(!isalpha(S[l]))
                l++;
            while(!isalpha(S[r]))
                r--;
            if(l<r){
                swap(S[l],S[r]);
                l++;
                r--;
            }
        }
        return S;
    }
};
$0
endsnippet

# 918
snippet maximumSumCircularSubarray "comment " b
/* code by 王江 DC-Melo */

class Solution {
public:
    int maxSubarraySumCircular(vector<int>& A) {
        if(A.size()==0)
            return 0;
        if(A.size()==1)
            return A[0];
        int ans=INT_MIN;
        int tol=0;
        int least=0;
        int num=INT_MAX;
        int sum=0;
        for(auto ele : A){
            tol+=ele;
            sum+=ele;
            if(sum<0){
                ans=max(ans,ele);
                sum=0;
            }else{
                ans=max(sum,ans);
            }
            least+=ele;
            if(least>0)
                least=0;
            else
                num=min(least,num);
        }
        if(ans<=0)
            return ans;
        else
            return max(ans,tol-num);
    }
};
$0
endsnippet

# 919
snippet completeBinaryTreeInserter "comment " b
/* code by 王江 DC-Melo */

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class CBTInserter {
public:
    TreeNode* r;
    queue<TreeNode *> q;
    CBTInserter(TreeNode* root) {
        r = root;
        queue<TreeNode *> tq;
        tq.push(r);
        TreeNode *t;
        while(tq.size()>0){
            t = tq.front();
            tq.pop();
            if(t->left != NULL)
                tq.push(t->left);
            if(t->right != NULL)
                tq.push(t->right);
            if(t->left == NULL || t->right == NULL)
                q.push(t);
        }
    }
  
    int insert(int v) {
        TreeNode *t = new TreeNode(v);
        TreeNode *n = q.front();
        if(n->left == NULL){
            n->left = t;
        }else{
            n->right = t;
            q.pop();
        }
        q.push(t);
        return n->val;
    }
  
    TreeNode* get_root() {
        return r;
    }
};

/**
 * Your CBTInserter object will be instantiated and called as such:
 * CBTInserter obj = new CBTInserter(root);
 * int param_1 = obj.insert(v);
 * TreeNode* param_2 = obj.get_root();
 */
$0
endsnippet

# 925
snippet longPressedName "comment " b
/* code by 王江 DC-Melo */

class Solution {
public:
    bool isLongPressedName(string name, string typed) {
        vector<pair<char, int> > na, ty;
        char last='0';
        for(int i=0;i<name.size();i++){
            if(name[i] == last)
                na[na.size()-1].second += 1;
            else
                na.push_back(pair<char, int>(name[i], 1));
            last = name[i];
        }
      
        last='0';
        for(int i=0;i<typed.size();i++){
            if(typed[i] == last)
                ty[ty.size()-1].second += 1;
            else
                ty.push_back(pair<char, int>(typed[i], 1));
            last = typed[i];
        }
      
        if(na.size() != ty.size())
            return false;
        for(int i=0;i<na.size();i++){
            if( (na[i].first != ty[i].first) || (na[i].second > ty[i].second))
                return false;
        }
        return true;
    }
};
$0
endsnippet

# 926
snippet flipStringToMonotoneIncreasing "comment " b
/* code by 王江 DC-Melo */

class Solution {
public:
    int minFlipsMonoIncr(string S) {      
        vector<pair<int, int> > group;
        int t;
        int last = S[0]=='1'?1:0;
        group.push_back(pair<int,int>(last, 1));
        for(int i=1;i<S.size();i++){
            t = S[i]=='1'?1:0;
            if(t == last)
                group[group.size()-1].second += 1;
            else
                group.push_back(pair<int,int>(t, 1));
            last = t;
        }

      
        vector<int> leftOne(group.size(),0), rightZero(group.size(),0);
      
        for(int i=1;i<group.size();i++){
            leftOne[i] = group[i-1].first==1?group[i-1].second:0;
            leftOne[i] += leftOne[i-1];
        }
        for(int i=group.size()-2;i>=0;i--){
            rightZero[i] = group[i+1].first==0?group[i+1].second:0;
            rightZero[i] += rightZero[i+1];
        }

      
        int min = S.size();
        for(int i=0;i<group.size();i++)
            if(leftOne[i] + rightZero[i] < min)
                min = leftOne[i] + rightZero[i];
      
        return min;
    }
};
$0
endsnippet

# 929
snippet uniqueEmailAddresses "comment " b
/* code by 王江 DC-Melo */

class Solution {
public:
    int numUniqueEmails(vector<string>& emails) {
        set<string> mailset;
        for(int i=0;i<emails.size();i++){
            bool beforeAt = true;
            bool afterPlus = false;
            string temp;
            for(int j=0;j<emails[i].size();j++){
                if(emails[i][j] == '@'){
                    temp += emails[i][j];
                    beforeAt = false;
                }
                if(beforeAt && emails[i][j] == '+')
                    afterPlus = true;
                if(beforeAt && !afterPlus && emails[i][j] != '.')
                    temp += emails[i][j];
                if(!beforeAt)
                    temp += emails[i][j];
            }
            mailset.insert(temp);
        }
        return mailset.size();
    }
};
$0
endsnippet

# 930
snippet binarySubarraysWithSum "comment " b
/* code by 王江 DC-Melo */

class Solution {
public:
    int numSubarraysWithSum(vector<int>& A, int S) {
        vector<int> dp(A.size()+1,0);
      
        map<int, vector<int> > mapp;
      
        dp[0] = 0;
        for(int i=0;i<A.size();i++){
            dp[i+1] = dp[i] + A[i];
            if(mapp.count(dp[i+1])>0)
                mapp[dp[i+1]].push_back(i);
            else
                mapp[dp[i+1]] = vector<int>(1,i);
        }
      
      
        int num = 0;
        for(int i=0;i<A.size();i++){
            int del = S + dp[i];
            if(mapp.count(del)>0){
                for(int j=0;j<mapp[del].size();j++)
                    if(mapp[del][j] >= i)
                        num += 1;
            }
            // for(int j=i;j<A.size();j++){
            //     if(dp[j+1] - dp[i] == S)
            //         num += 1;
            // }
        }
        return num;
    }
};
$0
endsnippet

# 933
snippet numberOfRecentCalls "comment " b
/* code by 王江 DC-Melo */

class RecentCounter {
public:
    vector<int> list;
    RecentCounter() {
      
    }
  
    int ping(int t) {
        list.push_back(t);
        int last = t-3000 > 0? t-3000:0;
        int i=list.size()-1;
        for(;i>=0;i--){
            if(list[i]<last)
                break; 
        }
        return list.size() - i-1;
    }
};

/**
 * Your RecentCounter object will be instantiated and called as such:
 * RecentCounter* obj = new RecentCounter();
 * int param_1 = obj->ping(t);
 */
$0
endsnippet

# 934
snippet shortestBridge "comment " b
/* code by 王江 DC-Melo */

class Solution {
public:
    int shortestBridge(vector<vector<int>>& A) {
        queue<pair<int,int> > que;
      
        bool found = false;
        for(int i=0;i<A.size();i++){
            for(int j=0;j<A[0].size();j++){
                if(A[i][j] == 1){
                    found = true;
                    dfs(A, i,j,que);
                    break;
                }
            }
            if(found)
                break;
        }
      
        int x,y,step=0;
        while(que.size() != 0){
            int size = que.size();
            for(int i=0;i<size;i++){
                x = que.front().first;
                y = que.front().second;
                que.pop();

                if(x-1>=0 && A[x-1][y] != 2){
                    if(A[x-1][y] == 0){
                        A[x-1][y] = 2;
                        que.push(pair<int,int>(x-1,y));
                    }else if(A[x-1][y] == 1){
                        return step;
                    }
                }
                if(x+1<A.size() && A[x+1][y] != 2){
                    if(A[x+1][y] == 0){
                        A[x+1][y] = 2;
                        que.push(pair<int,int>(x+1,y));
                    }else if(A[x+1][y] == 1){
                        return step;
                    }
                }
                if(y-1>=0 && A[x][y-1] != 2){
                    if(A[x][y-1] == 0){
                        A[x][y-1] = 2;
                        que.push(pair<int,int>(x,y-1));
                    }else if(A[x][y-1] == 1){
                        return step;
                    }
                }
                if(y+1<A[0].size() && A[x][y+1] != 2){
                    if(A[x][y+1] == 0){
                        A[x][y+1] = 2;
                        que.push(pair<int,int>(x,y+1));
                    }else if(A[x][y+1] == 1){
                        return step;
                    }
                }
            }
            step += 1;
        }
        return step;
    }
  
    int dfs(vector<vector<int>>& A, int x, int y, queue<pair<int,int> > & que){
        if(A[x][y] == 1){
            que.push(pair<int,int>(x,y));
            A[x][y] = 2;
          
            if(x-1>=0)
                dfs(A, x-1,y,que);
            if(x+1<A.size())
                dfs(A, x+1,y,que);
            if(y-1>=0)
                dfs(A, x,y-1,que);
            if(y+1<A[0].size())
                dfs(A, x,y+1,que);
        }
      
        return 0;
    }
};
$0
endsnippet

# 937
snippet reorderLogFiles "comment " b
/* code by 王江 DC-Melo */

bool cmp(string s1, string s2){
    if(s1.back() >= '0' && s1.back() <= '9' && s2.back() >= '0' && s2.back() <= '9')
        return true;
    if(s2.back() >= '0' && s2.back() <= '9')
        return true;
    if(s1.back() >= '0' && s1.back() <= '9')
        return false;
    int i = s1.find(" ");
    s1 = s1.substr(i+1);
    i = s2.find(" ");
    s2 = s2.substr(i+1);
    return s1.compare(s2)<0;

}

int bubble_sort(vector<string> &nums){
    bool swapped;
    for(int i=0;i<nums.size();i++){
        // swapped标记用于检查内层循环是否发生交换，若没发生，则跳出，减少时间
        swapped = false;
        for(int j=0;j<nums.size()-i-1;j++){
            if(!cmp(nums[j],nums[j+1])){
                swap(nums[j],nums[j+1]);
                swapped = true;
            }
        }
        if(!swapped)
            break;
    }
    return 0;
}

class Solution {
public:
    vector<string> reorderLogFiles(vector<string>& logs) {
        // vector<string> letters;
        // for(int i=0;i<logs.size();i++)
        //     if(logs[i].back() < '0' || logs[i].back() > '9')
        //         letters.push_back(logs[i]);
      
        bubble_sort(logs);
        return logs;
    }
};
$0
endsnippet

# 938
snippet rangeSumOfBST "comment " b
/* code by 王江 DC-Melo */

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    int preOrder(TreeNode* root, int L, int R){
        if(root == NULL)
            return 0;
        if(root->val >= L && root->val <= R){
            return root->val + preOrder(root->left,L,R) + preOrder(root->right,L,R);
        }
        if(root->val < L){
            return preOrder(root->right,L,R);
        }
        if(root->val > R){
            return preOrder(root->left,L,R);
        }
        return 0;
    }
  
    int rangeSumBST(TreeNode* root, int L, int R) {
        return preOrder(root,  L,  R);
    }
};
$0
endsnippet

# 939
snippet minimumAreaRectangle "comment " b
/* code by 王江 DC-Melo */

int area(int x1,int x2,int p1,int p2){
    return (x2-x1)*(p2-p1);
}

class Solution {
public:
    int minAreaRect(vector<vector<int>>& points) {
        // 按X坐标分类，X坐标相同的分到同一个set中
        map<int, set<int> > pmap;
        for(int i=0;i<points.size();i++){
            if(pmap.find(points[i][0]) == pmap.end())
                pmap[points[i][0]] = set<int>();
            pmap[points[i][0]].insert(points[i][1]);
        }
      
        int minarea = INT_MAX;
      
        // 枚举一个X坐标，并取两个点
        for(map<int, set<int> >::iterator it1 = pmap.begin();it1 != pmap.end();it1++){
            int x1 = it1->first;
            for(set<int>::iterator p1 = (it1->second).begin();p1 != (it1->second).end();p1++){
                for(set<int>::iterator p2 = p1;p2 != (it1->second).end();p2++){
                    if(p1 == p2)
                        continue;
                    // 枚举另一个X坐标，查看是否有和上面两个点Y坐标相同的点。
                    for(map<int, set<int> >::iterator it2 = it1;it2 != pmap.end();it2++){
                        if(it1 == it2)
                            continue;
                        int x2 = it2->first;
                        if((it2->second).find(*p1) != (it2->second).end() && (it2->second).find(*p2) != (it2->second).end()){
                            int a = area(x1,x2,*p1,*p2);
                            minarea = min(a,minarea);
                        }
                    }
                }
            }
        }
        if(minarea == INT_MAX)
            return 0;
        return minarea;
    }
};
$0
endsnippet

# 940
snippet distinctSubsequencesII "comment " b
/* code by 王江 DC-Melo */

class Solution {
public:
    int distinctSubseqII(string S) {
        vector<long> endsWith(26,0);
        long mod = 1e9 + 7;
        for (auto c : S)
            endsWith[c - 'a'] = accumulate(begin(endsWith), end(endsWith), 1L) % mod;
        return accumulate(begin(endsWith), end(endsWith), 0L) % mod;  
    }
};
$0
endsnippet

# 941
snippet validMountainArray "comment " b
/* code by 王江 DC-Melo */

class Solution {
public:
    bool validMountainArray(vector<int>& A) {
        if(A.size()<3)
            return false;
        int last = A[0];
        int i;
        for(i=1;i<A.size();i++){
            if(A[i]>last){
                last = A[i];
            }else{
                break;
            }
        }
        if(i-1==0 || i-1==A.size()-1)
            return false;
        for(i;i<A.size();i++){
            if(A[i]>=last)
                return false;
            last = A[i];
        }
        return true;
    }
};
$0
endsnippet

# 942
snippet dIStringMatch "comment " b
/* code by 王江 DC-Melo */

class Solution {
public:
    vector<int> diStringMatch(string S) {
        int counti = 0, countd = 0;
        for(auto c:S){
            if(c == 'I')
                counti++;
        }
        countd = S.size()-counti;
      
        vector<int> A(S.size()+1);
        int iflag = countd, dflag = countd-1;
        if(S[0] == 'I'){
            A[0] = 0;
            iflag ++;
            dflag ++;
        }else{
            A[0] = A.size()-1;
        }
        for(int i=0;i<S.size();i++){
            if(S[i] == 'I'){
                A[i+1] = iflag;
                iflag += 1;
            }else{
                A[i+1] = dflag;
                dflag -= 1;
            }
        }
        return A;
    }
};
$0
endsnippet

# 943
snippet findTheShortestSuperstring "comment " b
/* code by 王江 DC-Melo */

class Solution {
public:
    int count_overlap(string &a, string &b){
        int s = min(a.size(),b.size());
        for(int i=s;i>0;i--){
            if(a.substr(a.size()-i) == b.substr(0,i))
                return i;
        }
        return 0;
    }
  
    int search(vector<string>& A, vector<vector<int> > &overlap, vector<bool> &used, int used_count, vector<int> &shortest_super, int &shortest_super_size, vector<int> &cur_super, int cur_super_size){
        // 所有字符串用完，和最短的super比较
        if(used_count == used.size()){
            if(cur_super_size < shortest_super_size){
                shortest_super = cur_super;
                shortest_super_size = cur_super_size;
            }
            return 0;
        }
      
        // 剪枝
        if(cur_super_size >= shortest_super_size)
            return 0;
      
        // 搜索
        for(int i=0;i<A.size();i++){
            if(!used[i]){
                used[i] = true;
                cur_super_size += A[i].size() - overlap[cur_super.back()][i];
                cur_super.push_back(i);
                search(A, overlap, used, used_count+1, shortest_super, shortest_super_size, cur_super, cur_super_size);
                cur_super.pop_back();
                cur_super_size -= A[i].size() - overlap[cur_super.back()][i];
                used[i] = false;
            }
        }
        return 0;
    }
  
    string shortestSuperstring(vector<string>& A) {
        // 计算两两之间的重叠
        vector<vector<int> > overlap(A.size(),vector<int>(A.size()));
        for(int i=0;i<overlap.size();i++){
            for(int j=i+1;j<overlap[0].size();j++){
                overlap[i][j] = count_overlap(A[i],A[j]);
                overlap[j][i] = count_overlap(A[j],A[i]);
            }
        }
      
        // 最短的super，只存下标
        vector<int> shortest_super;
        // 最短的super对应的长度
        int shortest_super_size = INT_MAX;
        // 当前super，只存下标
        vector<int> cur_super;
        // 标记已使用的字符串
        vector<bool> used(A.size(),false);
      
        for(int i=0;i<A.size();i++){
            used[i] = true;
            cur_super.push_back(i);
            search(A, overlap, used, 1, shortest_super, shortest_super_size, cur_super, A[i].size());
            cur_super.pop_back();
            used[i] = false;
        }
      
        // 根据下标，重建字符串
        string shortest = A[shortest_super[0]];
        for(int i=1;i<shortest_super.size();i++){
            shortest += A[shortest_super[i]].substr(overlap[shortest_super[i-1]][shortest_super[i]]);
        }
        return shortest;
    }
};
$0
endsnippet

# 944
snippet deleteColumnsToMakeSorted "comment " b
/* code by 王江 DC-Melo */

class Solution {
public:
    int minDeletionSize(vector<string>& A) {
        string last = A[0];
        int len = A[0].size();
        int del = 0;
        for(int i=1;i<A.size();i++){
            for(int j=0;j<len;j++){
                if(last[j] != '#'){
                    if(A[i][j] >= last[j])
                        last[j] = A[i][j];
                    else{
                        last[j] = '#';
                        del += 1;
                    }
                }
            }
        }
        return del;
    }
};
$0
endsnippet

# 945
snippet minimumIncrementToMakeArrayUnique "comment " b
/* code by 王江 DC-Melo */

class Solution {
public:
    int minIncrementForUnique(vector<int>& A) {
        if(A.size() == 0)
            return 0;
        sort(A.begin(),A.end());
        vector<int> n;
        int last = A[0];
        int move = 0;
        for(int i=1;i<A.size();i++){
            if(A[i] == last)
                n.push_back(A[i]);
            if(A[i] - last > 1){
                int d = A[i] - last - 1;
                for(int j=0;j<d && n.size()>0;j++){
                    last = last + 1;
                    move += last  - n[n.size()-1];
                    n.erase(n.end()-1);
                }
            }
            last = A[i];
        }
        for(int i=0;i<n.size();i++){
            last = last + 1;
            move += last  - n[i];
            // cout<<last<<endl;
        }
        return move;
    }
};
$0
endsnippet

# 946
snippet validateStackSequences "comment " b
/* code by 王江 DC-Melo */

class Solution {
public:
    bool validateStackSequences(vector<int>& pushed, vector<int>& popped) {
        vector<int> s;
        int i=0,j=0;
        while(i<pushed.size() && j<popped.size()){
            while(s.empty() || s.back()!=popped[j]){
                s.push_back(pushed[i]);
                i++;
            }
            while(!s.empty() && s.back()==popped[j]){
                s.pop_back();
                j++;
            }
        }
        return (s.size() == 0);
    }
};
$0
endsnippet

# 947
snippet mostStonesRemovedWithSameRowOrColumn "comment " b
/* code by 王江 DC-Melo */

class Solution {
public:
    map<int, vector<vector<int> > > xgroup;
    map<int, vector<vector<int> > > ygroup;
  
    int dfs(vector<vector<int>>& stones, vector<bool> &used, vector<int> &p){
        if(xgroup.find(p[0]) != xgroup.end()){
            for(auto i:xgroup.find(p[0])->second){
                if(!used[i[2]]){
                    used[i[2]] = true;
                    dfs(stones, used, i);
                }
            }
        }
        if(ygroup.find(p[1]) != ygroup.end()){
            for(auto i:ygroup.find(p[1])->second){
                if(!used[i[2]]){
                    used[i[2]] = true;
                    dfs(stones, used, i);
                }
            }
        }
        return 0;
    }
  
    int removeStones(vector<vector<int>>& stones) {
        for(int i=0;i<stones.size();i++){
            if(xgroup.find(stones[i][0]) == xgroup.end()){
                xgroup[stones[i][0]] = vector<vector<int> >();
            }
          
            if(ygroup.find(stones[i][1]) == ygroup.end()){
                ygroup[stones[i][1]] = vector<vector<int> >();
            }
          
            vector<int> t = stones[i];
            t.push_back(i);
            xgroup[stones[i][0]].push_back(t);
            ygroup[stones[i][1]].push_back(t);
        }
      
        vector<bool> used(stones.size(),false);
        int count=0;
        for(int i=0;i<stones.size();i++){
            if(used[i])
                continue;
            used[i] = true;
            dfs(stones, used, stones[i]);
            count ++;
        }
        return stones.size() - count;
    }
};
$0
endsnippet

# 948
snippet bagOfTokens "comment " b
/* code by 王江 DC-Melo */

class Solution {
public:
    int bagOfTokensScore(vector<int>& tokens, int P) {
        sort(tokens.begin(),tokens.end());
        int left = 0, right = tokens.size() - 1;
        int points = 0, ans = 0;
        while (left <= right && (P >= tokens[left] || points > 0)) {
            while (left <= right && P >= tokens[left]) {
                P -= tokens[left++];
                points++;
            }
            ans = max(ans, points);
            if (left <= right && points > 0) {
                P += tokens[right--];
                points--;
            }
        }
        return ans;
    }
};
$0
endsnippet

# 949
snippet largestTimeForGivenDigits "comment " b
/* code by 王江 DC-Melo */

class Solution {
public:
    string largestTimeFromDigits(vector<int>& A) {
        vector<bool> used(4,false);
        vector<int> result;
        for(int i=0;i<A.size();i++){
            if(A[i]<0 || A[i]>2)
                continue;
            int t1 = A[i];
            used[i] = true;
            for(int j=0;j<A.size();j++){
                if(used[j] || (t1==2 && (A[j]>3 || A[j]<0) ) )
                    continue;
                int t2 = t1*10 + A[j];
                used[j] = true;
                for(int k=0;k<A.size();k++){
                    if(used[k] || A[k]>5 || A[k]<0)
                        continue;
                    int t3 = t2*10 + A[k];
                    used[k] = true;
                    for(int y=0;y<A.size();y++){
                        if(used[y])
                            continue;
                        result.push_back(t3*10+A[y]);
                        // cout<<t3*10+A[y]<<endl;
                    }
                    used[k] = false;
                }
                used[j] = false;
            }
            used[i] = false;
        }
      
        if(result.empty())
            return "";
      
        vector<int>::iterator it = max_element(result.begin(), result.end());
        string r = to_string(*it);
        if(r.size()<4)
            r = string(4-r.size(),'0') + r;
      
        return r.substr(0,2) + ":" + r.substr(2);
    }
};
$0
endsnippet

# 950
snippet revealCardsInIncreasingOrder "comment " b
/* code by 王江 DC-Melo */

class Solution {
public:
    vector<int> deckRevealedIncreasing(vector<int>& deck) {
        sort(deck.begin(),deck.end());
        queue<int> q;
        for(int i=deck.size()-1;i>=0;i--){
            if(!q.empty()){
                int t = q.front();
                q.pop();
                q.push(t);
            }
            q.push(deck[i]);
        }
        vector<int> result(q.size());
        int i = q.size()-1;
        while(!q.empty()){
            result[i] = q.front();
            i--;
            q.pop();
        }
        return result;
    }
};
$0
endsnippet

# 951
snippet flipEquivalentBinaryTrees "comment " b
/* code by 王江 DC-Melo */

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool eq(TreeNode* n1, TreeNode* n2){
        if(n1 == NULL && n2 == NULL)
            return true;
        else if(n1 == NULL || n2 == NULL)
            return false;
        else{
            if(n1->val == n2->val)
                return true;
        }
        return false;
    }
  
    bool flipEquiv(TreeNode* root1, TreeNode* root2) {
        if(eq(root1,root2)){
            if(root1 != NULL){
                return flipEquiv(root1->left, root2->left) && flipEquiv(root1->right, root2->right) 
                    || flipEquiv(root1->left, root2->right) && flipEquiv(root1->right, root2->left);;
            }
            return true;
        }
        return false;
    }
};
$0
endsnippet

# 952
snippet largestComponentSizeByCommonFactor "comment " b
/* code by 王江 DC-Melo */

class Solution {
public:
    int p[100100], sz[100100];
  
    int find(int x) {
        return x == p[x] ? x : p[x] = find(p[x]);
    }
  
    void merge(int x, int y) {
        x = find(x);
        y = find(y);
        if(x == y) return;
        sz[x] += sz[y];
        p[y] = x;
    }
  
    int largestComponentSize(vector<int>& A) {
        bool mark[100100] = {0}, used[100100] = {0};
        for(int x : A) {
            mark[x] = 1;
            p[x] = x;
            sz[x] = 1;
        }
        // Sieve of erastosthenes
        for(long long i = 2; i <= 100000; i++) {
            if(!used[i]) {
                int last = -1;
                // i is a prime, union all numbers which has i as its factor.
                for(long long j = i; j <= 100000; j += i) {
                    used[j] = 1;
                    if(mark[j]) {
                        if(last != -1) merge(last, j);
                        last = j;
                    }
                }
            }
        }
        int ans = 0;
        for(int x : A) ans = max(ans, sz[x]);
        return ans;
    }
};
$0
endsnippet

# 953
snippet verifyingAnAlienDictionary "comment " b
/* code by 王江 DC-Melo */

class Solution {
public:
    bool less(string &s1, string &s2, map<char, int> &m){
        int l = min(s1.size(),s2.size());
        for(int i=0;i<l;i++){
            if(m[s1[i]]<m[s2[i]])
                return true;
            if(m[s1[i]]>m[s2[i]])
                return false;
        }
        if(s1.size() <= s2.size())
            return true;
        return false;
    }
    bool isAlienSorted(vector<string>& words, string order) {
        map<char, int> m;
        int i=0;
        for(char &a:order){
            m.insert(pair<char, int>(a,i));
            i++;
        }
      
        for(int i=1;i<words.size();i++){
            if(!less(words[i-1],words[i],m))
                return false;
        }
        return true;
    }
};
$0
endsnippet

# 954
snippet arrayOfDoubledPairs "comment " b
/* code by 王江 DC-Melo */

class Solution {
public:
    bool canReorderDoubled(vector<int>& A) {
        sort(A.begin(),A.end());
        unordered_map<int,int> used;
        for(auto &i:A){
            if(used.find(i) == used.end())
                used.insert(pair<int,int>(i,1));
            else
                used[i] ++;
        }
      
        for(int i=0;i<A.size();i++){
            if((used.find(A[i]) != used.end() ) && (used[A[i]] != 0 ) ){
                used[A[i]] --;
                int d = A[i] * 2;
                if(d < 0)
                    d = A[i] / 2;
                if((used.find(d) != used.end()) && (used[d] != 0)){
                    used[d] --;
                }
                else
                    return false;
            }
        }
        return true;
    }
};
$0
endsnippet

# 955
snippet deleteColumnsToMakeSortedII "comment " b
/* code by 王江 DC-Melo */

class Solution {
public:
    int lexicographic(vector<string>& A, vector<int> &col){
        for (int i=0; i<A.size()-1; i++){
            for(auto &j:col){
                if (A[i][j] < A[i+1][j])
                    break;
                if (A[i][j] > A[i+1][j])
                    return false;
            }
        }
        return true;
    }
  
    int minDeletionSize(vector<string>& A) {
        int l = A.size();
        int w = A[0].size();
      
        vector<int> col;
        int res=0;
        for(int i=0;i<w;i++){
            col.push_back(i);
            if(!lexicographic(A,col)){
                col.pop_back();
                res += 1;
            }
        }
        return res;
    }
};

$0
endsnippet

# 957
snippet prisonCellsAfterNDays "comment " b
/* code by 王江 DC-Melo */

class Solution {
public:
    int to_int(vector<int> cells){
        int a = 0;
        for(auto i:cells){
            a = a*2 + i;
        }
        return a;
    }
  
    vector<int> to_cells(int a){
        vector<int> c(8,0);
        for(int i=7;i>=0;i--){
            c[i] = a%2;
            a /= 2;
        }
        return c;
    }

    vector<int> next(vector<int> cells){
        vector<int> n = cells;
        n.front() = 0;
        n.back() = 0;
        for(int i=1;i<7;i++){
            if(cells[i-1] == cells[i+1])
                n[i] = 1;
            else
                n[i] = 0;
        }
        return n;
    }

    vector<int> prisonAfterNDays(vector<int>& cells, int N) {
        unordered_map<int, int> m;
        for(int i=0;i<256;i++){
            m.insert(pair<int,int>(i,to_int(next(to_cells(i)))) );
        }
      
        int cycle;
        vector<int> l;
        l.push_back(0);
        for(int i=0;i<256;i++){
            int t = m[l.back()];
            for(int j=0;j<l.size();j++){
                if(l[j] == t){
                    cycle = i-j+1;
                    break;
                }
            }
            l.push_back(t);
        }
      
        N = N % cycle;
        int result = to_int(cells);
        for(int i=0;i<N;i++){
            result = m[result];
        }
        return to_cells(result);
    }
};
$0
endsnippet

# 958
snippet checkCompletenessOfABinaryTree "comment " b
/* code by 王江 DC-Melo */

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool isCompleteTree(TreeNode* root) {
        queue<TreeNode*> q;
        q.push(root);
        TreeNode *t;
        bool flag=false;
        while(q.size()>0){
            t = q.front();
            q.pop();
            if(t==NULL){
                flag = true;
            }else{
                if(flag)
                    return false;
                q.push(t->left);
                q.push(t->right);
            }
        }
        return true;
    }
};
$0
endsnippet

# 959
snippet regionsCutBySlashes "comment " b
/* code by 王江 DC-Melo */

class Solution {
public:
    void dfs(vector<vector<int>>& g, int i, int j) {
        if (i >= 0 && j >= 0 && i < g.size() && j < g.size() && g[i][j] == 0) {
            g[i][j] = 1;
            dfs(g, i-1, j);
            dfs(g, i+1, j);
            dfs(g, i, j-1);
            dfs(g, i, j+1);
        }
    }
    int regionsBySlashes(vector<string>& grid) {
        int N = grid.size();
        vector<vector<int>> g(N*3, vector<int>(N*3, 0));
        for (int i=0; i<grid.size(); i++)
            for (int j=0; j<grid.size(); j++) {
                if (grid[i][j] == '/'){
                    g[i*3][j*3 + 2] = 1;
                    g[i*3 + 1][j*3 + 1] = 1;
                    g[i*3 + 2][j*3] = 1;
                }
                if (grid[i][j] == '\\'){
                    g[i*3][j * 3] = 1;
                    g[i*3 + 1][j*3 + 1] = 1;
                    g[i*3 + 2][j*3 + 2] = 1;
                }
        }
        int result = 0;
        for (int i=0; i<g.size(); i++){
            for (int j=0; j<g.size(); j++){
                if (g[i][j] == 0){
                    dfs(g, i, j);
                    result++;
                }
            }
        }
        return result;
    }
};
$0
endsnippet

# 973
snippet kClosestPointsToOrigin "comment " b
/* code by 王江 DC-Melo */


bool cmp(const vector<int> &p1, const vector<int> &p2){
    return (p1[0]*p1[0] + p1[1]*p1[1]) < (p2[0]*p2[0] + p2[1]*p2[1]);
}

class Solution {
public:
    vector<vector<int>> kClosest(vector<vector<int>>& points, int K) {
        sort(points.begin(), points.end(), cmp);
        return vector(points.begin(), points.begin()+K);
    }
};
$0
endsnippet

# 974
snippet subarraySumsDivisibleByK "comment " b
/* code by 王江 DC-Melo */

class Solution {
public:
    int subarraysDivByK(vector<int>& A, int K) {
        int sum = 0;
        int length = A.size();
        vector<int> mod(K,0);
        for(int i = 0; i < length; i++) {
        	sum += A[i];
        	mod[((sum % K) + K) % K]++; // as the sum can be negative, taking modulo twice
        }
      
        sum = 0;
        for(int i = 0; i < K; i++) {
        	if(mod[i] > 1) {
        		sum += (mod[i] - 1) * mod[i] / 2;
        	}
        }
        sum += mod[0];
        return sum;
    }
};
$0
endsnippet

# 976
snippet largestPerimeterTriangle "comment " b
/* code by 王江 DC-Melo */

bool cmp(int a, int b){
    return a > b;
}
class Solution {
public:
    int largestPerimeter(vector<int>& A) {
        sort(A.begin(), A.end(), cmp);
        for(int i=0;i<A.size();i++){
            for(int j=i+1;j<A.size();j++){
                if(A[j] < A[i]/2)
                    break;
                for(int k=j+1;k<A.size();k++){
                    if(A[k] + A[j] > A[i])
                        return A[i] + A[j] + A[k];
                    break;
                }
            }
        }
        return 0;
    }
};
$0
endsnippet

